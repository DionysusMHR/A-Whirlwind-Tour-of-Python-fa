<div dir=rtl>

|
<a href="08-دستورات کنترل جریان.md">دستورات کنترل جریان</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="10-خطاها و استثناها.md">خطاها و استثناها</a>
|


<h1>تعریف و استفاده از توابع</h1>


<p>تا کنون، اسکریپت‌های ما بلوک‌های کد ساده و تک‌کاربردی بوده‌اند. یکی از راه‌های سازمان‌دهی کد پایتون و افزایش قابلیت خوانایی و بازاستفاده، استخراج بخش‌های مفید و تبدیل آن‌ها به توابع قابل استفاده مجدد است. در این بخش، دو روش ایجاد تابع را بررسی می‌کنیم: دستور def که برای هر نوع تابعی مفید است و دستور lambda که برای ایجاد توابع کوتاه و ناشناس کاربرد دارد.</p>


<h2>استفاده از توابع</h2>


<p>توابع گروه‌هایی از کد هستند که نام دارند و می‌توان با استفاده از پرانتز آن‌ها را فراخوانی کرد. قبلاً با توابع آشنا شده‌ایم. به‌عنوان مثال، print در پایتون ۳ یک تابع است:</p>


<pre dir=ltr>
<font color=white>
print('abc')
</pre>
<p dir=ltr>abc</p>


<p>در اینجا، print نام تابع است و 'abc' آرگومان تابع محسوب می‌شود.</p>


<p>علاوه بر آرگومان‌ها، آرگومان‌های کلیدی (keyword arguments) نیز وجود دارند که با نام مشخص می‌شوند. یکی از آرگومان‌های کلیدی موجود برای تابع <b dir=ltr>print()</b> در پایتون ۳، sep است، که مشخص می‌کند چه کاراکتر یا کاراکترهایی برای جدا کردن آیتم‌های متعدد استفاده شود:</p>


<pre dir=ltr>
<font color=white>
print(1, 2, 3)
</pre>
<p dir=ltr>1 2 3</p>


<pre dir=ltr>
<font color=white>
print(1, 2, 3, sep='--')
</pre>
<p dir=ltr>1--2--3</p>


<p>هنگامی که آرگومان‌های غیرکلیدی (positional arguments) همراه با آرگومان‌های کلیدی استفاده می‌شوند، آرگومان‌های کلیدی باید در انتهای فهرست قرار گیرند.</p>


<h2>تعریف توابع</h2>


<p>توابع زمانی کاربردی‌تر می‌شوند که خودمان شروع به تعریف آن‌ها کنیم و عملکردهایی را سازمان‌دهی کنیم که در چندین بخش قابل استفاده باشند. در پایتون، توابع با دستور def تعریف می‌شوند. به‌عنوان مثال، می‌توانیم نسخه‌ای از کد دنباله فیبوناچی که در بخش قبلی داشتیم را به شکل زیر در یک تابع قرار دهیم:</p>


<pre dir=ltr>
<font color=white>
def fibonacci(N):
    L = []
    a, b = 0, 1
    while len(L) < N:
        a, b = b, a + b
        L.append(a)
    return L
</pre>


<p>حال ما یک تابع به نام fibonacci داریم که یک آرگومان به نام N می‌گیرد، کاری با این آرگومان انجام می‌دهد و یک مقدار بازمی‌گرداند؛ در این مثال، یک لیست شامل N عدد اول فیبوناچی بازگردانده می‌شود:</p>


<pre dir=ltr>
<font color=white>
fibonacci(10)
</pre>
<p dir=ltr>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</p>


<p>اگر با زبان‌های سخت‌نوع (strongly-typed) مانند C آشنا باشید، بلافاصله متوجه می‌شوید که هیچ اطلاعات نوعی برای ورودی‌ها یا خروجی‌های تابع در پایتون مشخص نمی‌شود. توابع پایتون می‌توانند هر شیء پایتون، چه ساده و چه مرکب، را بازگردانند، که این باعث می‌شود ساختارهایی که در دیگر زبان‌ها ممکن است دشوار باشند، در پایتون ساده و قابل‌فهم باشند.</p>


<p>به‌عنوان مثال، بازگرداندن چند مقدار به‌سادگی در یک tuple قرار می‌گیرد که با ویرگول‌ها مشخص می‌شود:</p>


<pre dir=ltr>
<font color=white>
def real_imag_conj(val):
    return val.real, val.imag, val.conjugate()

r, i, c = real_imag_conj(3 + 4j)
print(r, i, c)
</pre>
<p dir=ltr>3.0 4.0 (3-4j)</p>


<h2>مقادیر پیش‌فرض آرگومان‌ها</h2>


<p>اغلب هنگام تعریف یک تابع، مقادیری وجود دارند که می‌خواهیم تابع بیشتر اوقات از آن‌ها استفاده کند، اما همچنین می‌خواهیم به کاربر کمی انعطاف بدهیم. در این حالت می‌توانیم از مقادیر پیش‌فرض برای آرگومان‌ها استفاده کنیم. به تابع fibonacci که قبلاً داشتیم توجه کنید. چه می‌شد اگر می‌خواستیم کاربر بتواند با مقادیر شروع بازی کند؟ می‌توانیم این کار را به شکل زیر انجام دهیم:</p>



<pre dir=ltr>
<font color=white>
def fibonacci(N, a=0, b=1):
    L = []
    while len(L) < N:
        a, b = b, a + b
        L.append(a)
    return L
</pre>


<p>با یک آرگومان، نتیجهٔ فراخوانی تابع همانند قبل خواهد بود:</p>


<pre dir=ltr>
<font color=white>
fibonacci(10)
</pre>
<p dir=ltr>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</p>


<p>اما اکنون می‌توانیم از تابع برای کشف موارد جدید استفاده کنیم، مانند تأثیر مقادیر شروع جدید:</p>


<pre dir=ltr>
<font color=white>
fibonacci(10, 0, 2)
</pre>
<p dir=ltr>[2, 2, 4, 6, 10, 16, 26, 42, 68, 110]</p>


<p>همچنین می‌توان مقادیر را در صورت تمایل با نام مشخص کرد، که در این صورت ترتیب مقادیر نام‌گذاری‌شده اهمیتی ندارد:</p>


<pre dir=ltr>
<font color=white>
fibonacci(10, b=3, a=1)
</pre>
<p dir=ltr>[3, 4, 7, 11, 18, 29, 47, 76, 123, 199]</p>


<h2>*args و **kwargs: آرگومان‌های انعطاف‌پذیر</h2>


<p>گاهی ممکن است بخواهید تابعی بنویسید که در ابتدا نمی‌دانید کاربر چند آرگومان به آن ارسال خواهد کرد. در این حالت می‌توانید از فرم ویژه *args و **kwargs استفاده کنید تا تمام آرگومان‌های ارسالی را دریافت کنید. در اینجا یک مثال آورده شده است:</p>


<pre dir=ltr>
<font color=white>
def catch_all(*args, **kwargs):
    print("args =", args)
    print("kwargs = ", kwargs)
</pre>


<pre dir=ltr>
<font color=white>
catch_all(1, 2, 3, a=4, b=5)
</pre>
<p dir=ltr>args = (1, 2, 3)</br>
kwargs =  {'a': 4, 'b': 5}</p>


<pre dir=ltr>
<font color=white>
catch_all('a', keyword=2)
</pre>
<p dir=ltr>args = ('a',)<br>
kwargs =  {'keyword': 2}</p>


<p>در اینجا مهم، نام‌های args و kwargs نیستند، بلکه کاراکترهای * هستند که قبل از آن‌ها آمده‌اند. args و kwargs صرفاً نام‌های متغیری هستند که معمولاً طبق قرارداد استفاده می‌شوند و مخفف «arguments» و «keyword arguments» هستند. تفاوت عملی در همین کاراکترهای ستاره‌ای است: یک ستاره * قبل از یک متغیر به معنی «این را به‌عنوان یک دنباله باز کن» است، در حالی که دو ستاره ** قبل از یک متغیر به معنی «این را به‌عنوان یک دیکشنری باز کن» است. در واقع، این نحو نه تنها در تعریف تابع، بلکه در فراخوانی تابع نیز قابل استفاده است!</p>


<pre dir=ltr>
<font color=white>
inputs = (1, 2, 3)
keywords = {'pi': 3.14}

catch_all(*inputs, **keywords)
</pre>
<p dir=ltr>args = (1, 2, 3)<br>
kwargs =  {'pi': 3.14}</p>


<h2>توابع ناشناس (lambda)</h2>


<p>قبلاً به‌طور سریع رایج‌ترین روش تعریف توابع، یعنی دستور def را بررسی کردیم. احتمالاً با روش دیگری برای تعریف توابع کوتاه و یک‌باره با دستور lambda مواجه خواهید شد. این نحو چیزی شبیه به این است:</p>


<pre dir=ltr>
<font color=white>
add = lambda x, y: x + y
add(1, 2)
</pre>
<p dir=ltr>3</p>


<p>این تابع lambda تقریباً معادل است با:</p>


<pre dir=ltr>
<font color=white>
def add(x, y):
    return x + y
</pre>


<p>پس چرا ممکن است بخواهید از چنین چیزی استفاده کنید؟ اساساً این به این نکته برمی‌گردد که در پایتون، همه چیز یک شیء است، حتی خود توابع! این بدان معناست که توابع می‌توانند به‌عنوان آرگومان به توابع دیگر منتقل شوند.</p>


<p>به‌عنوان مثال برای این مورد، فرض کنید داده‌هایی در یک لیست از دیکشنری‌ها ذخیره شده‌اند:</p>


<pre dir=ltr>
<font color=white>
data = [{'first':'Guido', 'last':'Van Rossum', 'YOB':1956},
        {'first':'Grace', 'last':'Hopper',     'YOB':1906},
        {'first':'Alan',  'last':'Turing',     'YOB':1912}]
</pre>


<p>حال فرض کنید می‌خواهیم این داده‌ها را مرتب کنیم. پایتون یک تابع sorted دارد که این کار را انجام می‌دهد:</p>


<pre dir=ltr>
<font color=white>
sorted([2,4,3,5,1,6])
</pre>
<p dir=ltr>[1, 2, 3, 4, 5, 6]</p>


<p>اما دیکشنری‌ها قابل مرتب‌سازی مستقیم نیستند؛ بنابراین نیاز داریم به تابع بگوییم داده‌ها را چگونه مرتب کند. این کار را می‌توان با مشخص کردن تابع کلید (key function) انجام داد، تابعی که با دریافت یک آیتم، کلید مرتب‌سازی آن آیتم را بازمی‌گرداند:</p>


<pre dir=ltr>
<font color=white>
# sort alphabetically by first name
sorted(data, key=lambda item: item['first'])
</pre>
<p dir=ltr>[{'YOB': 1912, 'first': 'Alan', 'last': 'Turing'},<br>
 {'YOB': 1906, 'first': 'Grace', 'last': 'Hopper'},<br>
 {'YOB': 1956, 'first': 'Guido', 'last': 'Van Rossum'}]</p>



<pre dir=ltr>
<font color=white>
# sort by year of birth
sorted(data, key=lambda item: item['YOB'])
</pre>
<p dir=ltr>[{'YOB': 1906, 'first': 'Grace', 'last': 'Hopper'},<br>
 {'YOB': 1912, 'first': 'Alan', 'last': 'Turing'},<br>
 {'YOB': 1956, 'first': 'Guido', 'last': 'Van Rossum'}]</p>


<p>در حالی که این توابع کلید را می‌توان با نحو معمول def نیز ایجاد کرد، نحو lambda برای چنین توابع کوتاه و یک‌باره‌ای بسیار مناسب و راحت است.</p>


|
<a href="08-دستورات کنترل جریان.md">دستورات کنترل جریان</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="10-خطاها و استثناها.md">خطاها و استثناها</a>
|


</div>