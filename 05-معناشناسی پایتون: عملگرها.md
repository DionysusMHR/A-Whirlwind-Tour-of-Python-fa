<div dir=rtl>


|
<a href="04-معناشناسی پایتون: متغیرها.md">معناشناسی پایتون: متغیرها</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="06-انواع داده اسکالر داخلی.md">انواع داده اسکالر داخلی</a>
|



<h1>معنای پایهٔ پایتون: عملگرها</h1>


<p>در بخش پیشین، شروع کردیم به بررسی معناشناسی متغیرها و اشیاء در پایتون؛ در اینجا عمیق‌تر به معناشناسی عملگرهای مختلف موجود در زبان می‌پردازیم. در پایان این بخش، ابزارهای پایه‌ای لازم برای مقایسه و انجام عملیات روی داده‌ها در پایتون را در اختیار خواهید داشت.</p>


<h2>عملیات حسابی</h2>



<p>پایتون هفت عملگر حسابی دودوییِ پایه را پیاده‌سازی می‌کند که دو مورد از آن‌ها می‌توانند به‌صورت عملگرهای یک‌تایی نیز استفاده شوند. این عملگرها در جدول زیر خلاصه شده‌اند:</p>


<table>
    <tr>
        <th>عملگر</th>
        <th>نام</th>
        <th>توضیح</th>
    </tr>
    <tr>
        <td>a + b</td>
        <td>جمع (Addition)</td>
        <td>حاصل جمع a و b</td>
    </tr>
    <tr>
        <td>a - b</td>
        <td>تفریق (Subtraction)</td>
        <td>تفاضل a و b</td>
    </tr>
    <tr>
        <td>a * b</td>
        <td>ضرب (Multiplication)</td>
        <td>حاصل‌ضرب a و b</td>
    </tr>
    <tr>
        <td>a / b</td>
        <td>تقسیم حقیقی (True division)</td>
        <td>خارج‌قسمت a بر b</td>
    </tr>
    <tr>
        <td>a // b</td>
        <td>تقسیم کف (Floor division)</td>
        <td>خارج‌قسمت a بر b با حذف بخش اعشاری</td>
    </tr>
    <tr>
        <td>a % b</td>
        <td>باقیمانده (Modulus)</td>
        <td>باقیمانده‌ی تقسیم a بر b</td>
    </tr>
    <tr>
        <td>a ** b</td>
        <td>توان (Exponentiation)</td>
        <td>a به توان b</td>
    </tr>
    <tr>
        <td dir=ltr align=middle>-a</td>
        <td>منفی‌سازی (Negation)</td>
        <td>مقدار منفی a</td>
    </tr>
    <tr>
        <td dir=ltr align=middle>+a</td>
        <td>علامت مثبت (Unary plus)</td>
        <td>a بدون تغییر (به‌ندرت استفاده می‌شود)</td>
    </tr>
</table>



<p>این عملگرها را می‌توان به‌صورت ترکیبی و به‌شکلی کاملاً شهودی استفاده کرد و برای گروه‌بندی عملیات می‌توان از پرانتزهای استاندارد استفاده نمود. برای مثال:</p>


<pre dir=ltr>
<font color=white>
# addition, subtraction, multiplication
(4 + 8) * (6.5 - 3)
</pre>
<p dir=ltr>42.0</p>


<p>«تقسیم کف» (Floor division) همان «تقسیم حقیقی» است با این تفاوت که بخش کسری نتیجه حذف (یا بریده) می‌شود:</p>



<pre dir=ltr>
<font color=white>
# True division
print(11 / 2)
</pre>
<p dir=ltr>5.5</p>



<pre dir=ltr>
<font color=white>
# Floor division
print(11 // 2)
</pre>
<p dir=ltr>5</p>



<p>عملگر «تقسیم کف» در پایتون ۳ اضافه شد؛ اگر با پایتون ۲ کار می‌کنید، باید بدانید که عملگر تقسیم استاندارد (/) برای اعداد صحیح مانند تقسیم کف عمل می‌کند و برای اعداد اعشاری مانند تقسیم حقیقی رفتار می‌کند.</p>


<p>در نهایت، باید به هشتمین عملگر حسابی اشاره کنم که در پایتون ۳.۵ اضافه شد: عملگر a @ b که برای نشان‌دادن ضرب ماتریسیِ a و b استفاده می‌شود و در کتابخانه‌های مختلف جبر خطی کاربرد دارد.</p>


<h2>عملیات بیت‌به‌بیت (Bitwise Operations)</h2>


<p>علاوه بر عملیات عددی استاندارد، پایتون شامل عملگرهایی برای انجام عملیات منطقی بیت‌به‌بیت روی اعداد صحیح نیز هست. این عملگرها بسیار کمتر از عملگرهای حسابی معمولی استفاده می‌شوند، اما دانستن آن‌ها مفید است. شش عملگر بیت‌به‌بیت در جدول زیر خلاصه شده‌اند:</p>


<table>
    <tr>
        <th>عملگر</th>
        <th>نام</th>
        <th>توضیح</th>
    </tr>
    <tr>
        <td>a & b</td>
        <td>AND بیت‌به‌بیت</td>
        <td>بیت‌هایی که هم در a و هم در b یک هستند</td>
    </tr>
    <tr>
        <td>a | b</td>
        <td>OR بیت‌به‌بیت</td>
        <td>بیت‌هایی که در a یا b یا در هردوی آن‌ها یک هستند.</td>
    </tr>
    <tr>
        <td>a ^ b</td>
        <td>XOR بیت‌به‌بیت</td>
        <td>بیت‌هایی که در a یا b یک هستند، اما نه هر دو</td>
    </tr>
    <tr>
        <td>a << b</td>
        <td>شیفت به چپ</td>
        <td>انتقال بیت‌های a به سمت چپ به اندازه b واحد</td>
    </tr>
    <tr>
        <td>a >> b</td>
        <td>شیفت به راست</td>
        <td>انتقال بیت‌های a به سمت راست به اندازه b واحد</td>
    </tr>
    <tr>
        <td>~a</td>
        <td>NOT بیت‌به‌بیت</td>
        <td>وارون‌سازی بیت‌های a (تبدیل 0 به 1 و بالعکس)</td>
    </tr>
</table>


<p>این عملگرهای بیتی تنها در چارچوب نمایش باینری (دودویی) اعداد معنا پیدا می‌کنند؛ نمایشی که می‌توانید با استفاده از تابع داخلی bin مشاهده کنید:</p>


<pre dir=ltr>
<font color=white>
bin(10)
</pre>
<p dir=ltr>'0b1010'</p>


<p>خروجی با پیشوند 0b نمایش داده می‌شود، که نشان‌دهنده‌ی یک نمایش باینری است. بخش باقی‌ماندهٔ ارقام بیان می‌کند که عدد ۱۰ به صورت مجموع زیر نمایش داده شده است:<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mn>1</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>2</mn>
    <mn>3</mn>
  </msup>
  <mo>+</mo>
  <mn>0</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>2</mn>
    <mn>2</mn>
  </msup>
  <mo>+</mo>
  <mn>1</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>2</mn>
    <mn>1</mn>
  </msup>
  <mo>+</mo>
  <mn>0</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>2</mn>
    <mn>0</mn>
  </msup>
</math></p>


<p>به‌طور مشابه می‌توان نوشت:</p>


<pre dir=ltr>
<font color=white>
bin(4)
</pre>
<p dir=ltr>'0b100'</p>


<p>اکنون با استفاده از عملیات OR بیت‌به‌بیت می‌توانیم عددی را بیابیم که بیت‌های ۴ و ۱۰ را با هم ترکیب می‌کند:</p>


<pre dir=ltr>
<font color=white>
4 | 10
</pre>
<p dir=ltr>14</p>


<pre dir=ltr>
<font color=white>
bin(4 | 10)
</pre>
<p dir=ltr>'0b1110'</p>


<p>این عملگرهای بیت‌به‌بیت به اندازهٔ عملگرهای حسابی استاندارد کاربرد فوری ندارند، اما دیدن آن‌ها حداقل یک‌بار مفید است تا درک کنید در چه دسته‌ای از عملیات قرار می‌گیرند. به‌ویژه، برنامه‌نویسانی که از زبان‌های دیگر می‌آیند گاهی وسوسه می‌شوند از XOR (یعنی a ^ b) استفاده کنند، در حالی که در واقع منظورشان توان است (یعنی a ** b).</p>


<h2>عملیات تخصیص (Assignment Operations)</h2>


<p>دیدیم که متغیرها می‌توانند با استفاده از عملگر = مقداردهی شوند و مقادیر برای استفاده‌های بعدی ذخیره شوند. برای مثال:</p>


<pre dir=ltr>
<font color=white>
a = 24
print(a)
</pre>
<p dir=ltr>24</p>


<p>می‌توانیم از این متغیرها در عبارات به همراه هر یک از عملگرهای گفته‌شده استفاده کنیم. برای مثال، برای اضافه کردن ۲ به a می‌نویسیم:</p>


<pre dir=ltr>
<font color=white>
a + 2
</pre>
<p dir=ltr>26</p>


<p>ممکن است بخواهیم مقدار جدید را در متغیر a به‌روزرسانی کنیم؛ در این صورت می‌توانیم جمع و تخصیص را با هم ترکیب کرده و بنویسیم a = a + 2. از آنجایی که این نوع عملیات ترکیبی و تخصیص بسیار رایج است، پایتون عملگرهای به‌روزرسانی داخلی برای همهٔ عملیات حسابی ارائه می‌دهد:</p>


<pre dir=ltr>
<font color=white>
a += 2  # equivalent to a = a + 2
print(a)
</pre>
<p dir=ltr>26</p>


<p>برای هر یک از عملگرهای دودویی که پیش‌تر ذکر شد، یک عملگر تخصیص ترکیبی (Augmented Assignment) وجود دارد؛ به طور خلاصه، آن‌ها به شکل زیر هستند:</p>


<table>
    <tr>
        <th>عملگر</th>
        <th>معادل</th>
    </tr>
    <tr>
        <td>a += b</td>
        <td>a = a + b</td>
    </tr>
    <tr>
        <td>a -= b</td>
        <td>a = a - b</td>
    </tr>
    <tr>
        <td>a *= b</td>
        <td>a = a * b</td>
    </tr>
    <tr>
        <td>a /= b</td>
        <td>a = a / b</td>
    </tr>
    <tr>
        <td>a //= b</td>
        <td>a = a // b</td>
    </tr>
    <tr>
        <td>a %= b</td>
        <td>a = a % b</td>
    </tr>
    <tr>
        <td>a **= b</td>
        <td>a = a ** b</td>
    </tr>
    <tr>
        <td>a &= b</td>
        <td>a = a & b</td>
    </tr>
    <tr>
        <td>a |= b</td>
        <td>a = a | b</td>
    </tr>
    <tr>
        <td>a ^= b</td>
        <td>a = a ^ b</td>
    </tr>
    <tr>
        <td>a <<= b</td>
        <td>a = a << b</td>
    </tr>
    <tr>
        <td>a >>= b</td>
        <td>a = a >> b</td>
    </tr>
</table>


<p>هر یک از این عملگرها معادل انجام عملیات مربوطه و سپس تخصیص است؛ یعنی برای هر عملگر «■»، عبارت a ■= b معادل a = a ■ b است، با یک نکتهٔ مهم. برای اشیاء قابل تغییر مانند لیست‌ها، آرایه‌ها یا DataFrameها، این عملگرهای تخصیص ترکیبی در واقع کمی متفاوت از نسخهٔ طولانی‌تر خود عمل می‌کنند: آن‌ها محتوای شیء اصلی را تغییر می‌دهند به جای اینکه یک شیء جدید برای ذخیره نتیجه ایجاد کنند.</p>


<h2>عملیات مقایسه (Comparison Operations)</h2>


<p>نوع دیگری از عملیات که می‌تواند بسیار مفید باشد، مقایسه‌ی مقادیر مختلف است. برای این کار، پایتون مجموعه‌ای از عملگرهای مقایسه را پیاده‌سازی می‌کند که مقدار بولی True یا False برمی‌گردانند. عملیات مقایسه در جدول زیر فهرست شده‌اند:</p>


<table>
    <tr>
        <th>عملیات</th>
        <th>توضیحات</th>
        <th>عملیات</th>
        <th>توضیحات</th>
    </tr>
    <tr>
        <td>a == b</td>
        <td>a برابر با b است</td>
        <td>a != b</td>
        <td>a با b برابر نیست</td>
    </tr>
    <tr>
        <td>a < b</td>
        <td>a کوچکتر از b</td>
        <td>a > b</td>
        <td>a بزرگتر از b</td>
    </tr>
    <tr>
        <td>a <= b</td>
        <td>a کوچکتر یا مساوی b</td>
        <td>a >= b</td>
        <td>a بزرگتر یا مساوی b</td>
    </tr>

</table>



<p>این عملگرهای مقایسه‌ای را می‌توان با عملگرهای حسابی و بیت‌به‌بیت ترکیب کرد تا مجموعه‌ای تقریباً نامحدود از آزمون‌ها روی اعداد را بیان کرد. برای مثال، می‌توانیم بررسی کنیم که آیا یک عدد فرد است یا نه، با این کار که بررسی کنیم حاصل باقیمانده تقسیم آن بر ۲ برابر با ۱ باشد:</p>


<pre dir=ltr>
<font color=white>
# 25 is odd
25 % 2 == 1
</pre>
<p dir=ltr>True</p>


<pre dir=ltr>
<font color=white>
# 66 is odd
66 % 2 == 1
</pre>
<p dir=ltr>False</p>


<p>می‌توانیم چندین مقایسه را به هم زنجیر کنیم تا روابط پیچیده‌تری را بررسی کنیم:</p>


<pre dir=ltr>
<font color=white>
# check if a is between 15 and 30
a = 25
15 < a < 30
</pre>
<p dir=ltr>True</p>


<p>و حالا، فقط برای اینکه کمی ذهنتان را به چالش بکشیم، نگاهی به این مقایسه بیندازید:</p>


<pre dir=ltr>
<font color=white>
-1 == ~0
</pre>
<p dir=ltr>True</p>


<p>به یاد داشته باشید که عملگر ~ عملگر وارون‌سازی بیت‌ها (bit-flip) است، و همان‌طور که می‌بینید وقتی تمام بیت‌های عدد صفر را وارونه می‌کنید، نتیجه عدد <b dir=ltr>-1</b> می‌شود.</p>
<p>اگر کنجکاوید که چرا این اتفاق می‌افتد، موضوع را در «کدگذاری اعداد صحیح با مکمل دو» (Two’s Complement) جست‌وجو کنید؛ این همان روشی است که پایتون برای نمایش اعداد صحیح علامت‌دار استفاده می‌کند.</p>
<p>کافی است فکر کنید وقتی در این شیوه‌ی نمایش، تمام بیت‌های یک عدد را برعکس می‌کنید چه اتفاقی می‌افتد—آن وقت دلیل تبدیل شدن 0 به <b dir=ltr>-1</b> کاملاً روشن می‌شود.</p>


<h2>عملیات بولی</h2>


<p>هنگام کار با مقادیر بولی، پایتون عملگرهایی برای ترکیب این مقادیر با استفاده از مفاهیم استاندارد و (and)، یا (or) و نفی (not) فراهم می‌کند. همان‌طور که انتظار می‌رود، این عملگرها با کلمات and، or و not نمایش داده می‌شوند:</p>


<pre dir=ltr>
<font color=white>
x = 4
(x < 6) and (x > 2)
</pre>
<p dir=ltr>True</p>


<pre dir=ltr>
<font color=white>
(x > 10) or (x % 2 == 0)
</pre>
<p dir=ltr>True</p>


<pre dir=ltr>
<font color=white>
not (x < 6)
</pre>
<p dir=ltr>False</p>


<p>علاقه‌مندان به جبر بولی ممکن است متوجه شوند که عملگر XOR به‌صورت مستقیم ارائه نشده است؛ البته این عملگر را می‌توان به روش‌های مختلف با ترکیب دیگر عملگرها ساخت. به‌طور دیگر، یک روش هوشمندانه برای محاسبه XOR بین مقادیر بولی به شکل زیر است:</p>


<pre dir=ltr>
<font color=white>
# (x > 1) xor (x < 10)
(x > 1) != (x < 10)
</pre>
<p dir=ltr>False</p>


<p>این نوع عملیات بولی زمانی که به بررسی دستورات جریان کنترل مانند شرط‌ها و حلقه‌ها بپردازیم، بسیار کاربردی خواهند بود.</p>


<p>یکی از موارد گاهی گیج‌کننده در زبان پایتون این است که چه زمانی باید از عملگرهای بولی (and, or, not) استفاده کنیم و چه زمانی از عملگرهای بیت‌به‌بیت (&, |, ~). پاسخ در نام آن‌ها نهفته است: عملگرهای بولی وقتی استفاده می‌شوند که بخواهید مقدار True یا False یک عبارت کامل را محاسبه کنید، و عملگرهای بیت‌به‌بیت وقتی کاربرد دارند که بخواهید روی بیت‌های مجزا یا اجزای داخلی اشیاء عمل کنید.</p>


<h2>عملگرهای هویّت و عضویت</h2>


<p>مانند عملگرهای and، or و not، پایتون همچنین عملگرهایی شبیه به زبان محاوره‌ای دارد که برای بررسی هویت و عضویت استفاده می‌شوند. این عملگرها به شرح زیر هستند:</p>


<table>
    <tr>
        <th>عملیات</th>
        <th>توضیح</th>
    </tr>
    <tr>
        <td>a is b</td>
        <td>مقدار True را برمی‌گرداند اگر a و b همان شیء یکسان باشند.</td>
    </tr>
    <tr>
        <td>a is not b</td>
        <td>مقدار True را برمی‌گرداند اگر a و b اشیاء یکسان نباشند.</td>
    </tr>
    <tr>
        <td>a in b</td>
        <td>مقدار True را برمی‌گرداند اگر a عضوی از b باشد.</td>
    </tr>
    <tr>
        <td>a not in b</td>
        <td>مقدار True را برمی‌گرداند اگر a عضوی از b نباشد.</td>
    </tr>
</table>


<h2>عملگرهای هویتی: «is» و «is not»</h2>


<p>عملگرهای هویتی «is» و «is not» برای بررسی هویت اشیاء استفاده می‌شوند. هویت شیء با برابری متفاوت است، همان‌طور که در اینجا می‌بینیم:</p>


<pre dir=ltr>
<font color=white>
a = [1, 2, 3]
b = [1, 2, 3]
</pre>


<pre dir=ltr>
<font color=white>
a == b
</pre>
<p dir=ltr>True</p>


<pre dir=ltr>
<font color=white>
a is b
</pre>
<p dir=ltr>False</p>


<pre dir=ltr>
<font color=white>
a is not b
</pre>
<p dir=ltr>True</p>

<p>اشیاء یکسان چگونه به نظر می‌رسند؟ در اینجا یک مثال آورده شده است:</p>



<pre dir=ltr>
<font color=white>
a = [1, 2, 3]
b = a
a is b
</pre>
<p dir=ltr>True</p>


<p>تفاوت بین این دو حالت در این است که در حالت اول، متغیرهای a و b به اشیاء متفاوت اشاره می‌کنند، در حالی که در حالت دوم هر دو به یک شیء اشاره دارند. همان‌طور که در بخش قبل دیدیم، متغیرهای پایتون به‌عنوان اشاره‌گر عمل می‌کنند. عملگر "is" بررسی می‌کند که آیا دو متغیر به یک شیء یکسان اشاره می‌کنند یا خیر، نه اینکه محتوای آن شیء چیست. با این توضیح، در اکثر مواقع وقتی یک مبتدی وسوسه می‌شود از "is" استفاده کند، آنچه واقعاً مدنظر دارد == است.</p>


<h2>عملگرهای عضویت</h2>


<p>عملگرهای عضویت بررسی می‌کنند که آیا یک مقدار درون یک شیء مرکب وجود دارد یا خیر. برای مثال، می‌توان نوشت:</p>


<pre dir=ltr>
<font color=white>
1 in [1, 2, 3]
</pre>
<p dir=ltr>True</p>


<pre dir=ltr>
<font color=white>
2 not in [1, 2, 3]
</pre>
<p dir=ltr>False</p>


<p>این عملیات عضویت نمونه‌ای از دلایلی است که پایتون را در مقایسه با زبان‌های سطح پایین‌تر مانند C بسیار آسان می‌کند. در زبان C، بررسی عضویت معمولاً با ساخت یک حلقه‌ی دستی روی لیست و بررسی برابری هر مقدار انجام می‌شود. در پایتون، شما تنها چیزی را که می‌خواهید بدانید تایپ می‌کنید، به روشی شبیه به نگارش ساده و مستقیم انگلیسی.</p>



|
<a href="04-معناشناسی پایتون: متغیرها.md">معناشناسی پایتون: متغیرها</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="06-انواع داده اسکالر داخلی.md">انواع داده اسکالر داخلی</a>
|



</div>