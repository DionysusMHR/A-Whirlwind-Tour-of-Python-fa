## عملیات حسابی

پایتون هفت عملگر اصلی حسابی دودویی را ارائه می‌دهد که دو مورد از آنها می‌توانند به عنوان عملگرهای یکانی نیز عمل کنند. این عملگرها در جدول زیر خلاصه شده‌اند:

| عملگر       | نام             | توضیح                                                     |
|------------|-----------------|---------------------------------------------------------|
| `a + b`    | جمع             | `a` و `b` حاصل جمع                                    |
| `a - b`    | تفریق          |  `a` و `b` تفاضل                                         |
| `a * b`    | ضرب            |   `a` و `b` حاصل ضرب                                      |
| `a / b`    | تقسیم     |  `b` بر `a`  تقسیم اعشاری                   |
| `a // b`   | تقسیم صحیح     |  `b` بر `a`     تقسیم صحیح                   |
| `a % b`    | باقیمانده       |    `b` بر `a` باقیمانده تقسیم صحیح                        |
| `a ** b`   | توان           | `b` به توان `a`                                         |
| `-a`       | نقیض       |  `a` قرینه                                                |
| `+a`       | مثبت یکانی     |   `a` (کمکاربرد) بدون تغییر                              |

این عملگرها را می‌توان  با پرانتزهای استاندارد ترکیب کرد. به عنوان مثال:

```python
# addition, subtraction, multiplication
(4 + 8) * (6.5 - 3)

>>> 42.0
```

تقسیم صحیح، همان تقسیم واقعی است که بخش‌های کسری آن حذف شده‌اند:

```python
# True division
print(11 / 2)


>>> 5.5
```

```python
# Floor division
print(11 // 2)


>>> 5
```

عملگر تقسیم صحیح (//) در پایتون ۳ اضافه شد. اگر با پایتون ۲ کار می‌کنید، باید به این نکته توجه داشته باشید که عملگر تقسیم استاندارد (/) در آن نسخه، برای اعداد صحیح مانند تقسیم صحیح و برای اعداد اعشاری مانند تقسیم واقعی عمل می‌کند.

در پایان، به عملگر هشتم حسابی که در پایتون ۳.۵ اضافه شد اشاره می‌کنم: عملگر a @ b. این عملگر برای نشان دادن حاصلضرب ماتریسی a و b در نظر گرفته شده است و در پکیج‌های مختلف جبر خطی مورد استفاده قرار می‌گیرد.

## عملیات بیتی

علاوه بر عملیات متداول عددی، پایتون عملگرهایی برای انجام عملیات منطقی بیتی روی اعداد صحیح ارائه می‌دهد. این عملگرها نسبت به عملگرهای حسابی استاندارد کمتر مورد استفاده قرار می‌گیرند، اما خوب است بدانید که وجود دارند.

شش عملگر بیتی در جدول زیر خلاصه شده‌اند:

| عملگر                       | نام             | توضیح                                      |
|-----------------------------|-----------------|------------------------------------------|
| `a & b`                     | AND بیتی        | بیت‌های مشترک در `a` و `b`               |
| <code>a &#124; b</code>     | OR بیتی         | بیت‌های موجود در `a` یا `b` یا هر دو     |
| `a ^ b`                     | XOR بیتی        | بیت‌های موجود در `a` یا `b` اما نه هر دو  |
| `a << b`                    | شیفت بیتی چپ    | جابه‌جایی بیت‌های `a` به اندازه `b` واحد به چپ |
| `a >> b`                    | شیفت بیتی راست  | جابه‌جایی بیت‌های `a` به اندازه `b` واحد به راست |
| `~a`                        | NOT بیتی        | نقیض بیتی `a`                            |

این عملگرهای بیتی فقط در مورد نمایش دودویی اعداد معنی پیدا می‌کنند که می‌توانید با استفاده از تابع داخلی `bin` آن را مشاهده کنید:


```python
bin(10)

>>> '0b1010'
```

نتیجه با 0b پیشوندگذاری شده که نشان‌دهنده نمایش دودویی است. باقی رقم‌ها نشان می‌دهند که عدد ۱۰ به صورت حاصل جمع $1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0$ بیان شده است.

به طور مشابه، می‌توانیم بنویسیم:


```python
bin(4)


>>>'0b100'
```

حالا با استفاده از عملگر OR بیتی، می‌توانیم عددی که بیت‌های 4 و 10 را ترکیب می‌کند پیدا کنیم:

```python
4 | 10

>>> 14
```

```python
bin(4 | 10)

>>>'0b1110'
```

این عملگرهای بیتی به اندازه عملگرهای حسابی استاندارد کاربردی نیستند، اما خوب است حداقل یک بار با آنها آشنا شوید تا بدانید چه نوع عملیاتی انجام می‌دهند.

به ویژه، کاربرانی که از زبان‌های دیگر می‌آیند، گاهی اوقات به اشتباه به جای عملگر توان (a ** b) از عملگر XOR (a ^ b) استفاده می‌کنند.

## عملیات انتساب
دیدیم که می‌توان به متغیرها با عملگر = مقدار اختصاص داد و مقادیر را برای استفاده بعدی ذخیره کرد. برای مثال:

```python
a = 24
print(a)

>>> 24
```

می‌توانیم از این متغیرها در عبارات همراه با هر یک از عملگرهای ذکر شده قبلی استفاده کنیم.

برای مثال، برای افزودن ۲ به a می‌نویسیم:

```python
a + 2

>>> 26
```

ممکن است بخواهیم متغیر «a» را با این مقدار جدید به‌روزرسانی کنیم. در این حالت می‌توانیم عمل جمع و انتساب را ترکیب کنیم   . از آنجا که این نوع عملیات ترکیبی و انتساب بسیار رایج است، پایتون عملگرهای به‌روزرسانی داخلی برای تمامی عملیات حسابی ارائه می‌دهد.

```python
a += 2  # equivalent to a = a + 2
print(a)


>>> 26
```

برای هر یک از عملگرهای دودویی که پیش‌تر ذکر شد، یک عملگر انتساب افزایشی متناظر وجود دارد. به طور خلاصه، آن‌ها به این صورت هستند:

|||||
|-|-|-|-|
|``a += b``| ``a -= b``|``a *= b``| ``a /= b``|
|``a //= b``| ``a %= b``|``a **= b``|``a &= b``|
|<code>a &#124;= b</code>| ``a ^= b``|``a <<= b``| ``a >>= b``|

هر یک از این عملگرها معادل عمل مربوطه به همراه انتساب هستند. به عبارت دیگر، برای هر عملگر "``■``"، عبارت ``a ■= b`` معادل ``a = a ■ b`` است، با یک تفاوت کوچک.

برای اشیاء تغییرپذیر مانند لیست‌ها، آرایه‌ها یا DataFrames، این عملیات انتساب افزوده در واقع تفاوت ظریفی با همتایان طولانی‌تر خود دارند: آنها به جای ایجاد یک شیء جدید برای ذخیره نتیجه، محتویات شیء اصلی را تغییر می‌دهند.

## عملیات مقایسه‌ای

نوع دیگری از عملیات که می‌تواند بسیار مفید باشد، مقایسه مقادیر مختلف است. پایتون برای این منظور عملگرهای استاندارد مقایسه‌ای را پیاده‌سازی کرده که مقادیر بولین ``True`` و ``False`` برمی‌گردانند.

عملیات مقایسه‌ای در جدول زیر فهرست شده‌اند:

| عملگر         | توضیح                           |  
|---------------|---------------------------------|  
| ``a == b``    | ``b`` برابر با ``a``           |  
| ``a != b``    | ``b`` نامساوی با ``a``         |  
| ``a < b``     | ``b`` کوچک‌تر از ``a``         |  
| ``a > b``     | ``b`` بزرگ‌تر از ``a``         |  
| ``a <= b``    | ``b`` کوچک‌تر یا مساوی با ``a``|  
| ``a >= b``    | ``b`` بزرگ‌تر یا مساوی با ``a``|  

این عملگرهای مقایسه‌ای را می‌توان با عملگرهای حسابی و بیتی ترکیب کرد تا محدوده تقریباً نامحدودی از آزمون‌ها برای اعداد بیان شود.

برای مثال، می‌توانیم بررسی کنیم که یک عدد فرد است یا خیر با بررسی اینکه باقی‌مانده آن بر 2 برابر با 1 است:

```python
# 25 is odd
25 % 2 == 1

>>> True
```

```python
# 66 is odd
66 % 2 == 1

>>> False
```
می‌توانیم چندین مقایسه را به هم پیوند بزنیم تا روابط پیچیده‌تر را بررسی کنیم:
```python
# check if a is between 15 and 30
a = 25
15 < a < 30

>>> True
```

و فقط برای اینکه کمی سرتان را به درد بیاورم، نگاهی به این مقایسه بیندازید:

```python
-1 == ~0

>>>True
```

به خاطر داشته باشید که `~` عملگر معکوس‌سازی بیتی است و وقتی تمام بیت‌های صفر را معکوس کنید، به عدد 1- می‌رسید. اگر کنجکاو هستید که چرا این اتفاق می‌افتد، به طرح کدگذاری اعداد صحیح *مکمل دو* مراجعه کنید که پایتون از آن برای کدگذاری اعداد علامت‌دار استفاده می‌کند و به این فکر کنید که وقتی تمام بیت‌های اعداد کدگذاری شده به این روش را معکوس می‌کنید چه اتفاقی می‌افتد.

## عملیات بولی

هنگام کار با مقادیر بولی، پایتون عملگرهایی برای ترکیب این مقادیر با استفاده از مفاهیم استاندارد "and" (و)، "or" (یا) و "not" (نقیض) ارائه می‌دهد. همان طور که انتظار می‌رود، این عملگرها با استفاده از کلمات and، or و not بیان می‌شوند.

```python
x = 4
(x < 6) and (x > 2)

>>> True
```

```python
(x > 10) or (x % 2 == 0)

>>> True
```

```python
not (x < 6)

>>> False
```

علاقه‌مندان به جبر بولی ممکن است متوجه شوند که عملگر XOR در اینجا گنجانده نشده است. البته می‌توان این عملگر را به چند روش از طریق ترکیبی از عملگرهای دیگر ساخت.

یک ترفند هوشمندانه که می‌توان برای XOR مقادیر بولی استفاده کرد به صورت زیر است:

```python
# (x > 1) xor (x < 10)
(x > 1) != (x < 10)

>>> False
```
این نوع عملیات بولی زمانی بسیار مفید خواهند شد که بحث *دستورات کنترل جریان* مانند شرط‌ها و حلقه‌ها را آغاز کنیم.

یک نکته گاهی گیج‌کننده در زبان پایتون این است که چه زمانی از عملگرهای بولی (``and``، ``or``، ``not``) و چه زمانی از عملیات بیتی (``&``، ``|``، ``~``) استفاده کنیم. پاسخ در نام آن‌ها نهفته است:

- از **عملگرهای بولی** باید زمانی استفاده کنید که می‌خواهید *مقادیر بولی (یعنی درستی یا نادرستی) کل عبارات* را محاسبه کنید.
- از **عملیات بیتی** باید زمانی استفاده کنید که می‌خواهید *روی بیت‌ها یا اجزای فردی اشیاء مورد نظر عملیات انجام دهید*.

## عملگرهای هویت و عضویت

مانند `and`، `or` و `not`، پایتون همچنین شامل عملگرهای توصیفی برای بررسی هویت و عضویت است. این عملگرها به شرح زیر هستند:

| عملگر           | توضیح                                     |
|-----------------|-----------------------------------------|
| `a is b`        | درست اگر `a` و `b` شیء یکسانی باشند      |
| `a is not b`    | درست اگر `a` و `b` شیء یکسانی نباشند    |
| `a in b`        | درست اگر `a` عضو `b` باشد               |
| `a not in b`    | درست اگر `a` عضو `b` نباشد              |

### عملگرهای هویت: "is" و "is not"

عملگرهای هویت "is" و "is not"، **هویت شیء** را بررسی می‌کنند. هویت شیء با برابری متفاوت است، همان‌طور که در اینجا مشاهده می‌کنیم:

```python
a = [1, 2, 3]
b = [1, 2, 3]
```

```python
a == b

>>> True
```

```python
a is b

>>> False
```

```python
a is not b

>>> True
```

اشیای یکسان چگونه هستند؟ در اینجا یک مثال آورده شده است:

```python
a = [1, 2, 3]
b = a
a is b

>>> True
```

تفاوت بین این دو مورد در این است که در مورد اول، `a` و `b` به **اشیاء مختلف** اشاره می‌کنند، در حالی که در مورد دوم به **یک شیء یکسان** اشاره دارند.

همان‌طور که در بخش قبل دیدیم، متغیرهای پایتون اشاره‌گر هستند. عملگر `is` بررسی می‌کند که آیا دو متغیر به یک ظرف (شیء) یکسان اشاره می‌کنند یا خیر، نه به محتوای درون ظرف.

با در نظر گرفتن این موضوع، در بیشتر مواردی که یک تازه‌کار تمایل به استفاده از `is` دارد، در واقع منظورشان `==` است.

### عملگرهای عضویت

عملگرهای عضویت، وجود یک عضو را درون اشیاء مرکب بررسی می‌کنند. برای مثال، می‌توانیم بنویسیم:


```python
1 in [1, 2, 3]

>>> True
```

```python
2 not in [1, 2, 3]

>>> False
```

این عملیات ها نمونه‌ای هستند که نشان می‌دهند چرا پایتون در مقایسه با زبان‌های سطح پایین‌تری مثل C، چنین آسان برای استفاده است.

در زبان C، عضویت معمولاً با ساخت یک حلقه دستی روی لیست و بررسی برابری هر مقدار تعیین می‌شود.

در پایتون، شما فقط چیزی را که می‌خواهید بدانید، به شکلی شبیه به نثر ساده انگلیسی تایپ می‌کنید.
