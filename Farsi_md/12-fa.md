مولدها (Generators)

در این بخش به بررسی عمیق‌تر مولدهای پایتون می‌پردازیم که شامل *عبارات مولد* و *توابع مولد* می‌شود.


عبارات مولد (Generator Expressions)

تفاوت بین فهرست‌سازی (List Comprehensions) و عبارات مولد (Generator Expressions) گاهی اوقات گیج‌کننده است؛ در اینجا به سرعت تفاوت‌های بین آن‌ها را مرور می‌کنیم:

### فهرست‌سازی از کروشه استفاده می‌کند، در حالی که عبارات مولد از پرانتز استفاده می‌کنند

این یک نمونه از فهرست‌سازی است:

```python
[n ** 2 for n in range(12)]

>>> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]
```

در حالی که این یک نمونه از عبارت مولد است:

```python
(n ** 2 for n in range(12))

>>> <generator object <genexpr> at 0x104a60518>
```

توجه کنید که چاپ عبارت مولد، محتوای آن را نمایش نمی‌دهد؛ یکی از راه‌های نمایش محتوای یک عبارت مولد، انتقال آن به سازنده ``list`` است
:

```python
G = (n ** 2 for n in range(12))
list(G)

>>> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]
```

### لیست مجموعه‌ای از مقادیر است، در حالی که مولد دستورالعملی برای تولید مقادیر محسوب می‌شود

وقتی یک لیست ایجاد می‌کنید، در واقع در حال ساختن یک مجموعه از مقادیر هستید و این امر با هزینه حافظه‌ای همراه است.  
اما وقتی یک مولد می‌سازید، مجموعه‌ای از مقادیر نمی‌سازید، بلکه یک دستورالعمل برای تولید آن مقادیر ایجاد می‌کنید.  

هر دو، واسط یکسان تکرارکننده را ارائه می‌دهند، همان‌طور که در اینجا مشاهده می‌کنید:

```python
L = [n ** 2 for n in range(12)]
for val in L:
    print(val, end=' ')
>>> 0 1 4 9 16 25 36 49 64 81 100 121 
```

```python
G = (n ** 2 for n in range(12))
for val in G:
    print(val, end=' ')


>>> 0 1 4 9 16 25 36 49 64 81 100 121 
```

```python
L = [n ** 2 for n in range(12)]
for val in L:
    print(val, end=' ')


>>> 0 1 4 9 16 25 36 49 64 81 100 121 
```

تفاوت در این است که یک عبارت مولد در واقع مقادیر را تا زمانی که مورد نیاز نباشند، محاسبه نمی‌کند.  
این نه تنها به کارایی حافظه منجر می‌شود، بلکه به کارایی محاسباتی نیز کمک می‌کند!  
این همچنین بدان معناست که در حالی که اندازه یک لیست توسط حافظه موجود محدود می‌شود، اندازه یک عبارت مولد نامحدود است!  

یک نمونه از عبارت مولد بی‌پایان را می‌توان با استفاده از تکرارکننده ``count`` تعریف‌شده در ``itertools`` ایجاد کرد:

```python
from itertools import count
count()


>>> count(0)
```

```python
for i in count():
    print(i, end=' ')
    if i >= 10: break


>>> 0 1 2 3 4 5 6 7 8 9 10 
```

تکرارکننده ``count`` با خوشحالی تا بی‌نهایت به شمارش ادامه خواهد داد تا زمانی که به آن بگویید متوقف شود؛ این ویژگی ایجاد مولدهایی که تا ابد ادامه می‌یابند را آسان می‌کند:


```python
factors = [2, 3, 5, 7]
G = (i for i in count() if all(i % n > 0 for n in factors))
for val in G:
    print(val, end=' ')
    if val > 40: break


>>> 1 11 13 17 19 23 29 31 37 41 
```

شاید متوجه شده باشید که به چه سمتی داریم می‌رویم: اگر فهرست عوامل را به درستی گسترش دهیم، در واقع شروع به ساخت یک مولد اعداد اول کرده‌ایم که از الگوریتم غربال اراتوستن استفاده می‌کند. به زودی این موضوع را بیشتر بررسی خواهیم کرد.

### یک لیست را می‌توان چندین بار تکرار کرد؛ یک عبارت مولد فقط یک بار قابل استفاده است

این یکی از آن موارد احتمالی است که در کار با عبارات مولد ممکن است باعث اشتباه شود.  
با یک لیست، می‌توانیم به سادگی این کار را انجام دهیم:

```python
L = [n ** 2 for n in range(12)]
for val in L:
    print(val, end=' ')
print()

for val in L:
    print(val, end=' ')


>>> 0 1 4 9 16 25 36 49 64 81 100 121 
0 1 4 9 16 25 36 49 64 81 100 121  
```

از طرف دیگر، یک عبارت مولد پس از یک بار تکرار تمام می‌شود:

```python
G = (n ** 2 for n in range(12))
list(G)


>>> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]
```
```python
list(G)
```

```python
list(G)

>>> []
```

این ویژگی می‌تواند بسیار مفید باشد زیرا به این معنی است که تکرار می‌تواند متوقف و دوباره شروع شود:

```python
G = (n**2 for n in range(12))
for n in G:
    print(n, end=' ')
    if n > 30: break

print("\ndoing something in between")

for n in G:
    print(n, end=' ')

>>> 0 1 4 9 16 25 36 
doing something in between
49 64 81 100 121 
```

یکی از جاهایی که این ویژگی را مفید یافته‌ام، هنگام کار با مجموعه‌ای از فایل‌های داده روی دیسک است؛ این یعنی می‌توانید به راحتی آن‌ها را به صورت دسته‌ای تحلیل کنید و اجازه دهید مولد پیگیری کند که کدام یک را هنوز مشاهده نکرده‌اید.

## توابع مولد: استفاده از ``yield``

در بخش قبل دیدیم که فهرست‌سازی (List Comprehensions) برای ایجاد لیست‌های نسبتاً ساده بهترین کاربرد را دارد، در حالی که استفاده از یک حلقه عادی ``for`` می‌تواند در موقعیت‌های پیچیده‌تر مناسب‌تر باشد.  
همین موضوع در مورد عبارات مولد نیز صادق است: ما می‌توانیم با استفاده از *توابع مولد* که از دستور ``yield`` استفاده می‌کنند، مولدهای پیچیده‌تری ایجاد کنیم.

در اینجا دو روش برای ساخت یک لیست یکسان داریم:

```python
L1 = [n ** 2 for n in range(12)]

L2 = []
for n in range(12):
    L2.append(n ** 2)

print(L1)
print(L2)

>>> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]
```

به طور مشابه، در اینجا دو روش برای ساخت مولدهای معادل داریم:

```python
G1 = (n ** 2 for n in range(12))

def gen():
    for n in range(12):
        yield n ** 2

G2 = gen()
print(*G1)
print(*G2)

>>> 0 1 4 9 16 25 36 49 64 81 100 121
0 1 4 9 16 25 36 49 64 81 100 121
```

```python
G1 = (n ** 2 for n in range(12))

def gen():
    for n in range(12):
        yield n ** 2

G2 = gen()
print(*G1)
print(*G2)

>>> 0 1 4 9 16 25 36 49 64 81 100 121
0 1 4 9 16 25 36 49 64 81 100 121
```

یک تابع مولد، تابعی است که به جای استفاده از ``return`` برای بازگرداندن یک مقدار به صورت یک‌باره، از ``yield`` برای تولید یک دنباله (احتمالاً بی‌پایان) از مقادیر استفاده می‌کند.  
دقیقاً مانند عبارات مولد، وضعیت مولد بین تکرارهای جزئی حفظ می‌شود، اما اگر بخواهیم یک کپی تازه از مولد داشته باشیم، می‌توانیم به سادگی دوباره تابع را فراخوانی کنیم.

## مثال: مولد اعداد اول  
در اینجا مثال مورد علاقه‌ام از یک تابع مولد را نشان می‌دهم: تابعی برای تولید یک سری نامحدود از اعداد اول.  
یک الگوریتم کلاسیک برای این کار *غربال اراتوستن* است که به این صورت عمل می‌کند:


```python
# Generate a list of candidates
L = [n for n in range(2, 40)]
print(L)


>>> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]
```

```python
# Remove all multiples of the first value
L = [n for n in L if n == L[0] or n % L[0] > 0]
print(L)

>>>[2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]
```

```python
# Remove all multiples of the second value
L = [n for n in L if n == L[1] or n % L[1] > 0]
print(L)

>>> [2, 3, 5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37]
```

```python
# Remove all multiples of the third value
L = [n for n in L if n == L[2] or n % L[2] > 0]
print(L)

>>> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
```

اگر این روش را به تعداد کافی روی یک لیست به اندازه کافی بزرگ تکرار کنیم، می‌توانیم هر تعداد عدد اول که می‌خواهیم تولید کنیم.

بیایید این منطق را در یک تابع مولد کپسوله کنیم:

```python
def gen_primes(N):
    """Generate primes up to N"""
    primes = set()
    for n in range(2, N):
        if all(n % p > 0 for p in primes):
            primes.add(n)
            yield n

print(*gen_primes(100))

>>> 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
```

تمام ماجرا همین است!  
اگرچه این قطعاً کارآمدترین پیاده‌سازی محاسباتی غربال اراتوستن نیست، اما نشان می‌دهد که سینتکس تابع مولد چقدر می‌تواند برای ساخت دنباله‌های پیچیده‌تر مناسب باشد.