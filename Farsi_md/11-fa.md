# List Comprehensions (درک لیست)

اگر به اندازه کافی کد پایتون بخوانید، بالاخره با ساختار مختصر و کارآمدی به نام *list comprehension* روبرو خواهید شد.
این یکی از ویژگی‌های پایتون است که مطمئنم اگر قبلاً از آن استفاده نکرده باشید، عاشقش خواهید شد. این ساختار چیزی شبیه به این است:

```python
[i for i in range(20) if i % 3 > 0]

>>> [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19]
```

نتیجه این کار یک لیست از اعداد است که مضارب عدد ۳ را حذف می‌کند.
اگرچه این مثال ممکن است در نگاه اول کمی گیج‌کننده به نظر برسد، اما با افزایش familiarity با پایتون، خواندن و نوشتن list comprehensions به امری طبیعی تبدیل خواهد شد.

## List Comprehensions پایه‌ای

List comprehensions در واقع روشی برای فشرده‌سازی یک حلقه for سازنده لیست در یک خط کوتاه و خوانا هستند.

به عنوان مثال، در ادامه یک حلقه را مشاهده می‌کنید که لیستی از ۱۲ مربع کامل اول را می‌سازد:

```python
L = []
for n in range(12):
    L.append(n ** 2)
L

>>> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]
```


معادل این کد به صورت List Comprehension به صورت زیر است:

```python
[n ** 2 for n in range(12)]

>>> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]
```

همانند بسیاری از دستورات پایتون، می‌توانید معنای این عبارت را تقریباً به زبان انگلیسی ساده بخوانید: «لیستی بسازید متشکل از مربع `n` برای هر `n` تا عدد ۱۲».

سینتکس پایه آن به این شکل است:  
`[`*`عبارت`* `for` *`متغیر`* `in` *`پیمایش‌پذیر`*`]`،  
که در آن *`عبارت`* هر عبارت معتبری است، *`متغیر`* یک نام متغیر است و *`پیمایش‌پذیر`* هر شیء پیمایش‌پذیر پایتون می‌باشد.

## پیمایش چندگانه

گاهی اوقات نیاز دارید یک لیست نه فقط از یک مقدار، بلکه از دو مقدار بسازید. برای این کار کافیست یک عبارت ``for`` دیگر به comprehension اضافه کنید:

```python
[(i, j) for i in range(2) for j in range(3)]

>>> [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]
```

توجه کنید که عبارت دوم ``for`` به عنوان ایندکس داخلی عمل می‌کند و سریع‌ترین تغییر را در لیست حاصل دارد.

این نوع ساختار را می‌توان به سه، چهار یا تعداد بیشتری iterator در درون comprehension گسترش داد، اگرچه در نقطه‌ای خوانایی کد کاهش خواهد یافت!


## شرط‌ها روی Iterator

می‌توانید با افزودن یک شرط در انتهای عبارت، کنترل بیشتری روی پیمایش اعمال کنید.
در اولین مثال این بخش، روی تمام اعداد از ۱ تا ۲۰ پیمایش کردیم، اما مضارب ۳ را حذف نمودیم.
دوباره به این مثال نگاه کنید و ساختار آن را توجه کنید:

```python
[val for val in range(20) if val % 3 > 0]

>>> [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19]
```

عبارت ``(i % 3 > 0)`` تنها در صورتی `False` می‌شود که مقدار بر ۳ بخش‌پذیر باشد.

باز هم می‌توان معنای این عبارت را مستقیماً به زبان انگلیسی خواند: "یک لیست از مقادیر برای هر عدد تا ۲۰ بساز، اما فقط در صورتی که مقدار بر ۳ بخش‌پذیر نباشد".

زمانی که با این syntax آشنا شوید، نوشتن آن - و درک آن در نگاه اول - بسیار ساده‌تر از syntax معادل با حلقه خواهد بود:

```python
L = []
for val in range(20):
    if val % 3:
        L.append(val)
L

>>> [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19]
```

## شرط‌ها روی مقدار

اگر قبلاً در C برنامه‌نویسی کرده باشید، احتمالاً با شرط تک خطی که با اپراتور ``?`` فعال می‌شود آشنا هستید:
``` C
int absval = (val < 0) ? -val : val
```
پایتون چیزی بسیار شبیه به این دارد که اغلب در List Comprehensions، توابع ``lambda`` و سایر جاهایی که یک expression ساده مورد نیاز است استفاده می‌شود:


```python
val = -10
val if val >= 0 else -val

>>> 10
```

می‌بینیم که این فقط عملکرد تابع داخلی ``abs()`` را تکرار می‌کند، اما این ساختار به شما امکان می‌دهد کارهای واقعاً جالبی درون List Comprehensions انجام دهید.

اگرچه الان دارد کمی پیچیده می‌شود، اما می‌توانید چیزی شبیه به این انجام دهید:

```python
[val if val % 2 else -val
 for val in range(20) if val % 3]

>>> [1, -2, -4, 5, 7, -8, -10, 11, 13, -14, -16, 17, 19]
```

توجه کنید به شکستن خط درون list comprehension قبل از عبارت ``for``: این کار در پایتون معتبر است و اغلب روش خوبی برای شکستن list comprehensionهای طولانی و بهبود خوانایی محسوب می‌شود.

به این نگاه کنید: کاری که ما انجام می‌دهیم، ساخت یک لیست است که مضارب ۳ را حذف می‌کند و همه مضارب ۲ را منفی می‌کند.

وقتی dynamics مربوط به list comprehensions را درک کنید، حرکت به سمت سایر انواع comprehensions بسیار ساده خواهد بود. syntax تا حد زیادی یکسان است؛ تنها تفاوت در نوع براکتی است که استفاده می‌کنید.

برای مثال، با استفاده از curly braces می‌توانید یک `set` با *set comprehension* ایجاد کنید:

```python
{n**2 for n in range(12)}

>>> {0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121}
```

به خاطر دارید که `set` یک مجموعه است که شامل هیچ مورد تکراری نیست.
set comprehension این قانون را رعایت می‌کند و هر ورودی تکراری را حذف می‌کند:

```python
{a % 3 for a in range(1000)}

>>> {0, 1, 2}
```

با یک تغییر کوچک، می‌توانید یک کولن (``:``) اضافه کنید تا یک *dict comprehension* ایجاد کنید:

```python
{n:n**2 for n in range(6)}

>>> {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

در نهایت، اگر به جای براکت‌های مربعی از پرانتز استفاده کنید، به چیزی به نام *generator expression* می‌رسید:

```python
(n**2 for n in range(12))

>>> <generator object <genexpr> at 0x1027a5a50>
```

یک generator expression در اصل یک list comprehension است که در آن المان‌ها به صورت on-demand و نه یک‌باره تولید می‌شوند. این سادگی، قدرت این ویژگی زبانی را پنهان می‌کند که بیشتر در ادامه به آن خواهیم پرداخت.

