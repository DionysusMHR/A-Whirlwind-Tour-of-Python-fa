# خطاها و استثناها (Errors and Exceptions)

مهم نیست چقدر به عنوان یک برنامه‌نویس مهارت داشته باشید، در نهایت مرتکب اشتباه کدنویسی خواهید شد.  
این اشتباهات عموماً در سه دسته اصلی قرار می‌گیرند:  

- **خطاهای نحوی (Syntax errors):** خطاهایی که در آن کد از نظر پایتون معتبر نیست (معمولاً به راحتی رفع می‌شوند).  
- **خطاهای زمان اجرا (Runtime errors):** خطاهایی که در آن کد از نظر نحوی معتبر است، اما در اجرا با شکست مواجه می‌شود؛ اغلب به دلیل ورودی نامعتبر کاربر (گاهی به راحتی رفع می‌شوند).  
- **خطاهای معنایی (Semantic errors):** خطاهای منطقی؛ کد بدون مشکل اجرا می‌شود، اما نتیجه آن چیزی نیست که انتظار دارید (اغلب ردیابی و رفع آن‌ها بسیار دشوار است).  

در اینجا قصد داریم بر نحوه مدیریت تمیز **خطاهای زمان اجرا** تمرکز کنیم.  
همان‌طور که خواهیم دید، پایتون این خطاها را از طریق چارچوب **مدیریت استثناها (exception handling)** پردازش می‌کند.

## خطاهای زمان اجرا (Runtime Errors)

اگر تا به حال در پایتون کدنویسی کرده باشید، احتمالاً با خطاهای زمان اجرا مواجه شده‌اید.  
این خطاها می‌توانند به روش‌های مختلفی رخ دهند.  

برای مثال، اگر سعی کنید به یک متغیر تعریف‌نشده ارجاع دهید:

```python
print(Q)

---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

<ipython-input-3-e796bdcf24ff> in <module>()

----> 1 print(Q)



NameError: name 'Q' is not defined
```

یا اگر عملیاتی را امتحان کنید که تعریف نشده است:

```python
1 + 'abc'

---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

<ipython-input-4-aab9e8ede4f7> in <module>()

----> 1 1 + 'abc'



TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

یا ممکن است در حال محاسبه یک نتیجه‌ی mathematically ill-defined (از نظر ریاضی تعریف‌نشده) باشید:

```python
2 / 0

---------------------------------------------------------------------------

ZeroDivisionError                         Traceback (most recent call last)

<ipython-input-5-ae0c5d243292> in <module>()

----> 1 2 / 0



ZeroDivisionError: division by zero
```

یا شاید بخواهید به یک عنصر در دنباله (sequence) دسترسی پیدا کنید که وجود ندارد:

```python
L = [1, 2, 3]
L[1000]

---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

<ipython-input-6-06b6eb1b8957> in <module>()

      1 L = [1, 2, 3]

----> 2 L[1000]



IndexError: list index out of range
```

توجه کنید که در هر مورد، پایتون به اندازه‌ای هوشمند است که نه تنها وقوع خطا را نشان می‌دهد، بلکه یک استثنای **معنادار** (meaningful exception) ارائه می‌کند که شامل اطلاعاتی دربارهٔ دقیقاً چه چیزی اشتباه رخ داده است، به همراه شمارهٔ دقیق خطای کد که خطا در آن رخ داده است.  
دسترسی به خطاهای معنادار مانند این، هنگام ردیابی ریشه مشکلات در کد شما، فوق‌العاده مفید است.


## گرفتن استثناها: ``try`` و ``except``

ابزار اصلی که پایتون برای مدیریت استثناهای زمان اجرا در اختیار شما قرار می‌دهد، دستور ``try``...``except`` است.  
ساختار پایهٔ آن به این شکل است:

```python
try:
    print("this gets executed first")
except:
    print("this gets executed only if there is an error")

>>> this gets executed first
```

توجه کنید که بلوک دوم در اینجا اجرا نشد: زیرا بلوک اول خطایی بازنگرداند.  
بیایید یک دستور مشکل‌دار در بلوک ``try`` قرار دهیم و ببینیم چه اتفاقی می‌افتد:

```python
try:
    print("let's try something:")
    x = 1 / 0 # ZeroDivisionError
except:
    print("something bad happened!")

>>> let's try something:
something bad happened!
```

در اینجا مشاهده می‌کنیم که وقتی خطا در عبارت ``try`` ایجاد شد (در این مورد، یک ``ZeroDivisionError``)، خطا گرفته شد و عبارت ``except`` اجرا گردید.

یکی از کاربردهای رایج این روش، بررسی ورودی کاربر درون یک تابع یا بخش دیگری از کد است.
برای مثال، ممکن است بخواهیم تابعی داشته باشیم که تقسیم بر صفر را گرفته و مقدار دیگری برگرداند، مثلاً یک عدد به اندازه‌ی کافی بزرگ مانند $10^{100}$:

```python
def safe_divide(a, b):
    try:
        return a / b
    except:
        return 1E100
```

```python
safe_divide(1, 2)

>>> 0.5
```

```python
safe_divide(2, 0)

>>> 1e+100
```

با این حال، یک مشکل ظریف در این کد وجود دارد: اگر نوع دیگری از exception رخ دهد چه اتفاقی می‌افتد؟ برای مثال، احتمالاً این چیزی نیست که ما در نظر داشتیم:


```python
safe_divide (1, '2')

>>> 1e+100
```

تقسیم یک عدد صحیح و یک رشته، یک ``TypeError`` ایجاد می‌کند که کد بیش از حد سختگیرانه‌ی ما آن را گرفته و به اشتباه فرض کرده یک ``ZeroDivisionError`` است!

به همین دلیل، تقریباً همیشه بهتر است exceptionها را به صورت *explicit* (صریح) بگیریم:


```python
def safe_divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        return 1E100
```


```python
safe_divide(1, 0)

>>> 1e+100
```

```python
safe_divide(1, '2')

---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

<ipython-input-15-2331af6a0acf> in <module>()

----> 1 safe_divide(1, '2')



<ipython-input-13-10b5f0163af8> in safe_divide(a, b)

      1 def safe_divide(a, b):

      2     try:

----> 3         return a / b

      4     except ZeroDivisionError:

      5         return 1E100



TypeError: unsupported operand type(s) for /: 'int' and 'str'
```


اکنون فقط خطاهای تقسیم بر صفر را می‌گیریم و به سایر خطاها اجازه می‌دهیم بدون تغییر عبور کنند.


## ایجاد استثناها با ``raise``
دیدیم که چقدر داشتن استثناهای informative (اطلاع‌دهنده) هنگام استفاده از بخش‌های مختلف زبان پایتون ارزشمند است.
به همان اندازه، استفاده از استثناهای informative در کدی که می‌نویسید نیز ارزشمند است، تا کاربران کد شما (که در درجه اول خود شما هستید!) بتوانند علت خطاهای خود را تشخیص دهند.

راه ایجاد استثناهای خودتان استفاده از عبارت ``raise`` است. برای مثال:

```python
raise RuntimeError("my error message")

---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

<ipython-input-16-c6a4c1ed2f34> in <module>()

----> 1 raise RuntimeError("my error message")



RuntimeError: my error message
```

به عنوان مثالی از کاربرد این قابلیت، بیایید به تابع ``fibonacci`` که قبلاً تعریف کردیم بازگردیم:

```python
def fibonacci(N):
    L = []
    a, b = 0, 1
    while len(L) < N:
        a, b = b, a + b
        L.append(a)
    return L
```

یک مشکل احتمالی اینجا این است که مقدار ورودی می‌تواند منفی باشد.
این در حال حاضر باعث بروز هیچ خطایی در تابع ما نمی‌شود، اما ممکن است بخواهیم به کاربر اطلاع دهیم که مقدار منفی برای ``N`` پشتیبانی نمی‌شود.
طبق قرارداد، خطاهای ناشی از مقادیر پارامتر نامعتبر، منجر به ایجاد یک ``ValueError`` می‌شوند:

```python
def fibonacci(N):
    if N < 0:
        raise ValueError("N must be non-negative")
    L = []
    a, b = 0, 1
    while len(L) < N:
        a, b = b, a + b
        L.append(a)
    return L
```

```python
fibonacci(10)

>>> [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

```python
fibonacci(-10)

---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

<ipython-input-20-3d291499cfa7> in <module>()

----> 1 fibonacci(-10)



<ipython-input-18-01d0cf168d63> in fibonacci(N)

      1 def fibonacci(N):

      2     if N < 0:

----> 3         raise ValueError("N must be non-negative")

      4     L = []

      5     a, b = 0, 1



ValueError: N must be non-negative
```


aاکنون کاربر دقیقاً می‌داند چرا ورودی نامعتبر است و حتی می‌تواند از بلوک ``try``...``except`` برای مدیریت آن استفاده کند!


```python
N = -10
try:
    print("trying this...")
    print(fibonacci(N))
except ValueError:
    print("Bad value: need to do something else")

>>> trying this...
Bad value: need to do something else
```

## بررسی عمیق‌تر Exceptions

به طور خلاصه، در اینجا می‌خواهم به چند مفهوم دیگر که ممکن است با آنها مواجه شوید اشاره کنم.
قصد ندارم در مورد جزئیات این مفاهیم و چگونگی و دلایل استفاده از آنها توضیح مفصلی بدهم، بلکه فقط syntax را به شما نشان می‌دهم تا بتوانید به طور مستقل بیشتر کاوش کنید.


### دسترسی به پیغام خطا

گاهی اوقات در عبارت ``try``...``except``، ممکن است بخواهید با خود پیغام خطا کار کنید.
این کار با استفاده از کلیدواژه‌ی ``as`` امکان‌پذیر است:

```python
try:
    x = 1 / 0
except ZeroDivisionError as err:
    print("Error class is:  ", type(err))
    print("Error message is:", err)

>>> Error class is:   <class 'ZeroDivisionError'>
Error message is: division by zero
```

با این الگو، می‌توانید مدیریت exception در تابع خود را بیشتر سفارشی کنید.

### تعریف exception های سفارشی

علاوه بر exception های داخلی، می‌توان از طریق *class inheritance* (ارث‌بری کلاس) exception های سفارشی تعریف کرد.

برای مثال، اگر به یک نوع خاص از ``ValueError`` نیاز دارید، می‌توانید این کار را انجام دهید:

```python
class MySpecialError(ValueError):
    pass

raise MySpecialError("here's the message")

---------------------------------------------------------------------------

MySpecialError                            Traceback (most recent call last)

<ipython-input-23-92c36e04a9d0> in <module>()

      2     pass

      3 

----> 4 raise MySpecialError("here's the message")



MySpecialError: here's the message
```

این امکان را به شما می‌دهد که از یک بلوک ``try``...``except`` استفاده کنید که فقط این نوع خطا را می‌گیرد:

```python
try:
    print("do something")
    raise MySpecialError("[informative error message here]")
except MySpecialError:
    print("do something else")

>>> do something
do something else
```

ممکن است این ویژگی در حین توسعه کدهای سفارشی‌تر برای شما مفید باشد.

## ``try``...``except``...``else``...``finally``

علاوه بر ``try`` و ``except``، می‌توانید از کلیدواژه‌های ``else`` و ``finally`` برای تنظیم دقیق‌تر مدیریت استثناها در کد خود استفاده کنید.
ساختار پایه به این شکل است:

```python
try:
    print("try something here")
except:
    print("this happens only if it fails")
else:
    print("this happens only if it succeeds")
finally:
    print("this happens no matter what")

>>> try something here
this happens only if it succeeds
this happens no matter what
```

کاربرد ``else`` در اینجا واضح است، اما هدف از ``finally`` چیست؟
در واقع، بند ``finally`` *under any circumstances* (در هر شرایطی) اجرا می‌شود: معمولاً از آن برای انجام برخی عملیات نظافتی پس از اتمام یک عملیات استفاده می‌شود.
