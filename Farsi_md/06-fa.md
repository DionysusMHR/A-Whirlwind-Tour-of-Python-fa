# ساختارهای داده داخلی

ما انواع ساده پایتون را دیده‌ایم: `int`، `float`، `complex`، `bool`، `str` و غیره. پایتون همچنین چندین نوع مرکب داخلی دارد که به عنوان نگهدارنده برای انواع دیگر عمل می‌کنند. این انواع مرکب عبارت‌اند از:

| نام نوع   | مثال                   | توضیح                                 |
|-----------|---------------------------|---------------------------------------|
| `list`    | `[1, 2, 3]`               | مجموعه مرتب‌شده                     |
| `tuple`   | `(1, 2, 3)`               | مجموعه مرتب و تغییرناپذیر           |
| `dict`    | `{'a':1, 'b':2, 'c':3}`   | نگاشت نامرتب (کلید، مقدار)           |
| `set`     | `{1, 2, 3}`               | مجموعه نامرتب از مقادیر منحصربه‌فرد |

همان‌طور که می‌بینید، پرانتزهای گرد، کروشه و آکولاد معانی متمایزی در مورد نوع مجموعه تولید شده دارند. در اینجا به طور خلاصه این ساختارهای داده را بررسی می‌کنیم.

## لیست‌ها

لیست‌ها، نوع پایه‌ی مجموعه‌داده‌های **مرتب** و **تغییرپذیر** در پایتون هستند. آن‌ها با مقادیر جدا شده با کاما درون کروشه تعریف می‌شوند. برای مثال، در زیر لیستی از چند عدد اول آورده شده است:

```python
L = [2, 3, 5, 7]
```

لیست‌ها دارای تعدادی ویژگی و متد مفید هستند. در اینجا نگاهی سریع به برخی از متداول‌ترین و کاربردی‌ترین آنها می‌اندازیم:

```python
# Length of a list
len(L)


>>> 4
```

```python
# Append a value to the end
L.append(11)
L


>>> [2, 3, 5, 7, 11]
```

```python
# Addition concatenates lists
L + [13, 17, 19]


>>> [2, 3, 5, 7, 11, 13, 17, 19]
```

```python
# sort() method sorts in-place
L = [2, 5, 1, 6, 3, 4]
L.sort()
L


>>> [1, 2, 3, 4, 5, 6]
```

علاوه بر این، متدهای داخلی بسیار بیشتری برای لیست‌ها وجود دارد که به خوبی در [مستندات آنلاین پایتون](https://docs.python.org/3/tutorial/datastructures.html) پوشش داده شده‌اند.

در حالی که ما لیست‌های حاوی مقادیر از یک نوع را نشان می‌دادیم، یکی از ویژگی‌های قدرتمند اشیاء مرکب پایتون این است که می‌توانند حاوی اشیاء از ***هر*** نوع، یا حتی ترکیبی از انواع باشند. برای مثال:


```python
L = [1, 'two', 3.14, [0, 3, 5]]
```
این انعطاف نتیجه سیستم نوع پویای پایتون است.
ایجاد چنین دنباله‌ای مختلط در یک زبان با نوع ایستا مانند C می‌تواند بسیار دردسرسازتر باشد!
می‌بینیم که لیست‌ها حتی می‌توانند شامل لیست‌های دیگر به عنوان عناصر باشند.
چنین انعطاف نوعی بخش ضروری از چیزی است که کد پایتون را نسبتاً سریع و آسان برای نوشتن می‌کند.

تاکنون ما دستکاری‌های لیست‌ها را به صورت کلی در نظر گرفته‌ایم؛ بخش ضروری دیگر دسترسی به عناصر منفرد است.
این کار در پایتون از طریق *ایندکس‌گذاری* و *برش‌زنی* انجام می‌شود، که در ادامه بررسی خواهیم کرد.

### ایندکس‌گذاری و برش‌زنی لیست‌ها

پایتون دسترسی به عناصر در انواع مرکب را از طریق *ایندکس‌گذاری* برای عناصر منفرد و *برش‌زنی* برای چندین عنصر فراهم می‌کند.
همان‌طور که خواهیم دید، هر دو با استفاده از یک سینتکس کروشه‌ای نشان‌ داده می‌شوند.
فرض کنید به لیست اعداد اول اولیه خود بازگردیم:


```python
L = [2, 3, 5, 7, 11]
```

پایتون از ایندکس‌گذاری *بر مبنای صفر* استفاده می‌کند، بنابراین می‌توانیم با استفاده از سینتکس زیر به عناصر اول و دوم دسترسی پیدا کنیم:

```python
L = [0]

>>> 2
```

```python
L = [1]

>>> 3
```

عناصر موجود در انتهای لیست را می‌توان با اعداد منفی، که از -۱ شروع می‌شوند، دسترسی یافت:

```python
L = [-1]

>>> 11
```

```python
L = [-2]

>>> 7
```

می‌توانید این روش ایندکس‌گذاری را به این صورت تصویر کنید:

![List Indexing Figure](fig/list-indexing.png)

در اینجا مقادیر داخل لیست با اعداد بزرگ درون کادرها نشان داده شده‌اند؛  
و اندیس‌های لیست با اعداد کوچک در بالا و پایین نمایش داده شده‌اند.  
در این حالت، ``L[2]`` مقدار ``5`` را برمی‌گرداند،  
چون این مقدار بعدی در اندیس ``2`` است.

در حالی که *ایندکس‌گذاری* روشی برای دریافت یک مقدار واحد از لیست است،  
*برش‌زنی* روشی برای دسترسی به چندین مقدار در زیرلیست‌ها محسوب می‌شود.  

در این روش از دونقطه برای نشان دادن نقطه شروع (شامل) و نقطه پایان (غیرشامل) زیرآرایه استفاده می‌شود.  
به عنوان مثال، برای دریافت سه عنصر اول لیست، می‌توانیم بنویسیم:

```python
L = [0:3]

>>> [2, 5, 3]
```

توجه کنید که ``0`` و ``3`` در نمودار قبلی در کجا قرار گرفته‌اند،  
و چگونه برش فقط مقادیر بین این اندیس‌ها را انتخاب می‌کند.  

اگر اندیس اول را حذف کنیم، مقدار ``0`` به طور پیش‌فرض در نظر گرفته می‌شود،  
بنابراین می‌توانیم به طور معادل بنویسیم:


```python
L = [:3]

>>> [2, 5, 3]
```

به طور مشابه، اگر اندیس آخر را حذف کنیم، به طور پیش‌فرض تا طول لیست در نظر گرفته می‌شود.  
بنابراین، سه عنصر آخر را می‌توان به صورت زیر دسترسی یافت:

```python
L = [-3]

>>> [5, 7, 11]
```

در نهایت، می‌توان یک عدد صحیح سوم را مشخص کرد که نشان‌دهنده اندازه گام است؛  
برای مثال، برای انتخاب هر عنصر دوم لیست، می‌توان نوشت:

```python
L[::2]  # equivalent to L[0:len(L):2]

>>> [2, 5, 11]
```

یک نسخه بسیار مفید از این قابلیت، مشخص کردن گام منفی است که آرایه را معکوس می‌کند:

```python
L[::-1]

>>> [11, 7, 5, 3, 2]
```

هم ایندکس‌گذاری و هم برش‌زنی می‌توانند برای تنظیم عناصر و همچنین دسترسی به آنها استفاده شوند.  
سینتکس آن همانطور که انتظار می‌رود به صورت زیر است:

```python
L[0] = 100
print(L)

>>> [100, 3, 5, 7, 11]
```

```python
L[1:3] = [55, 56]
print(L)


>>> [100, 55, 56, 7, 11]
```

سینتکس بسیار مشابه برای برش‌زنی در بسیاری از پکیج‌های متمرکز بر علم داده، از جمله NumPy و Pandas (که در مقدمه ذکر شد) نیز استفاده می‌شود.

حال که با لیست‌های پایتون و نحوه دسترسی به عناصر در انواع داده مرکب مرتب آشنا شدیم، اجازه دهید نگاهی به سه نوع داده مرکب استاندارد دیگر که پیش‌تر اشاره شد بیندازیم.

## تاپل‌ها (Tuples)  
تاپل‌ها از بسیاری جهات شبیه به لیست‌ها هستند، اما به جای کروشه با پرانتز تعریف می‌شوند:

```python
t = (1, 2, 3)
```
همچنین می‌توان آن‌ها را بدون هیچ پرانتزی تعریف کرد:

```python
t = 1, 2, 3
print(t)

>>> (1, 2, 3)
```

مانند لیست‌هایی که پیش‌تر بحث شد، تاپل‌ها نیز طول دارند و عناصر منفرد را می‌توان با استفاده از ایندکس‌گذاری کروشه‌ای استخراج کرد:

```python
len(t)

>>> 3
```

```python
t[0]

>>> 1
```

ویژگی اصلی متمایزکننده تاپل‌ها این است که آن‌ها *غیرقابل تغییر* (immutable) هستند: این بدان معنی است که پس از ایجاد، اندازه و محتوای آن‌ها را نمی‌توان تغییر داد:

```python
t[1] = 4
```

---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

<ipython-input-23-141c76cb54a2> in <module>()

----> 1 t[1] = 4



TypeError: 'tuple' object does not support item assignment

```python
t.append(4)
```

---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

<ipython-input-24-e8bd1632f9dd> in <module>()

----> 1 t.append(4)



AttributeError: 'tuple' object has no attribute 'append'

تاپل‌ها اغلب در برنامه‌های پایتون استفاده می‌شوند. یک مورد بسیار رایج، در توابعی است که چندین مقدار بازگشتی دارند.  
به عنوان مثال، متد ``as_integer_ratio()`` برای اشیاء اعشاری، یک صورت و مخرج بازمی‌گرداند. این مقدار بازگشتی دوگانه به صورت یک تاپل ارائه می‌شود:

```python
x = 0.125
x.as_integer_ratio()

>>> (1, 8)
```

این مقادیر بازگشتی چندگانه را می‌توان به صورت جداگانه به این صورت تخصیص داد:

```python
numerator, denominator = x.as_integer_ratio()
print(numerator / denominator)

>>> 0.125
```

منطق ایندکس‌گذاری و برش‌زنی که پیش‌تر برای لیست‌ها اشاره شد، برای تاپل‌ها نیز کاربرد دارد، به همراه میزانی از متدهای دیگر.  
برای فهرست کامل‌تر این موارد به [مستندات پایتون](https://docs.python.org/3/tutorial/datastructures.html) مراجعه کنید.

## دیکشنری‌ها  
دیکشنری‌ها نگاشت‌های بسیار انعطاف‌پذیری از کلیدها به مقادیر هستند و پایه بسیاری از پیاده‌سازی‌های داخلی پایتون را تشکیل می‌دهند.  
آنها را می‌توان از طریق یک لیست جدا شده با کاما از جفت‌های ``کلید:مقدار`` درون آکولاد ایجاد کرد:

```python
numbers = {'one':1, 'two':2, 'three':3}
```

عناصر از طریق سینتکس ایندکس‌گذاری مورد استفاده برای لیست‌ها و تاپل‌ها قابل دسترسی و تنظیم هستند، با این تفاوت که در اینجا ایندکس بر اساس ترتیب مبتنی بر صفر نیست، بلکه یک کلید معتبر در دیکشنری است:

```python
# Access a value via the key
numbers['two']

>>> 2
```

مقادیر جدید نیز می‌توانند با استفاده از ایندکس‌گذاری به دیکشنری اضافه شوند:

```python
# Set a new key:value pair
numbers['ninety'] = 90
print(numbers)

>>> {'three': 3, 'ninety': 90, 'two': 2, 'one': 1}
```

در نظر داشته باشید که دیکشنری‌ها هیچ ترتیبی برای پارامترهای ورودی حفظ نمی‌کنند؛ این موضوع به صورت طراحی شده است.  
این عدم حفظ ترتیب به دیکشنری‌ها اجازه می‌دهد تا با کارایی بسیار بالا پیاده‌سازی شوند، به طوری که دسترسی تصادفی به عناصر بسیار سریع باشد، بدون توجه به اندازه دیکشنری (اگر کنجکاو هستید که این چگونه کار می‌کند، در مورد مفهوم *جدول هش* مطالعه کنید).  
[مستندات پایتون](https://docs.python.org/3/library/stdtypes.html) دارای یک لیست کامل از متدهای موجود برای دیکشنری‌ها است.

## مجموعه‌ها (Sets)  
چهارمین مجموعه پایه، مجموعه است که شامل مجموعه‌های بدون ترتیب از آیتم‌های منحصربه‌فرد می‌باشد.  
آنها بسیار شبیه به لیست‌ها و تاپل‌ها تعریف می‌شوند، با این تفاوت که از آکولادهای دیکشنری‌ها استفاده می‌کنند:

```python
primes = {2, 3, 5, 7}
odds = {1, 3, 5, 7, 9}
```

اگر با ریاضیات مجموعه‌ها آشنا باشید، با عملیات‌هایی مانند اجتماع، اشتراک، تفاوت، تفاوت متقارن و دیگر موارد آشنا خواهید بود.  
مجموعه‌های پایتون همه این عملیات‌ها را به صورت داخلی از طریق متدها یا عملگرها دارند.  
برای هرکدام، دو روش معادل را نشان خواهیم داد:


```python
# union: items appearing in either
primes | odds      # with an operator
primes.union(odds) # equivalently with a method

>>> {1, 2, 3, 5, 7, 9}
```

```python
# intersection: items appearing in both
primes & odds             # with an operator
primes.intersection(odds) # equivalently with a method

>>> {3, 5, 7}
```

```python
# difference: items in primes but not in odds
primes - odds           # with an operator
primes.difference(odds) # equivalently with a method

>>> {2}
```


```python
# symmetric difference: items appearing in only one set
primes ^ odds                     # with an operator
primes.symmetric_difference(odds) # equivalently with a method

>>> {1, 2, 9}
```

متدها و عملیات بسیار بیشتری برای مجموعه‌ها موجود است.  
احتمالاً حدس زده‌اید که چه می‌خواهم بگویم: برای راهنمای کامل به [مستندات آنلاین پایتون](https://docs.python.org/3/library/stdtypes.html) مراجعه کنید.

## ساختارهای داده تخصصی‌تر

پایتون شامل چندین ساختار داده دیگر است که ممکن است برای شما مفید باشند. این موارد معمولاً در ماژول توکار ``collections`` یافت می‌شوند.
ماژول collections به طور کامل در [مستندات آنلاین پایتون](https://docs.python.org/3/library/collections.html) مستند شده است و می‌توانید درباره اشیاء مختلف موجود در آن اطلاعات بیشتری کسب کنید.

به طور خاص، موارد زیر در عمل بسیار مفید بوده‌اند:

- ``collections.namedtuple``: مشابه تاپل، اما هر مقدار دارای یک نام است
- ``collections.defaultdict``: مشابه دیکشنری، اما کلیدهای مشخص‌نشده دارای یک مقدار پیش‌فرض تعریف‌شده توسط کاربر هستند
- ``collections.OrderedDict``: مشابه دیکشنری، اما ترتیب کلیدها حفظ می‌شود

پس از آشنایی با انواع مجموعه‌های توکار استاندارد، استفاده از این قابلیت‌های توسعه‌یافته بسیار شهودی خواهد بود و پیشنهاد می‌کنم [در مورد نحوه استفاده از آنها مطالعه کنید](https://docs.python.org/3/library/collections.html).

