## معناشناسی پایه پایتون: متغیرها و اشیاء (Variables and Objects)

این بخش به بررسی معناشناسی پایه زبان پایتون می‌پردازد. در مقابل *سینتکس* که در بخش قبل مورد بررسی قرار گرفت، *معناشناسی* یک زبان به معنای واقعی پشت دستورات می‌پردازد. همانند بحث سینتکس، در اینجا نیز چندین ساختار معنایی ضروری در پایتون را مرور خواهیم کرد تا چارچوب بهتری برای درک کدهای بخش‌های بعدی داشته باشید.

این بخش معناشناسی *متغیرها* و *اشیاء* را پوشش می‌دهد که روش‌های اصلی ذخیره‌سازی، ارجاع و عمل روی داده‌ها در یک اسکریپت پایتون هستند.

---

**نکات ترجمه:**
-   **Semantics** به «معناشناسی» ترجمه شد که ترجمه دقیق و استاندارد این مفهوم در برنامه‌نویسی است.
-   **Syntax** به «سینتکس» ترجمه شد و همانطور که قبلاً توافق شد، اصلاح تخصصی حفظ گردید.
-   **Meaning of the statements** به «معنای واقعی پشت دستورات» ترجمه شد تا مفهوم به صورت روان منتقل شود.
-   **Frame of reference** به «چارچوب مرجع» یا ساده‌تر، «چارچوب بهتری» ترجمه شد.
-   **Store, reference, and operate on data** به «ذخیره‌سازی، ارجاع و عمل روی داده‌ها» ترجمه شد که ترجمه‌ای دقیق و حرفه‌ای است.
-   لحن ترجمه همچنان رسمی، روان و مطابق با سبک کتاب‌های آموزشی است.

## متغیرهای پایتون اشاره‌گر هستند

اختصاص دادن متغیرها در پایتون به سادگی قرار دادن نام متغیر در سمت چپ علامت مساوی (``=``) است:

```python
# اختصاص مقدار 4 به متغیر x
x = 4
```

این ممکن است ساده به نظر برسد، اما اگر درک ذهنی نادرستی از اینکه این عملیات چه می‌کند داشته باشید، نحوه کار پایتون ممکن است گیج‌کننده به نظر برسد. در اینجا به طور خلاصه به این موضوع می‌پردازیم.

در بسیاری از زبان‌های برنامه‌نویسی، بهترین راه برای تصور متغیرها این است که آن‌ها را به عنوان ظروف یا سطل‌هایی در نظر بگیرید که داده‌ها را درون آن‌ها قرار می‌دهید. برای مثال در زبان C، وقتی می‌نویسید:

```C
// کد C
int x = 4;
```

شما اساساً یک "سطل حافظه" به نام ``x`` تعریف می‌کنید و مقدار ``4`` را درون آن قرار می‌دهید. در مقابل، در پایتون بهتر است متغیرها را نه به عنوان ظروف، بلکه به عنوان اشاره‌گر در نظر بگیرید. بنابراین در پایتون، وقتی می‌نویسید:

```python
x = 4
```

شما اساساً یک *اشاره‌گر* به نام ``x`` تعریف می‌کنید که به یک سطل دیگر حاوی مقدار ``4`` اشاره می‌کند. به یک نتیجه‌گیری از این موضوع توجه کنید: چون متغیرهای پایتون فقط به اشیاء مختلف اشاره می‌کنند، نیازی به "تعریف" متغیر نیست، یا حتی لازم نیست متغیر همیشه به اطلاعاتی از نوع یکسان اشاره کند!

این همان معنایی است که مردم می‌گویند پایتون *به صورت پویا تایپ شده* است: نام متغیرها می‌توانند به اشیاء هر نوعی اشاره کنند. بنابراین در پایتون، می‌توانید کارهایی مانند این انجام دهید:

```python
x = 1         # x is an integer
x = 'hello'   # now x is a string
x = [1, 2, 3] # now x is a list
```

اگرچه کاربران زبان‌های با تایپ استاتیک ممکن است امنیت نوعی (type-safety) که همراه با تعریف‌های مشابه آنچه در C وجود دارد را از دست بدهند،

```C
int x = 4;
```

اما همین تایپ پویا یکی از دلایلی است که پایتون را برای نوشتن سریع و خواندن آسان می‌کند.

این رویکرد "متغیر به عنوان اشاره‌گر" نتیجه‌ای دارد که باید از آن آگاه باشید. اگر دو نام متغیر به یک شیء *قابل تغییر** (mutable) اشاره کنند، در این صورت تغییر یکی، دیگری را نیز تغییر خواهد داد!

برای مثال، بیایید یک لیست ایجاد و تغییر دهیم:

---

**توضیح نکات ترجمه:**
-   **Statically-typed languages** به «زبان‌های با تایپ استاتیک» ترجمه شد.
-   **Type-safety** به «امنیت نوعی» ترجمه شد که معادل رایج این مفهوم است.
-   **Dynamic typing** به «تایپ پویا» ترجمه شد.
-   **Mutable object** به «شیء قابل تغییر» ترجمه شد و اصطلاح اصلی در پرانتز ذکر شد.
-   مفهوم اصلی جمله آخر درباره اشاره‌گر بودن متغیرها به خوبی منتقل شده است.
-   مثال کد C بدون تغییر باقی مانده است.

```python
x = [1, 2, 3]
y = x
```

ما دو متغیر `x` و `y` ایجاد کرده‌ایم که هر دو به یک شیء اشاره می‌کنند. به همین دلیل، اگر لیست را از طریق یکی از نام‌هایش تغییر دهیم، خواهیم دید که "لیست دیگر" نیز تغییر می‌کند:

```python
x = [1, 2, 3]
y = x  # حالا y و x هر دو به یک لیست اشاره می‌کنند

x.append(4)  # تغییر لیست از طریق x
print(y)     # خروجی: [1, 2, 3, 4] - y نیز تغییر کرده است!
```

این رفتار به این دلیل رخ می‌دهد که `x` و `y` اشاره‌گرهایی به یک شیء واحد در حافظه هستند، نه این که کپی‌های جداگانه‌ای از لیست باشند.

```python
print(y)

>>> [1, 2, 3, 4]
```
این رفتار ممکن است اگر به اشتباه متغیرها را به عنوان سطل‌هایی که داده را در خود نگه می‌دارند در نظر بگیرید، گیج‌کننده به نظر برسد. اما اگر به درستی متغیرها را به عنوان اشاره‌گر به اشیاء در نظر بگیرید، این رفتار کاملاً منطقی خواهد بود.

همچنین توجه داشته باشید که اگر از "``=``" برای اختصاص مقدار دیگری به ``x`` استفاده کنیم، این کار روی مقدار ``y`` تأثیری نخواهد داشت - زیرا عمل انتساب صرفاً تغییری در شیئی است که متغیر به آن اشاره می‌کند:

```python
x = [1, 2, 3]
y = x      # هر دو به یک شیء اشاره می‌کنند
x = [4, 5, 6]  # حالا x به یک شیء جدید اشاره می‌کند

print(x)   # خروجی: [4, 5, 6]
print(y)   # خروجی: [1, 2, 3] - y بدون تغییر باقی می‌ماند
```

در این مثال، وقتی ``x`` را به یک لیست جدید اختصاص می‌دهیم، تنها اشاره‌گر ``x`` را تغییر داده‌ایم و ``y`` همچنان به شیء اصلی اشاره می‌کند.

```python
x = 'something else'
print(y)  # y is unchanged

>>> [1, 2, 3, 4]
```

باز هم تأکید می‌کنم که این موضوع کاملاً منطقی خواهد بود اگر ``x`` و ``y`` را اشاره‌گر در نظر بگیرید و عملگر "``=``" را عملیاتی بدانید که جهت اشاره یک نام را تغییر می‌دهد.

ممکن است بپرسید آیا این مفهوم اشاره‌گر، عملیات ریاضی در پایتون را پیچیده می‌کند یا خیر؟ اما پایتون به گونه‌ای طراحی شده که این مسئله مشکلی ایجاد نمی‌کند. اعداد، رشته‌ها و سایر *انواع داده ساده* (simple types) تغییرناپذیر (immutable) هستند: شما نمی‌توانید مقدار آن‌ها را تغییر دهید - فقط می‌توانید مقادیری که متغیرها به آن‌ها اشاره می‌کنند را تغییر دهید.

بنابراین برای مثال، انجام عملیاتی مانند نمونه زیر کاملاً ایمن است:

```python
x = 5
y = x  # هر دو به عدد ۵ اشاره می‌کنند
x = x + 1  # یک عدد جدید (۶) ایجاد شده و x به آن اشاره می‌کند

print(x)  # خروجی: 6
print(y)  # خروجی: 5 - y بدون تغییر باقی می‌ماند
```

در این مورد، عملگر ``+`` یک شیء عددی جدید ایجاد می‌کند و متغیر ``x`` را به این شیء جدید اشاره می‌دهد، در حالی که ``y`` همچنان به شیء عددی اصلی اشاره دارد.

```python
x = 10
y = x
x += 5  # add 5 to x's value, and assign it to x
print("x =", x)
print("y =", y)

>>> x = 15
    y = 10
```

وقتی می‌نویسیم ``x += 5``، در واقع مقدار شیء ``10`` که ``x`` به آن اشاره می‌کند را تغییر نمی‌دهیم؛ بلکه متغیر ``x`` را طوری تغییر می‌دهیم که به یک شیء عددی جدید با مقدار ``15`` اشاره کند. به همین دلیل، مقدار ``y`` تحت تأثیر این عملیات قرار نمی‌گیرد.

```python
x = 10
y = x    # هر دو به عدد ۱۰ اشاره می‌کنند
x += 5   # ایجاد یک عدد جدید (۱۵) و تغییر اشاره x به آن

print(x)  # خروجی: 15
print(y)  # خروجی: 10 - y بدون تغییر باقی می‌ماند
```

این رفتار به دلیل تغییرناپذیر (immutable) بودن اعداد در پایتون است. عملگر ``+=`` یک شیء جدید ایجاد می‌کند و متغیر سمت چپ را به آن اشاره‌گر جدید تنظیم می‌کند، در حالی که اشاره‌گرهای دیگر همچنان به شیء اصلی اشاره می‌کنند.

## همه چیز یک شیء است

پایتون یک زبان برنامه‌نویسی شیءگرا است و در پایتون همه چیز یک شیء محسوب می‌شود.

بگذارید این مفهوم را بیشتر باز کنیم. پیش‌تر دیدیم که متغیرها صرفاً اشاره‌گر هستند و نام متغیرها خود به تنهایی حاوی اطلاعات نوع نیستند. این موضوع باعث شده برخی به اشتباه ادعا کنند که پایتون یک زبان بدون نوع است. اما این ادعا درست نیست!

مثال زیر را در نظر بگیرید:

```python
x = 4
type(x)  # خروجی: <class 'int'>

x = 'hello'
type(x)  # خروجی: <class 'str'>

x = [1, 2, 3]
type(x)  # خروجی: <class 'list'>
```

همانطور که می‌بینید، هر شیء در پایتون دارای یک نوع مشخص است - حتی مقادیر ساده مانند اعداد صحیح و رشته‌ها. آنچه که پایتون را به زبانی «پویا» تبدیل می‌کند این نیست که اشیاء بدون نوع هستند، بلکه این است که **متغیرها** می‌توانند به اشیاء هر نوعی اشاره کنند.

این طراحی هوشمندانه به پایتون امکان می‌دهد هم انعطاف‌پذیری نوع پویا داشته باشد و هم در عین حال تمام مزایای یک سیستم نوع قوی را حفظ کند. هر شیء می‌داند چه نوعی است و چه عملیاتی را می‌توان روی آن انجام داد.

```python
x = 4
type(x)

>>> int
```

```python
x = 'hello'
type(x)

>>> str
```

```python
x = 3.14159
type(x)

>>> float
```

پایتون دارای نوع است؛ با این حال، انواع به نام متغیرها مرتبط نیستند بلکه *به خود اشیاء* پیوند خورده‌اند.

در زبان‌های برنامه‌نویسی شیءگرا مانند پایتون، یک *شیء* موجودیتی است که شامل داده به همراه ابرداده و/یا قابلیت‌های مرتبط است. در پایتون همه چیز یک شیء است، که به این معنی است که هر موجودیتی دارای مقداری ابرداده (که *ویژگی‌ها* نامیده می‌شود) و قابلیت‌های مرتبط (که *متدها* نامیده می‌شوند) است. این ویژگی‌ها و متدها از طریق سینتکس نقطه قابل دسترسی هستند.

برای مثال، پیش از این دیدیم که لیست‌ها یک متد ``append`` دارند که یک مورد به لیست اضافه می‌کند و از طریق سینتکس نقطه ("``.``") قابل دسترسی است:

```python
my_list = [1, 2, 3]
my_list.append(4)  # فراخوانی متد append با استفاده از نقطه
print(my_list)     # خروجی: [1, 2, 3, 4]
```

این طراحی مبتنی بر شیء بودن همه چیز، یکی از قوی‌ترین ویژگی‌های پایتون است که consistency و قدرت زیادی به زبان می‌بخشد. حتی انواع داده به ظاهر ساده مانند اعداد صحیح و رشته‌ها نیز شیء هستند و دارای متدها و ویژگی‌های مربوط به خود می‌باشند.

```python
L = [1, 2, 3]
L.append(100)
print(L)

>>> [1, 2, 3, 100]
```

اگرچه انتظار می‌رود اشیاء مرکب مانند لیست‌ها دارای ویژگی‌ها و متد باشند، آنچه گاهی غیرمنتظره است این است که در پایتون حتی انواع ساده نیز دارای ویژگی‌ها و متدهای پیوست شده هستند.

برای مثال، انواع عددی دارای یک ویژگی ``real`` و ``imag`` هستند که بخش حقیقی و موهومی مقدار را برمی‌گردانند، اگر به عنوان یک عدد مختلط در نظر گرفته شود:

```python
x = 4.5
print(x.real)  # خروجی: 4.5
print(x.imag)  # خروجی: 0.0

y = 3 + 4j
print(y.real)  # خروجی: 3.0
print(y.imag)  # خروجی: 4.0
```

این نشان می‌دهد که حتی مقادیر عددی ساده مانند اعشاری نیز به عنوان شیء پیاده‌سازی شده‌اند و دارای ویژگی‌های داخلی هستند. این طراحی یکنواخت به برنامه‌نویسان اجازه می‌دهد با تمامی انواع داده در پایتون به صورت سازگار و یکپارچه کار کنند.

```python
x = 4.5
print(x.real, "+", x.imag, 'i')

>>> 4.5 + 0.0 i
```
متدها شبیه به ویژگی‌ها هستند، با این تفاوت که آن‌ها توابعی هستند که می‌توانید با استفاده از پرانتزهای باز و بسته آن‌ها را فراخوانی کنید.

برای مثال، اعداد اعشاری متدی به نام ``is_integer`` دارند که بررسی می‌کند آیا مقدار یک عدد صحیح است یا خیر:

```python
x = 4.0
y = 4.1

print(x.is_integer())  # خروجی: True
print(y.is_integer())  # خروجی: False
```

این نشان می‌دهد که چگونه حتی ساده‌ترین انواع داده در پایتون نیز دارای قابلیت‌های پیشرفته و متدهای کاربردی هستند. پرانتزهای پس از نام متد () نشان‌دهنده فراخوانی تابع هستند و در صورت عدم استفاده از پرانتز، خود تابع به عنوان یک شیء بازگردانده می‌شود بدون اینکه اجرا شود.

```python
x = 4.5
x.is_integer()

>>> False
```

```python
x = 4.0
x.is_integer()

>>> True
```

وقتی می‌گوییم هر چیزی در پایتون یک شیء است، واقعاً منظورمان این است که *همه چیز* یک شیء است - حتی ویژگی‌ها و متدهای اشیاء خود به تنهایی اشیائی هستند که دارای اطلاعات ``نوع`` مربوط به خود هستند:

```python
x = 4.5

# type خود متد is_integer یک شیء است
print(type(x.is_integer))  # خروجی: <class 'builtin_function_or_method'>

# type خود ویژگی real یک شیء است  
print(type(x.real))        # خروجی: <class 'float'>
```

این سطح از یکنواختی و سازگاری در طراحی زبان، کار با پایتون را بسیار直观 و قابل پیش‌بینی می‌کند. از آنجایی که همه چیز به صورت شیء پیاده‌سازی شده است، می‌توان با تمامی اجزای زبان به صورت یکسان و با استفاده از یک سینتکس مشترک کار کرد.


```python
type(x.is_integer)

>>> builtin_function_or_method
```

خواهیم دید که این انتخاب طراحیِ «همه-چیز-شیء-است» در پایتون، امکان ایجاد برخی ساختارهای زبانی بسیار کاربردی را فراهم می‌کند.

این یکپارچگی عمیق به موارد زیر منجر می‌شود:

*   **یکنواختی سینتکس:** نحوه تعامل با انواع مختلف داده‌ها (اعم از ساده یا پیچیده) یکسان است.
*   **انعطاف‌پذیری بالا:** از آنجایی که حتی توابع، ماژول‌ها و کلاس‌ها نیز شیء هستند، می‌توان آن‌ها را مانند هر داده دیگری منتقل، ذخیره و تغییر داد.
*   **قابلیت بازتاب (Reflection):** می‌توان در حین اجرا به بررسی و تغییر ساختار اشیاء پرداخت زیرا اطلاعات نوع و ساختار به عنوان بخشی از خود شیء در دسترس هستند.
*   **توسعه‌پذیری:** می‌توان رفتار عملگرها و توابع built-in را برای اشیاء自定义 تعریف کرد.

