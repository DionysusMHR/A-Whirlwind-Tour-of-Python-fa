تکرارکننده‌ها (Iterators)


اغلب بخش مهمی از تحلیل داده، انجام محاسبات مشابه به صورت مکرر و خودکار است.

برای مثال، ممکن است جدولی از نام‌ها داشته باشید که می‌خواهید آن را به نام و نام خانوادگی تقسیم کنید، یا جدولی از تاریخ‌ها که می‌خواهید به قالبی استاندارد تبدیل کنید.

یکی از پاسخ‌های پایتون به این نیاز، سینتکس *تکرارکننده* است.
ما قبلاً با تکرارکننده ``range`` آشنا شده‌ایم:

```python
for i in range(10):
    print(i, end=' ')

>>> 0 1 2 3 4 5 6 7 8 9 
```

در اینجا قصد داریم کمی عمیق‌تر به موضوع بپردازیم.
مشخص شده که در پایتون ۳، ``range`` یک لیست نیست، بلکه چیزی به نام *تکرارکننده* (iterator) است، و درک نحوه عملکرد آن کلید فهم دسته وسیعی از قابلیت‌های بسیار مفید پایتون محسوب می‌شود.

## پیمایش لیست‌ها

تکرارکننده‌ها را شاید بتوان به ساده‌ترین شکل در مورد عینی پیمایش یک لیست درک کرد.  
مثال زیر را در نظر بگیرید:

```python
for value in [2, 4, 6, 8, 10]:
    # do some operation
    print(value + 1, end=' ')

>>> 3 5 7 9 11 
```

سینتکس آشنای "``for x in y``" به ما امکان می‌دهد تا یک عملیات را برای هر مقدار در لیست تکرار کنیم.  
اینکه سینتکس کد بسیار نزدیک به توصیف انگلیسی آن است ("*برای [هر] مقدار در [این] لیست*")، تنها یکی از انتخاب‌های نحوی است که پایتون را به زبانی اینقوت intuitive برای یادگیری و استفاده تبدیل کرده است.

اما آنچه در ظاهر اتفاق می‌افتد، چیزی نیست که *واقعاً* در جریان است.  
وقتی چیزی مانند "``for val in L``" می‌نویسید، مفسر پایتون بررسی می‌کند که آیا این شیء دارای واسط *تکرارکننده* است یا خیر. شما خودتان می‌توانید این موضوع را با تابع توکار ``iter`` بررسی کنید:

```python
for iter([2, 4, 6, 8, 10])

>>> <list_iterator at 0x104722400>
```

این شیء تکرارکننده است که قابلیت‌های مورد نیاز حلقه ``for`` را فراهم می‌کند.  
شیء ``iter`` یک نگهدارنده است که تا زمانی که معتبر باشد، به شما امکان دسترسی به شیء بعدی را می‌دهد. این رفتار را می‌توان با تابع توکار ``next`` مشاهده کرد:

```python
I = iter([2, 4, 6, 8, 10])
```

```python
print(next(I))


>>> 2
```

```python
print(next(I))

>>> 4
```

```python
print(next(I))

>>> 6
```

هدف از این سطح از غیرمستقیم‌گویی چیست؟  
خب، مشخص شده که این روش فوق‌العاده مفید است، زیرا به پایتون اجازه می‌دهد چیزهایی را به عنوان لیست در نظر بگیرد که *در واقع لیست نیستند*.

## ``range()``: همیشه یک لیست، لیست نیست

شاید رایج‌ترین مثال از این تکرار غیرمستقیم، تابع ``range()`` در پایتون ۳ (با نام ``xrange()`` در پایتون ۲) باشد که نه یک لیست، بلکه یک شیء خاص ``range()`` برمی‌گرداند:

```python
range(10)

>>> range(0, 10)
```

``range``، همانند یک لیست، یک تکرارکننده در اختیار قرار می‌دهد:

```python
iter(range(10))

>>> <range_iterator at 0x1045a1810>
```

بنابراین پایتون می‌داند که باید با آن *انگار* یک لیست است رفتار کند:

```python
for i in range(10):
    print(i, end=' ')

>>> 0 1 2 3 4 5 6 7 8 9 
```

```python
iter(range(10))

>>> <range_iterator at 0x1045a1810>
```

مزیت غیرمستقیم‌گویی iterator این است که *لیست کامل هرگز به صورت صریح ایجاد نمی‌شود!*  
ما می‌توانیم این را با انجام یک محاسبه‌ی range مشاهده کنیم که اگر واقعاً آن را نمونه‌سازی کنیم، حافظه سیستم را overwhelmed خواهد کرد (توجه داشته باشید که در پایتون 2، ``range`` یک لیست ایجاد می‌کند، بنابراین اجرای موارد زیر به نتایج خوبی منجر نخواهد شد!):

```python
N = 10 ** 12
for i in range(N):
    if i >= 10: break
    print(i, end=', ')

>>> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
```

اگر ``range`` واقعاً آن لیست یک تریلیون مقداری را ایجاد می‌کرد، ده‌ها ترابایت از حافظه ماشین را اشغال می‌کرد: که هدررفتن منابع محسوب می‌شد، با توجه به این واقعیت که ما همه مقادیر به جز 10 مورد اول را نادیده می‌گیریم!

در واقع، هیچ دلیلی وجود ندارد که تکرارکننده‌ها حتماً باید پایان داشته باشند!
کتابخانه ``itertools`` پایتون شامل یک تابع ``count`` است که مانند یک range بی‌پایان عمل می‌کند:

```python
from itertools import count

for i in count():
    if i >= 10:
        break
    print(i, end=', ')

>>> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
```

اگر این دستور توقف (`break`) را در حلقه قرار نمی‌دادیم، برنامه به شکلی بی‌وقفه به شمارش ادامه می‌داد تا زمانی که فرآیند به صورت دستی متوقف یا خاتمه داده شود (برای مثال با استفاده از ``ctrl-C``).

## تکرارکننده‌های مفید

این سینتکس تکرارکننده تقریباً به صورت جهانی در انواع توکار پایتون و همچنین در اشیاء خاص‌تر مربوط به علم داده که در بخش‌های بعدی بررسی خواهیم کرد، استفاده می‌شود.  
در اینجا به برخی از تکرارکننده‌های مفیدتر در زبان پایتون می‌پردازیم:

### ``enumerate``

اغلب نه تنها نیاز به تکرار مقادیر یک آرایه دارید، بلکه باید ایندکس (شماره‌ی) آن‌ها را نیز دنبال کنید.  
ممکن است وسوسه شوید که این کار را به صورت زیر انجام دهید:

```python
L = [2, 4, 6, 8, 10]
for i in range(len(L)):
    print(i, L[i])

>>> 0 2
1 4
2 6
3 8
4 10
```

اگرچه این روش کار می‌کند، پایتون با استفاده از تکرارکننده ``enumerate`` یک سینتکس تمیزتر ارائه می‌دهد:


```python
for i, val in enumerate(L):
    print(i, val)

>>> 0 2
1 4
2 6
3 8
4 10
```

این روش، راهی «پایتونی‌تر» برای شمارش اندیس‌ها و مقادیر یک لیست است.

### ``zip``

در مواقع دیگر، ممکن است چندین لیست داشته باشید که می‌خواهید به طور همزمان روی آن‌ها تکرار کنید.  
مطمئناً می‌توانید مانند مثال غیرپایتونی که قبلاً بررسی کردیم، روی اندیس تکرار کنید، اما بهتر است از تکرارکننده ``zip`` استفاده کنید که تکرارپذیرها را به هم متصل می‌کند:

```python
L = [2, 4, 6, 8, 10]
R = [3, 6, 9, 12, 15]
for lval, rval in zip(L, R):
    print(lval, rval)

>>> 2 3
4 6
6 9
8 12
10 15
```

هر تعداد از تکرارپذیرها را می‌توان با هم zip کرد، و اگر طول‌های متفاوتی داشته باشند، کوتاه‌ترین آن‌ها طول ``zip`` را تعیین می‌کند.

### ``map`` و ``filter``

تکرارکننده ``map`` یک تابع گرفته و آن را روی مقادیر در یک تکرارکننده اعمال می‌کند:


```python
# find the first 10 square numbers
square = lambda x: x ** 2
for val in map(square, range(10)):
    print(val, end=' ')
>>> 0 1 4 9 16 25 36 49 64 81 
```

تکرارکننده ``filter`` ظاهری مشابه دارد، با این تفاوت که فقط مقادیری را عبور می‌دهد که تابع فیلتر برای آن‌ها True ارزیابی شود:

```python
# find values up to 10 for which x % 2 is zero
is_even = lambda x: x % 2 == 0
for val in filter(is_even, range(10)):
    print(val, end=' ')


>>> 0 2 4 6 8 
```

توابع ``map`` و ``filter``، به همراه تابع ``reduce`` (که در ماژول ``functools`` پایتون قرار دارد)، از اجزای اساسی سبک *برنامه‌نویسی تابعی* هستند. اگرچه این سبک، شیوهٔ غالب برنامه‌نویسی در دنیای پایتون نیست، اما طرفداران پرحرارتی دارد (برای مثال، کتابخانه [pytoolz](https://toolz.readthedocs.org/en/latest/) را ببینید).

### تکرارکننده‌ها به عنوان آرگومان تابع

در بخش [``*args`` و ``**kwargs``: آرگومان‌های انعطاف‌پذیر] مشاهده کردیم که از ``*args`` و ``**kwargs`` برای ارسال دنباله‌ها و دیکشنری‌ها به توابع استفاده می‌شود.  
مشخص شده که سینتکس ``*args`` نه تنها با دنباله‌ها، بلکه با هر تکرارکننده‌ای کار می‌کند:

```python
print(*range(10))


>>> 0 1 2 3 4 5 6 7 8 9
```

بنابراین، برای مثال، می‌توانیم با هوشمندی عمل کرده و نمونه ``map`` قبلی را به شکل زیر فشرده کنیم:

```python
print(*map(lambda x: x ** 2, range(10)))


>>> 0 1 4 9 16 25 36 49 64 81
```

با استفاده از این ترفند می‌توانیم به پرسش همیشگی که در فروم‌های یادگیری پایتون مطرح می‌شود پاسخ دهیم: چرا تابع ``unzip()`` که برعکس ``zip()`` عمل کند وجود ندارد؟

اگر برای مدتی در یک فضای تاریک به آن فکر کنید، ممکن است متوجه شوید که برعکس ``zip()`` در واقع... خود ``zip()`` است! نکته کلیدی این است که ``zip()`` می‌تواند هر تعداد تکرارکننده یا دنباله را با هم ترکیب کند. مشاهده کنید:

```python
L1 = (1, 2, 3, 4)
L2 = ('a', 'b', 'c', 'd')
```

```python
z = zip(L1, L2)
print(*z)


>>> (1, 'a') (2, 'b') (3, 'c') (4, 'd')
```

```python
z = zip(L1, L2)
new_L1, new_L2 = zip(*z)
print(new_L1, new_L2)


>>> (1, 2, 3, 4) ('a', 'b', 'c', 'd')
```

مدتی در این باره تأمل کنید. اگر درک کنید که چرا این روش کار می‌کند، در مسیر فهم تکرارکننده‌های پایتون پیشرفت چشمگیری کرده‌اید!

## تکرارکننده‌های تخصصی: ``itertools``

ما قبلاً نگاهی اجمالی به تکرارکننده بی‌نهایت ``range`` یعنی ``itertools.count`` داشتیم.  
ماژول ``itertools`` شامل مجموعه‌ای کامل از تکرارکننده‌های مفید است؛ ارزش دارد که زمان بگذارید و ماژول را برای کشف قابلیت‌های موجود بررسی کنید.  

به عنوان مثال، تابع ``itertools.permutations`` را در نظر بگیرید که روی تمام جایگشت‌های یک دنباله تکرار می‌کند:

```python
from itertools import permutations
p = permutations(range(3))
print(*p)


>>> (0, 1, 2) (0, 2, 1) (1, 0, 2) (1, 2, 0) (2, 0, 1) (2, 1, 0)
```

به طور مشابه، تابع ``itertools.combinations`` روی تمام ترکیب‌های منحصر به فرد ``N`` مقدار درون یک لیست تکرار می‌کند:

```python
from itertools import combinations
c = combinations(range(4), 2)
print(*c)

>>> (0, 1) (0, 2) (0, 3) (1, 2) (1, 3) (2, 3)
```

تابع مرتبط دیگر، تکرارکننده ``product`` است که روی تمام مجموعه‌های زوج‌های بین دو یا چند تکرارپذیر تکرار می‌کند:

```python
from itertools import product
p = product('ab', range(3))
print(*p)

>>> ('a', 0) ('a', 1) ('a', 2) ('b', 0) ('b', 1) ('b', 2)
```
تکرارکننده‌های مفید بسیار دیگری در ``itertools`` وجود دارند: لیست کامل به همراه برخی مثال‌ها در [مستندات آنلاین پایتون](https://docs.python.org/3.5/library/itertools.html) قابل مشاهده است.

