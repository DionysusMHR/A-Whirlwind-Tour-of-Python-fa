# انواع داده داخلی: مقادیر ساده

هنگام بحث در مورد متغیرها و آبجکت‌های پایتون، به این نکته اشاره کردیم که تمام آبجکت‌ها دارای اطلاعات **type** هستند. در اینجا به طور خلاصه انواع داده ساده و داخلی پایتون را مرور خواهیم کرد.

ما از عبارت «انواع ساده» برای تقابل با چندین **type مرکب** استفاده می‌کنیم که در بخش بعدی مورد بحث قرار خواهند گرفت.

انواع ساده پایتون در جدول زیر خلاصه شده‌اند:

<center>**انواع Scalar در پایتون**</center>

| Type        | Example        | Description                                                                 |
|-------------|----------------|-----------------------------------------------------------------------------|
| ``int``     | ``x = 1``      | اعداد صحیح                                                                  |
| ``float``   | ``x = 1.0``    | اعداد اعشاری (یعنی اعداد حقیقی)                                             |
| ``complex`` | ``x = 1 + 2j`` | اعداد مختلط (یعنی اعداد دارای بخش حقیقی و موهومی)                          |
| ``bool``    | ``x = True``   | Boolean: مقادیر True/False                                                  |
| ``str``     | ``x = 'abc'``  | String: کاراکترها یا متن                                                    |
| ``NoneType``| ``x = None``   | آبجکت ویژه که نشان‌دهنده مقادیر null است                                    |

به طور خلاصه هر یک از این موارد را بررسی خواهیم کرد.


## Integers (اعداد صحیح)

اساسی‌ترین نوع عددی، integer یا عدد صحیح است.
هر عددی که بدون نقطه اعشار باشد، یک integer محسوب می‌شود:

```python
x = 1
type(x)

>>> int
```

**Integers** در پایتون در واقع بسیار پیشرفته‌تر از integers در زبان‌هایی مثل `C` هستند.

**Integers** در C دارای دقت ثابت (**fixed-precision**) هستند و معمولاً پس از رسیدن به یک مقدار خاص (اغلب حول و حوش $2^{31}$ یا $2^{63}$، بسته به سیستم شما) **overflow** می‌کنند.

**Integers** در پایتون دارای دقت متغیر (**variable-precision**) هستند، بنابراین می‌توانید محاسباتی را انجام دهید که در زبان‌های دیگر باعث **overflow** می‌شد:

```python
2 ** 200

>>> 1606938044258990275541962092341162602522202993782792835301376
```

یک قابلیت کاربردی دیگر integers در پایتون این است که به طور پیش‌فرض، عملگر تقسیم (`/`)، نتیجه را به نوع **float** ارتقا می‌دهد (**up-cast** می‌کند):

```python
5 / 2

>>> 2.5
```

توجه داشته باشید که این **upcasting** یک ویژگی از پایتون ۳ است. در پایتون ۲، مانند بسیاری از زبان‌های **statically-typed** مثل C، تقسیم اعداد صحیح، بخش اعشاری را حذف می‌کرد و همیشه یک integer برمی‌گرداند:

```python
# رفتار Python 2
>>> 5 / 2
2
```

برای دستیابی به این رفتار در پایتون ۳، می‌توانید از عملگر **floor-division** استفاده کنید:

```python
5 // 2

>>> 2
```

در نهایت توجه داشته باشید که هرچند پایتون *۲.x* همزمان دارای یک **type** به نام `int` و یک **type** به نام `long` بود، اما پایتون ۳ رفتار این دو را در یک **type** واحد به نام `int` ترکیب کرده است.

## Floating-Point Numbers (اعداد اعشاری)

نوع **float** می‌تواند اعداد کسری را ذخیره کند.
این اعداد را می‌توان هم با نماد دهیی استاندارد و هم با نماد نمایی (**exponential notation**) تعریف کرد:

```python
x = 0.000005
y = 5e-6
print(x == y)

>>> True
```

```python
x = 1400000.00
y = 1.4e6
print(x == y)

>>> True
```

در نماد نمایی، `e` یا `E` را می‌توان به عنوان «... ضرب در ده به توان ...» خواند،
بنابراین `1.4e6` به عنوان $~1.4 \times 10^6$ تفسیر می‌شود.

می‌توان یک integer را به صورت صریح با استفاده از **constructor**ی `float` به یک float تبدیل کرد:

```python
float(1)

>>> 1.0
```

### نکته جانبی: دقت اعداد اعشاری

یک نکته مهم در مورد محاسبات **floating-point** این است که دقت آن محدود است، که این می‌تواند باعث ناپایداری در تست برابری (**equality tests**) شود. برای مثال:

```python
0.1 + 0.2 == 0.3

>>> False
```

چرا اینطور است؟ مشخص شده که این رفتار مختص پایتون نیست، بلکه به دلیل فرمت **fixed-precision** ذخیره‌سازی اعداد **floating-point** در مبنای دو است که توسط اکثر پلتفرم‌های محاسبات علمی استفاده می‌شود.

تمام زبان‌های برنامه‌نویسی که از اعداد اعشاری استفاده می‌کنند، آن‌ها را در تعداد ثابتی از **bit**ها ذخیره می‌کنند و این باعث می‌شود برخی از اعداد فقط به صورت تقریبی نمایش داده شوند.

می‌توانیم این موضوع را با چاپ کردن سه مقدار با دقت بالا مشاهده کنیم:

```python
print("0.1 = {0:.17f}".format(0.1))
print("0.2 = {0:.17f}".format(0.2))
print("0.3 = {0:.17f}".format(0.3))

>>> 0.1 = 0.10000000000000001
    0.2 = 0.20000000000000001
    0.3 = 0.29999999999999999
```

ما عادت کرده‌ایم که اعداد را در نماد ده‌دهی (**decimal** - مبنای ۱۰) در نظر بگیریم، به طوری که هر کسر باید به صورت مجموعی از توان‌های ۱۰ بیان شود:
$$
1 /8 = 1\cdot 10^{-1} + 2\cdot 10^{-2} + 5\cdot 10^{-3}
$$
در نمایش آشنای مبنای ۱۰، این را با عبارت اعشاری شناخته شده‌ی $0.125$ نشان می‌دهیم.

کامپیوترها معمولاً مقادیر را در نماد دودویی (**binary notation**) ذخیره می‌کنند، بنابراین هر عدد به صورت مجموعی از توان‌های ۲ بیان می‌شود:
$$
1/8 = 0\cdot 2^{-1} + 0\cdot 2^{-2} + 1\cdot 2^{-3}
$$
در نمایش مبنای ۲، می‌توانیم این را به صورت $0.001_2$ بنویسیم، که زیرنویس ۲ نشان‌دهنده نماد دودویی است.
مقدار $0.125 = 0.001_2$ اتفاقاً یکی از اعدادی است که هم نماد دودویی و هم نماد ده‌دهی می‌توانند آن را با تعداد رقم‌های محدود نمایش دهند.

در نمایش شناخته شده اعداد در مبنای ۱۰، احتمالاً با اعدادی آشنا هستید که نمی‌توان آن‌ها را در تعداد رقم‌های محدود بیان کرد.
برای مثال، تقسیم $۱$ بر $۳$ در نماد استاندارد ده‌دهی به این صورت است:
$$
1 / 3 = 0.333333333\cdots
$$
۳ها تا بی‌نهایت ادامه دارند: یعنی برای نمایش واقعی این خارج‌قسمت، تعداد رقم‌های مورد نیاز بی‌نهایت است!

به طور مشابه، اعدادی وجود دارند که نمایش دودویی آن‌ها به تعداد بی‌نهایت رقم نیاز دارد.
برای مثال:
$$
1 / 10 = 0.00011001100110011\cdots_2
$$
همان‌طور که نماد ده‌دهی به تعداد بی‌نهایت رقم برای نمایش دقیق $1/3$ نیاز دارد، نماد دودویی نیز برای نمایش $1/10$ به تعداد بی‌نهایت رقم نیاز دارد.
پایتون به صورت داخلی این نمایش‌ها را در اکثر سیستم‌ها پس از ۵۲ **bit** بعد از اولین **bit** غیرصفر، قطع می‌کند (**truncate** می‌کند).

این خطای گردکردن (**rounding error**) برای مقادیر اعشاری، یک شر ضروری در کار با اعداد **floating-point** است.
بهترین راه برای مدیریت آن، این است که همیشه به خاطر داشته باشید که محاسبات اعشاری تقریبی هستند و هرگز به تست برابری دقیق (**exact equality tests**) با مقادیر **floating-point** اتکا نکنید.

## Complex Numbers (اعداد مختلط)

اعداد مختلط، اعدادی با بخش حقیقی و موهومی (از نوع **floating-point**) هستند.
ما پیش از این با integers و اعداد حقیقی آشنا شده‌ایم؛ می‌توانیم از این‌ها برای ساخت یک عدد مختلط استفاده کنیم:

```python
complex(1, 2)

>>> (1+2j)
```
به طور جایگزین، می‌توانیم از پسوند "`j`" در عبارات برای نشان دادن بخش موهومی استفاده کنیم:

```python
1 + 2j

>>> (1+2j)
```

اعداد مختلط دارای ویژگی‌ها و متدهای جالب توجهی هستند که در ادامه به طور خلاصه به آن‌ها می‌پردازیم:

```python
c = 3 + 4j
```

```python
c.real  # real part

>>> 3.0
```

```python
c.imag  # imaginary part

>>> 4.0
```

```python
c.conjugate()  # complex conjugate

>>> (3-4j)
```

```python
abs(c)  # magnitude, i.e. sqrt(c.real ** 2 + c.imag ** 2)

>>> 5.0
```

## String Type (نوع رشته‌ای)

**String**ها در پایتون با استفاده از نقل قول تکی یا دوتایی ساخته می‌شوند:

```python
message = "what do you like?"
response = 'spam'
```

پایتون دارای توابع و متدهای بسیار کاربردی برای **string**ها است؛ در ادامه به چند مورد از آن‌ها اشاره می‌کنیم:

```python
# length of string
len(response)

>>> 4
```

```python
# Make upper-case. See also str.lower()
response.upper()

>>> 'SPAM'
```

```python
# Capitalize. See also str.title()
message.capitalize()

>>> 'What do you like?'
```

```python
# concatenation with +
message + response

>>> 'what do you like?spam'
```

```python
# multiplication is multiple concatenation
5 * response

>>> 'spamspamspamspamspam'
```

```python
# Access individual characters (zero-based indexing)
message[0]

>>> 'w'
```

برای بحث بیشتر در مورد **indexing** در پایتون، به بخش ["لیست‌ها"](06-Built-in-Data-Structures.ipynb#Lists) مراجعه کنید.

## None Type

پایتون شامل یک **type** ویژه به نام `NoneType` است که تنها یک مقدار ممکن دارد: `None`. برای مثال:

```python
type(None)

>>> NoneType
```

شما `None` را در بسیاری از جاها خواهید دید، اما شاید رایج‌ترین کاربرد آن به عنوان مقدار بازگشتی پیش‌فرض یک تابع باشد.

برای مثال، تابع `print()` در پایتون ۳ چیزی **return** نمی‌کند، اما همچنان می‌توانیم مقدار آن را دریافت کنیم:

```python
return_value = print('abc')

>>> abc
```

```python
print(return_value)

>>> None
```

به همین ترتیب، هر تابعی در پایتون که بدون مقدار بازگشتی باشد، در واقع `None` را **return** می‌کند.


## Boolean Type

نوع **Boolean** یک نوع ساده با دو مقدار ممکن است: `True` و `False`. این نوع توسط عملگرهای مقایسه‌ای که پیش‌تر讨论 شدند، بازگردانده می‌شود:

```python
result = (4 < 5)
result

>>> True
```

```python
type(result)

>>> bool
```

به خاطر داشته باشید که مقادیر Boolean به حروف بزرگ و کوچک حساس هستند: برخلاف برخی زبان‌های دیگر، `True` و `False` باید با حرف بزرگ نوشته شوند!

```python
print(True, False)

>>> True False
```

aمقادیر Boolean را می‌توان با استفاده از **constructor** آبجکت `bool()` نیز ساخت: مقادیر هر نوع دیگری را می‌توان با استفاده از قوانین قابل پیش‌بینی به Boolean تبدیل کرد.


```python
bool(2014)

>>> True
```

```python
bool(0)

>>> False
```

```python
bool(3.1415)

>>> True
```

تبدیل Boolean از `None` همیشه `False` است:

```python
bool(None)

>>> False
```

برای رشته‌ها، `bool(s)` برای رشته‌های خالی `False` و برای بقیه `True` است:

```python
bool("")

>>> False
```

```python
bool("abc")

>>> True
```

برای دنباله‌ها (**sequences**) که در بخش بعدی با آن‌ها آشنا خواهیم شد، نمایش Boolean برای دنباله‌های خالی `False` و برای هر دنباله دیگری `True` خواهد بود.

```python
bool([1, 2, 3])

>>> True
```

```python
bool([])

>>> False
```
