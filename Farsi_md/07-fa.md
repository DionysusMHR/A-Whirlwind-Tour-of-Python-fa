# کنترل جریان اجرا (Control Flow)

**Control Flow** یا کنترل جریان اجرا، جایی است که برنامه‌نویسی واقعاً معنای عملی پیدا می‌کند. بدون آن، یک برنامه صرفاً لیستی از دستورات است که به صورت متوالی اجرا می‌شوند. با کنترل جریان، شما می‌توانید بلوک‌های خاصی از کد را به صورت شرطی و/یا تکراری اجرا کنید: این بلوک‌های سازنده پایه می‌توانند ترکیب شده تا برنامه‌هایی به طور شگفت‌انگیزی پیچیده ایجاد کنند!

در اینجا به **دستورات شرطی** (شامل `if`، `elif` و `else`) و **دستورات حلقه** (شامل `for` و `while` و همراهان آنها یعنی `break`، `continue` و `pass`) خواهیم پرداخت.

## دستورات شرطی: `if`-`elif`-`else`:

دستورات شرطی که اغلب به عنوان دستورات *if-then* شناخته می‌شوند، به برنامه‌نویس اجازه می‌دهند قطعات خاصی از کد را بسته به برخی شرایط Boolean اجرا کند.

یک مثال پایه از دستور شرطی در پایتون به این صورت است:

```python
x = -15

if x == 0:
    print(x, "is zero")
elif x > 0:
    print(x, "is positive")
elif x < 0:
    print(x, "is negative")
else:
    print(x, "is unlike anything I've ever seen...")


>>> -15 is negative
```

به ویژه به استفاده از دونقطه (`:`) و فاصله سفید (**whitespace**) برای مشخص کردن بلوک‌های جداگانه کد توجه کنید.

پایتون از `if` و `else` که اغلب در زبان‌های دیگر استفاده می‌شوند، بهره می‌برد؛ اما کلمه کلیدی منحصر به فرد‌تر آن `elif` است که مخفف "else if" می‌باشد.
در این clauseهای شرطی، بلوک‌های `elif` و `else` اختیاری هستند؛ علاوه بر این، می‌توانید به تعداد دلخواه از دستورات `elif` استفاده کنید.

## حلقه‌های `for`

حلقه‌ها در پایتون راهی برای اجرای مکرر یک دستور کد هستند.
برای مثال، اگر بخواهیم هر یک از آیتم‌های موجود در یک لیست را چاپ کنیم، می‌توانیم از یک حلقه `for` استفاده کنیم:

```python
for N in [2, 3, 5, 7]:
    print(N, end=' ') # print all on same line

>>> 2 3 5 7 
```

به سادگی حلقه `for` توجه کنید: متغیری که می‌خواهیم استفاده کنیم را مشخص می‌کنیم، دنباله‌ای که می‌خواهیم روی آن حلقه بزنیم را تعیین می‌کنیم و از عملگر `in` برای ارتباط آن‌ها به شیوه‌ای قابل درک و خوانا استفاده می‌کنیم.

به طور دقیق‌تر، آبجکت سمت راست `in` می‌تواند هر **iterator** پایتون باشد. یک **iterator** را می‌توان به عنوان یک دنباله تعمیم یافته در نظر گرفت که در بخش [Iterators](10-Iterators.ipynb) در مورد آن‌ها بحث خواهیم کرد.

برای مثال، یکی از پرکاربردترین **iterator**ها در پایتون، آبجکت `range` است که یک دنباله از اعداد تولید می‌کند:

```python
for i in range(10):
    print(i, end=' ')

>>> 0 1 2 3 4 5 6 7 8 9 
```

توجه کنید که به طور پیش‌فرض، `range` از صفر شروع می‌شود و طبق قرارداد، عدد انتهایی در خروجی شامل نمی‌شود.

آبجکت‌های `range` می‌توانند مقادیر پیچیده‌تری نیز داشته باشند:

```python
# range from 5 to 10
list(range(5, 10))

>>> [5, 6, 7, 8, 9]
```

```python
# range from 0 to 10 by 2
list(range(0, 10, 2))

>>> [0, 2, 4, 6, 8]
```

ممکن است متوجه شده باشید که معنای آرگومان‌های `range` بسیار شبیه به syntax برش زنی (**slicing**) است که در بخش [لیست‌ها](06-Built-in-Data-Structures.ipynb#Lists) پوشش دادیم.

توجه داشته باشید که رفتار `range()` یکی از تفاوت‌های بین پایتون ۲ و پایتون ۳ است: در پایتون ۲، `range()` یک لیست تولید می‌کند، در حالی که در پایتون ۳، `range()` یک آبجکت قابل تکرار (**iterable**) تولید می‌کند.

## حلقه‌های `while`

نوع دیگر حلقه در پایتون، حلقه `while` است که تا زمانی که یک شرط برقرار باشد، به تکرار ادامه می‌دهد:

```python
i = 0
while i < 10:
    print(i, end=' ')
    i += 1

>>> 0 1 2 3 4 5 6 7 8 9 
```

آرگومان حلقه `while` به عنوان یک عبارت Boolean ارزیابی می‌شود و حلقه تا زمانی که عبارت به `False` ارزیابی شود، اجرا می‌گردد.

## `break` و `continue`: تنظیم دقیق حلقه‌های شما

دو دستور مفید وجود دارند که می‌توان درون حلقه‌ها برای تنظیم دقیق نحوه اجرای آن‌ها استفاده کرد:

- دستور `break` به طور کامل از حلقه خارج می‌شود
- دستور `continue` باقی‌مانده حلقه جاری را نادیده گرفته و به تکرار بعدی می‌رود

این دستورات را می‌توان در هر دو حلقه `for` و `while` استفاده کرد.

در اینجا نمونه‌ای از استفاده از `continue` برای چاپ یک رشته از اعداد فرد آورده شده است.
در این مورد، نتیجه را می‌توان به equally خوبی با یک دستور `if-else` نیز به دست آورد، اما گاهی اوقات دستور `continue` می‌تواند راهی راحت‌تر برای بیان ایده مورد نظر شما باشد:

```python
for n in range(20):
    # if the remainder of n / 2 is 0, skip the rest of the loop
    if n % 2 == 0:
        continue
    print(n, end=' ')

>>> 1 3 5 7 9 11 13 15 17 19 
```

در اینجا نمونه‌ای از استفاده از دستور `break` برای یک کار کمتر پیش‌پاافتاده آورده شده است.
این حلقه، یک لیست را با تمام اعداد فیبوناچی تا یک مقدار مشخص پر می‌کند:

```python
a, b = 0, 1
amax = 100
L = []

while True:
    (a, b) = (b, a + b)
    if a > amax:
        break
    L.append(a)

print(L)

>>> [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
```

توجه کنید که از یک حلقه `while True` استفاده کرده‌ایم که برای همیشه ادامه خواهد یافت، مگر اینکه یک دستور break داشته باشیم!

## حلقه‌ها با بلوک `else`

یک الگوی کمتر استفاده شده در پایتون، دستور `else` به عنوان بخشی از حلقه `for` یا `while` است.
ما پیش‌تر در مورد بلوک `else` بحث کردیم: این بلوک در صورتی اجرا می‌شود که تمام دستورات `if` و `elif` به `False` ارزیابی شوند.
`else` مربوط به حلقه شاید یکی از گیج‌کننده‌ترین نام‌گذاری‌ها در پایتون باشد؛ من ترجیح می‌دهم آن را به عنوان یک دستور `nobreak` در نظر بگیرم: یعنی بلوک `else` فقط در صورتی اجرا می‌شود که حلقه به صورت طبیعی پایان یابد، بدون اینکه با دستور `break` مواجه شود.

به عنوان مثالی از کاربرد این قابلیت، پیاده‌سازی (غیربهینه) *الگوریتم غربال اراتوستن* را در نظر بگیرید که یک الگوریتم شناخته شده برای یافتن اعداد اول است:

```python
L = []
nmax = 30

for n in range(2, nmax):
    for factor in L:
        if n % factor == 0:
            break
    else: # no break
        L.append(n)
print(L)

>>> [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
```

بلوک `else` فقط در صورتی اجرا می‌شود که هیچ یک از مقسوم‌علیه‌ها، عدد داده شده را تقسیم نکنند.
دستور `else` به همین شکل با حلقه `while` نیز کار می‌کند.
