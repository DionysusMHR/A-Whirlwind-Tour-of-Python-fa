# کار با رشته‌ها و عبارات باقاعده

یکی از حوزه‌هایی که پایتون واقعاً در آن می‌درخشد، کار با رشته‌ها است.  
این بخش به برخی از متدهای داخلی پایتون برای رشته‌ها و عملیات قالب‌بندی می‌پردازد و سپس راهنمایی سریع در مورد مبحث بسیار مفید *عبارات باقاعده* ارائه می‌دهد.  
این الگوهای کار با رشته‌ها اغلب در زمینه علم داده کاربرد دارند و یکی از مزیت‌های بزرگ پایتون در این حوزه محسوب می‌شوند.

رشته‌ها در پایتون را می‌توان با استفاده از نقل‌قول‌های تکی یا دوتایی تعریف کرد (از نظر عملکردی معادل هستند):

```python
x = 'a string'
y = "a string"
x == y

>>> True
```
علاوه بر این، امکان تعریف رشته‌های چندخطی با استفاده از سینتکس سه‌قلوتی وجود دارد:

```python
multiline = """
one
two
three
"""
```

با این مقدمه، اجازه دهید نگاهی سریع به برخی از ابزارهای manipulate رشته‌ها در پایتون بیندازیم.

## کاربرد ساده رشته‌ها در پایتون

برای دستکاری پایه رشته‌ها، متدهای داخلی رشته‌های پایتون می‌توانند بسیار کاربردی باشند. اگر پیشینه کار با C یا زبان‌های سطح پایین دیگر را دارید، به احتمال زیاد سادگی متدهای پایتون را بسیار دلنشین خواهید یافت. ما پیش‌تر نوع داده رشته و برخی از این متدها را معرفی کردیم؛ در اینجا کمی عمیق‌تر به آنها می‌پردازیم.

### قالب‌بندی رشته‌ها: تنظیم حروف

پایتون تنظیم حالت حروف یک رشته را بسیار آسان کرده است. در اینجا به متدهای ``upper()``، ``lower()``، ``capitalize()``، ``title()`` و ``swapcase()`` نگاهی می‌اندازیم و از رشته زیر به عنوان مثال استفاده می‌کنیم:

```python
fox = "tHe qUICk bROWn fOx."
```

برای تبدیل کل رشته به حروف بزرگ یا کوچک، به ترتیب می‌توانید از متدهای ``upper()`` یا ``lower()`` استفاده کنید:


```python
fox.upper()

>>> 'THE QUICK BROWN FOX.'
```

```python
fox.lower()

>>> 'the quick brown fox.'
```

یک نیاز رایج در قالب‌بندی، بزرگ کردن فقط حرف اول هر کلمه یا احتمالاً حرف اول هر جمله است. این کار را می‌توان با متدهای ``title()`` و ``capitalize()`` انجام داد:


```python
fox.title()

>>> 'The Quick Brown Fox.'
```

```python
fox.capitalize()

>>> 'The quick brown fox.'
```

می‌توان حالات حروف را با استفاده از متد ``swapcase()`` معکوس کرد:

```python
fox.swapcase()

>>> 'ThE QuicK BrowN FoX.'
```

### قالب‌بندی رشته‌ها: افزودن و حذف فاصله‌ها

نیاز رایج دیگر، حذف فاصله‌ها (یا کاراکترهای دیگر) از ابتدا یا انتهای رشته است.  
روش اصلی حذف کاراکترها، متد ``strip()`` است که فاصله‌های سفید را از ابتدا و انتهای خط حذف می‌کند:

```python
line = '         this is the content         '
line.strip()

>>> 'this is the content'
```

برای حذف فاصله فقط از سمت راست یا چپ، به ترتیب از ``rstrip()`` یا ``lstrip()`` استفاده کنید:

```python
line.rstrip()

>>> '         this is the content'
```

```python
line.lstrip()

>>> 'this is the content         '
```

برای حذف کاراکترهای غیر از فاصله، می‌توانید کاراکتر مورد نظر را به متد ``strip()`` ارسال کنید:

```python
num = "000000000000435"
num.strip('0')

>>> '435'         '
```

عملکرد معکوس این عملیات، یعنی افزودن فاصله یا کاراکترهای دیگر، با استفاده از متدهای 
`center()`
، 
`ljust()`
 و 
`rjust()`
 قابل انجام است.

برای مثال، میتوانیم از متد 
`center()`
 استفاده کنیم تا یک رشته را در میان تعداد مشخصی فاصله، وسط‌چین کنیم:

 ```python
line = "this is the content"
line.center(30)

>>> '     this is the content      '        
```

به طور مشابه، متدهای 
`ljust()`
 و 
`rjust()`
 رشته را به ترتیب در سمت چپ یا راست فضاهای با طول مشخص، تراز می‌کنند:

 ```python
line.ljust(30)

>>> 'this is the content           '
```


 ```python
line.rjust(30)

>>> '           this is the content'
```

همه این متدها علاوه بر این، هر کاراکتر دیگری را نیز به عنوان پرکننده فضا می‌پذیرند.  
برای مثال:

 ```python
'435'.rjust(10, '0')

>>> '0000000435'
```

با توجه به اینکه پر کردن با صفر نیاز رایجی است، پایتون متد 
`zfill()`
 را نیز ارائه می‌دهد که یک متد ویژه برای افزودن صفر به سمت چپ رشته است:

  ```python
'435'.zfill(10)

>>> '0000000435'
```

### یافتن و جایگزینی زیررشته‌ها

اگر می‌خواهید رخدادهای یک کاراکتر خاص را در یک رشته پیدا کنید، متدهای 
`find()`
/
`rfind()`
، 
`index()`
/
`rindex()`
 و 
`replace()`
 بهترین متدهای داخلی برای این کار هستند.

`find()`
 و 
`index()`
 بسیار شبیه به هم هستند؛ هر دو برای جستجوی اولین رخداد یک کاراکتر یا زیررشته درون رشته استفاده می‌شوند و اندیس آن زیررشته را برمی‌گردانند:

 ```python
line = 'the quick brown fox jumped over a lazy dog'
line.find('fox')

>>> 16
```

 ```python
line.index('fox')

>>> 16
```

تنها تفاوت بین 
`find()`
 و 
`index()`
 در رفتار آن‌ها زمانی است که رشته جستجو پیدا نشود؛ 
`find()`
 مقدار 
`1-`
 را برمی‌گرداند، در حالی که 
`index()`
 یک خطای 
`ValueError`
 ایجاد می‌کند:

  ```python
line.find('bear')

>>> -1
```

 ```python
line.index('bear')

---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

<ipython-input-21-4cbe6ee9b0eb> in <module>()

----> 1 line.index('bear')



ValueError: substring not found
```

متدهای مرتبط 
`rfind()`
 و 
`rindex()`
 به طور مشابه عمل می‌کنند، با این تفاوت که آن‌ها اولین occurrence (رخداد) را از انتهای رشته به جای ابتدای آن جستجو می‌کنند:


```python
line.rfind('a')

>>> 35
```

برای بررسی وجود یک زیررشته در ابتدا یا انتهای رشته، پایتون متدهای 
`startswith()`
 و 
`endswith()`
 را ارائه می‌دهد:

 ```python
line.endswith('dog')

>>> True
```
 ```python
line.startswith('fox')

>>> False
```

برای جایگزینی یک زیررشته با رشته‌ی جدید، می‌توانید از متد 
`replace()`
 استفاده کنید.  
در این مثال، بیایید 
`'brown'`
 را با 
`'red'`
 جایگزین کنیم:


 ```python
line.replace('brown', 'red')

>>> 'the quick red fox jumped over a lazy dog'
```

متد 
`replace()`
 یک رشته جدید برمی‌گرداند و تمامی occurrenceها (رخدادهای) ورودی را جایگزین می‌کند:

 ```python
line.replace('o', '--')

>>> 'the quick br--wn f--x jumped --ver a lazy d--g'
```

برای دستیابی به یک رویکرد انعطاف‌پذیرتر نسبت به این قابلیت 
`replace()`
، به بخش بحث در مورد عبارات باقاعده در [همسان‌سازی الگوهای انعطاف‌پذیر با عبارات باقاعده](#Flexible-Pattern-Matching-with-Regular-Expressions) مراجعه کنید.

### تقسیم‌بندی و جدا کردن رشته‌ها

اگر می‌خواهید یک زیررشته را پیدا کنید و *سپس* رشته را بر اساس موقعیت آن تقسیم کنید، متدهای 
`partition()`
 و/یا 
`split()`
 همان چیزی هستند که به دنبال آن هستید.  
هر دو دنباله‌ای از زیررشته‌ها را بازمی‌گردانند.

متد 
`partition()`
 یک تاپل سه‌عنصری بازمی‌گرداند: زیررشته قبل از اولین occurrence نقطه تقسیم، خود نقطه تقسیم، و زیررشته بعد از آن:

  ```python
line.partition('fox')

>>> ('the quick brown ', 'fox', ' jumped over a lazy dog')
```

متد 
`rpartition()`
 مشابه است، اما از سمت راست رشته جستجو می‌کند.

متد 
`split()`
 احتمالاً کاربردی‌تر است؛ این متد *همه* occurrenceهای نقطه تقسیم را پیدا کرده و زیررشته‌های بین آن‌ها را برمی‌گرداند.
پیش‌فرض آن تقسیم بر اساس هر گونه فضای خالی (whitespace) است که لیستی از کلمات جداگانه در یک رشته را بازمی‌گرداند:

 ```python
line.split()


>>> ['the', 'quick', 'brown', 'fox', 'jumped', 'over', 'a', 'lazy', 'dog']
```

متد مرتبط دیگر 
`splitlines()`
 است که بر اساس کاراکترهای newline (نویسه‌های جدید خط) تقسیم‌بندی می‌کند.  
بیایید این کار را با یک هایکو انجام دهیم که عموماً به ماتسوئو باشو، شاعر سده هفدهم نسبت داده می‌شود:

 ```python
haiku = """matsushima-ya
aah matsushima-ya
matsushima-ya"""

haiku.splitlines()


>>> ['matsushima-ya', 'aah matsushima-ya', 'matsushima-ya']
```
توجه داشته باشید که اگر بخواهید عمل 
`split()`
 را لغو کنید، می‌توانید از متد 
`join()`
 استفاده کنید که یک رشته را از یک نقطه اتصال و یک شیء قابل پیمایش (iterable) می‌سازد:

```python
'--'.join(['1', '2', '3'])


>>> '1--2--3'
```

یک الگوی رایج، استفاده از کاراکتر ویژه 
`"\n"`
 (نویسه جدید خط) برای پیوند دادن خطوطی است که قبلاً تقسیم شده‌اند و بازیابی ورودی اصلی است:

 ```python
print("\n".join(['matsushima-ya', 'aah matsushima-ya', 'matsushima-ya']))


>>> matsushima-ya
aah matsushima-ya
matsushima-ya
```

## قالب‌بندی رشته‌ها (Format Strings)

در روش‌های قبلی، یاد گرفتیم که چگونه مقادیر را از رشته‌ها استخراج کنیم و خود رشته‌ها را به فرمت‌های دلخواه تغییر دهیم.
کاربرد دیگر متدهای رشته‌ای، تغییر *بازنمایی‌های* رشته‌ای از مقادیر با انواع دیگر (داده‌ای) است.
البته که همیشه می‌توان بازنمایی رشته‌ای را با استفاده از تابع `str()` به دست آورد؛ برای مثال:

 ```python
pi = 3.14159
str(pi)


>>> '3.14159'
```

برای قالب‌بندی‌های پیچیده‌تر، ممکن است وسوسه شوید که از عملیات حسابی روی رشته‌ها استفاده کنید، همان‌طور که در [مفاهیم پایه‌ای پایتون: عملگرها](04-Semantics-Operators.ipynb) توضیح داده شد:

 ```python
"The value of pi is " + str(pi)


>>> 'The value of pi is 3.14159'
```

روش انعطاف‌پذیرتر برای این کار، استفاده از *رشته‌های قالب* (format strings) است. این رشته‌ها حاوی نشانگرهای ویژه‌ای (که با آکولاد مشخص می‌شوند) هستند و مقادیر قالب‌بندی شده درون آن‌ها قرار می‌گیرند.
در اینجا یک مثال پایه آورده شده است:


 ```python
"The value of pi is {}".format(pi)


>>> 'The value of pi is 3.14159'
```

درون نشانگر `{}` می‌توانید اطلاعاتی دربارهٔ *چیزی* که دقیقاً می‌خواهید در آنجا نمایش داده شود، قرار دهید.
اگر یک عدد وارد کنید، به ایندکس آرگومانی که باید وارد شود اشاره می‌کند:

 ```python
"""First letter: {0}. Last letter: {1}.""".format('A', 'Z')


>>> 'First letter: A. Last letter: Z.'
```

اگر یک رشته وارد کنید، به کلید هر آرگومان کلیدواژه‌ای اشاره خواهد کرد:

 ```python
"""First letter: {first}. Last letter: {last}.""".format(last='Z', first='A')


>>> 'First letter: A. Last letter: Z.'
```

در نهایت، برای ورودی‌های عددی می‌توانید کدهای فرمت را اضافه کنید که نحوه تبدیل مقدار به رشته را کنترل می‌کنند.
برای مثال، برای نمایش یک عدد به صورت ممیز شناور با سه رقم پس از ممیز، می‌توانید از روش زیر استفاده کنید:

```python
"pi = {0:.3f}".format(pi)

>>> 'pi = 3.142'
```

همان‌طور که پیش‌تر اشاره شد، عدد "`0`" در اینجا به ایندکس مقداری که باید قرار گیرد اشاره می‌کند.  
علامت "`:`" نشان‌دهنده این است که کدهای فرمت پس از آن می‌آیند.  
"`.3f`" دقت مورد نظر را مشخص می‌کند: سه رقم پس از نقطه اعشار، با فرمت ممیز شناور.  

این سبک مشخص‌سازی فرمت بسیار انعطاف‌پذیر است و مثال‌های ارائه‌شده در اینجا تنها بخش کوچکی از گزینه‌های موجود برای قالب‌بندی را پوشش می‌دهند.  
برای اطلاعات بیشتر در مورد نحو این رشته‌های فرمت، به بخش [Format Specification](https://docs.python.org/3/library/string.html#formatspec) در مستندات آنلاین پایتون مراجعه کنید.

## تطابق الگوی انعطاف‌پذیر با عبارات باقاعده (Regular Expressions)

متدهای نوع `str` در پایتون، مجموعه‌ای قدرتمند از ابزارها برای قالب‌بندی، تقسیم و دستکاری داده‌های رشته‌ای در اختیار شما قرار می‌دهند.  
اما ابزارهای حتی قدرتمندتری در ماژول *عبارات باقاعده* (regular expressions) داخلی پایتون موجود است.  
عبارات باقاعده یک موضوع بسیار گسترده است؛ کتاب‌های کاملی در این زمینه نوشته شده‌اند (از جمله کتاب [*Mastering Regular Expressions, 3rd Edition*](http://shop.oreilly.com/product/9780596528126.do) اثر Jeffrey E.F. Friedl)، بنابراین پرداختن به آن در تنها یک زیربخش کار دشواری است.  

هدف من در اینجا این است که به شما درکی از انواع مسائلی که می‌توان با استفاده از عبارات باقاعده حل کرد، و همچنین ایده‌ای پایه از نحوه استفاده از آن‌ها در پایتون بدهم.  
در بخش [منابع بیشتر برای یادگیری عبارات باقاعده](#Further-Resources-on-Regular-Expressions) برخی منابع برای یادگیری بیشتر را پیشنهاد خواهم داد.  

در اساس، عبارات باقاعده وسیله‌ای برای *تطابق الگوی انعطاف‌پذیر* در رشته‌ها هستند.  
اگر اغلب از خط فرمان استفاده می‌کنید، احتمالاً با این نوع تطابق انعطاف‌پذیر با کاراکتر "`*`" آشنا هستید که به عنوان یک کاراکتر جایگزین (wildcard) عمل می‌کند.  
برای مثال، می‌توانیم تمامی notebookهای آی‌پایتون (یعنی فایل‌های با پسوند *.ipynb*) که حاوی کلمه "Python" در نام فایل خود هستند را با استفاده از wildcard "`*`" برای تطابق با هر کاراکتری در میان آن‌ها فهرست کنیم:

```python
!ls *Python*.ipynb

>>> 01-How-to-Run-Python-Code.ipynb 02-Basic-Python-Syntax.ipynb
```

عبارات باقاعده این ایده «کاراکتر جایگزین» (wildcard) را به طیف گسترده‌ای از نحوهای انعطاف‌پذیر برای تطابق رشته تعمیم می‌دهند.  
رابط پایتون برای عبارات باقاعده در ماژول داخلی `re` قرار دارد. به عنوان یک مثال ساده، بیایید از آن برای تکرار عملکرد متد `split()` رشته استفاده کنیم:


```python
import re
regex = re.compile('\s+')
regex.split(line)

>>> ['the', 'quick', 'brown', 'fox', 'jumped', 'over', 'a', 'lazy', 'dog']
```

در اینجا ابتدا یک عبارت باقاعده را *کامپایل* کرده‌ایم، سپس از آن برای *تقسیم* یک رشته استفاده کرده‌ایم.  
درست مانند متد `split()` پایتون که لیستی از تمام زیررشته‌های بین فضاهای خالی را برمی‌گرداند، متد `split()` عبارات باقاعده نیز لیستی از تمام زیررشته‌های بین تطابق‌های الگوی ورودی را برمی‌گرداند.  

در این مورد، ورودی `"\s+"` است: "`\s`" یک کاراکتر ویژه است که با هر نویسه فضای خالی (فاصله، تب، خط جدید و غیره) مطابقت دارد، و "`+`" کاراکتری است که نشان‌دهنده *یک یا چند* مورد از نویسه قبل از خود است.  
بنابراین، عبارت باقاعده با هر زیررشته متشکل از یک یا چند فاصله مطابقت می‌کند.  

متد `split()` در اینجا اساساً یک روال کمکی است که بر اساس این رفتار *تطابق الگو* ساخته شده است. روش بنیادی‌تر، متد `match()` است که به شما می‌گوید آیا ابتدای یک رشته با الگو مطابقت دارد یا خیر:

```python
for s in ["     ", "abc  ", "  abc"]:
    if regex.match(s):
        print(repr(s), "matches")
    else:
        print(repr(s), "does not match")

>>> '     ' matches
'abc  ' does not match
'  abc' matches
```

مانند `split()`، روال‌های کمکی مشابهی برای یافتن اولین تطابق (مانند `str.index()` یا `str.find()`) یا برای یافتن و جایگزینی (مانند `str.replace()`) وجود دارد.  
ما دوباره از خط قبلی استفاده خواهیم کرد:

```python
line = 'the quick brown fox jumped over a lazy dog'
```

با این می‌توانیم ببینیم که متد `regex.search()` بسیار شبیه به `str.index()` یا `str.find()` عمل می‌کند:

```python
line.index('fox')

>>> 16
```

```python
regex = re.compile('fox')
match = regex.search(line)
match.start()

>>> 16
```
به طور مشابه، متد `regex.sub()` نیز بسیار شبیه به `str.replace()` عمل می‌کند:

```python
line.replace('fox', 'BEAR')

>>> 'the quick brown BEAR jumped over a lazy dog'
```

```python
regex.sub('BEAR', line)

>>> 'the quick brown BEAR jumped over a lazy dog'
```

با کمی تأمل، سایر عملیات بومی رشته‌ها نیز می‌توانند به صورت عبارات باقاعده بیان شوند.

### یک مثال پیچیده‌تر

اما ممکن است بپرسید، چرا باید از نحو پیچیده‌تر و طولانی‌تر عبارات باقاعده به جای متدهای ساده‌تر و شهودی رشته‌ها استفاده کرد؟  
مزیت این است که عبارات باقاعده *انعطاف بسیار بیشتری* ارائه می‌دهند.  

در اینجا یک مثال پیچیده‌تر را در نظر می‌گیریم: کار رایج تطابق آدرس‌های ایمیل.  
من با نوشتن یک عبارت باقاعده (تا حدودی پیچیده) شروع می‌کنم و سپس توضیح می‌دهم که چه اتفاقی در حال رخ دادن است.  
این هم از آن:

```python
email = re.compile('\w+@\w+\.[a-z]{3}')
```

با استفاده از این، اگر یک خط از یک سند به ما داده شود، می‌توانیم به سرعت مواردی که شبیه آدرس ایمیل هستند را استخراج کنیم


```python
text = "To email Guido, try guido@python.org or the older address guido@google.com."
email.findall(text)

>>> ['guido@python.org', 'guido@google.com']
```

(توجه کنید که این آدرس‌ها کاملاً ساختگی هستند؛ احتمالاً راه‌های بهتری برای تماس با گیدو [خالق پایتون] وجود دارد).

می‌توانیم عملیات بیشتری انجام دهیم، مانند جایگزینی این آدرس‌های ایمیل با رشته‌ای دیگر، مثلاً برای مخفی کردن آدرس‌ها در خروجی:

```python
email.sub('--@--.--', text)

>>> 'To email Guido, try --@--.-- or the older address --@--.--.'
```

در نهایت، توجه کنید که اگر واقعاً می‌خواهید *هر* آدرس ایمیلی را مطابقت دهید، عبارت باقاعده قبلی بسیار ساده‌تر از حد لازم است.  
برای مثال، این عبارت فقط آدرس‌های متشکل از کاراکترهای الفبایی-عددی را که به یکی از پسوندهای دامنه متداول ختم می‌شوند، مجاز می‌داند.  
بنابراین، برای مثال، نقطه استفاده شده در اینجا به این معنی است که فقط بخشی از آدرس را پیدا می‌کنیم:

```python
email.findall('barack.obama@whitehouse.gov')

>>> ['obama@whitehouse.gov']
```

این نشان می‌دهد که عبارات باقاعده چقدر می‌توانند بی‌رحمانه باشند اگر مراقب نباشید!  
اگر در اینترنت جستجو کنید، می‌توانید پیشنهاداتی برای عبارات باقاعده پیدا کنید که با *همه* ایمیل‌های معتبر مطابقت کنند، اما مراقب باشید: آن عبارات بسیار پیچیده‌تر از عبارت ساده‌ای هستند که در اینجا استفاده شد!

### مبانی نحو عبارات باقاعده (Regular Expression Syntax)

حوزه نحو عبارات باقاعده برای این بخش کوتاه بیش از حد گسترده است.  
با این حال، آشنایی نسبی با آن می‌تواند بسیار مفید باشد: در اینجا برخی از ساختارهای پایه را مرور می‌کنم و سپس چند منبع کامل‌تر را برای یادگیری بیشتر فهرست خواهم کرد.  
امیدوارم این مرور سریع، شما را قادر سازد تا از این منابع به طور موثر استفاده کنید.

#### رشته‌های ساده مستقیماً تطابق داده می‌شوند

اگر یک عبارت باقاعده بر اساس یک رشته ساده از کاراکترها یا ارقام بسازید، با همان رشته دقیق تطابق خواهد داد:

```python
regex = re.compile('ion')
regex.findall('Great Expectations')

>>> ['ion']
```

#### برخی کاراکترها دارای معانی ویژه هستند

در حالی که حروف یا اعداد ساده به صورت مستقیم تطابق داده می‌شوند، تعدادی کاراکتر وجود دارند که درون عبارات باقاعده معانی ویژه‌ای دارند. این کاراکترها عبارت‌اند از:
```
. ^ $ * + ? { } [ ] \ | ( )
```
به زودی معنای برخی از این موارد را بررسی خواهیم کرد.
در عین حال، باید بدانید که اگر می‌خواهید هر یک از این کاراکترها را مستقیماً تطابق دهید، می‌توانید آن‌ها را با استفاده از بک‌اسلش *escape* کنید:

```python
regex = re.compile(r'\$')
regex.findall("the cost is $20")

>>> ['$']
```

پیشوند `r` در `r'\$'` نشان‌دهنده یک *رشته خام* (raw string) است. در رشته‌های استاندارد پایتون، از بک‌اسلش برای نشان دادن کاراکترهای ویژه استفاده می‌شود.  
برای مثال، یک تب با `"\t"` نشان داده می‌شود:

```python
print('a\tb\tc')

>>> a	b	c
```

این گونه جایگزینی‌ها در یک رشته خام (raw string) انجام نمی‌شوند:

```python
print(r'a\tb\tc')

>>> a\tb\tc
```

به همین دلیل، هر زمان که از بک‌اسلش در یک عبارت باقاعده استفاده می‌کنید، استفاده از یک رشته خام (raw string) روش توصیه‌شده است.

#### کاراکترهای ویژه می‌توانند با گروه‌های کاراکتری تطابق پیدا کنند

همان‌طور که کاراکتر `"\"` در عبارات باقاعده می‌تواند کاراکترهای ویژه را escape کند و آن‌ها را به کاراکترهای معمولی تبدیل کند، می‌تواند به کاراکترهای معمولی نیز معانی ویژه بدهد.  
این کاراکترهای ویژه با گروه‌های مشخصی از کاراکترها تطابق پیدا می‌کنند و ما قبلاً آن‌ها را دیده‌ایم.  
در عبارت باقاعده آدرس ایمیل قبلی، از کاراکتر `"\w"` استفاده کردیم که یک نشانگر ویژه برای تطابق با *هر کاراکتر الفبایی-عددی* است. به طور مشابه، در مثال ساده `split()`، `"\s"` را نیز دیدیم که یک نشانگر ویژه برای *هر کاراکتر فضای خالی* است.  

با ترکیب این موارد، می‌توانیم یک عبارت باقاعده ایجاد کنیم که *هر دو حرف/عدد با فاصله خالی بین آن‌ها* را تطابق دهد:


```python
regex = re.compile(r'\w\s\w')
regex.findall('the fox is 9 years old')

>>> ['e f', 'x i', 's 9', 's o']
```

این مثال شروع به نشان دادن قدرت و انعطاف‌پذیری عبارات باقاعده می‌کند.

جدول زیر برخی از این کاراکترهای پرکاربرد را فهرست کرده است:

| کاراکتر   | توضیح                           | کاراکتر   | توضیح                               |
|-----------|---------------------------------|-----------|-------------------------------------|
| `"\d"`    | تطابق با هر رقم                | `"\D"`    | تطابق با هر غیررقم                 |
| `"\s"`    | تطابق با هر فاصله خالی         | `"\S"`    | تطابق با هر غیر فاصله خالی         |
| `"\w"`    | تطابق با هر کاراکتر الفبایی-عددی | `"\W"`    | تطابق با هر کاراکتر غیر الفبایی-عددی |

این لیست *کامل* یا توضیحات جامعی نیست؛ برای جزئیات بیشتر، به [مستندات نحو عبارات باقاعده پایتون](https://docs.python.org/3/library/re.html#re-syntax) مراجعه کنید.

#### براکت‌های مربعی با گروه‌های کاراکتری سفارشی تطابق پیدا می‌کنند

اگر گروه‌های کاراکتری داخلی به اندازه کافی برای نیازهای شما خاص نیستند، می‌توانید از براکت‌های مربعی برای مشخص کردن هر مجموعه کاراکتری که مدنظرتان است استفاده کنید.  
برای مثال، مورد زیر با هر حرف صدادار کوچک تطابق خواهد داد:

```python
regex = re.compile('[aeiou]')
regex.split('consequential')

>>> ['c', 'ns', 'q', '', 'nt', '', 'l']
```

به طور مشابه، می‌توانید از خط تیره برای مشخص کردن یک بازه استفاده کنید: برای مثال، `"[a-z]"` با هر حرف کوچک و `"[1-3]"` با هر یک از `"1"`، `"2"` یا `"3"` تطابق خواهد داد.  
به عنوان مثال، ممکن است نیاز باشد کدهای عددی خاصی را از یک سند استخراج کنید که شامل یک حرف بزرگ و به دنبال آن یک رقم هستند. می‌توانید این کار را به صورت زیر انجام دهید:



```python
regex = re.compile('[A-Z][0-9]')
regex.findall('1043879, G2, H6')

>>> ['G2', 'H6']
```

#### کاراکترهای جایگزین (Wildcards) با کاراکترهای تکراری تطابق پیدا می‌کنند

اگر می‌خواهید با رشته‌ای تطابق دهید که، مثلاً، سه کاراکتر الفبایی-عددی پشت سر هم دارد، می‌توانید به صورت `"\w\w\w"` بنویسید.  
از آنجا که این نیاز بسیار رایجی است، یک نحو خاص برای تطابق با تکرارها وجود دارد – استفاده از آکولاد با یک عدد:

```python
regex = re.compile(r'\w{3}')
regex.findall('The quick brown fox')

>>> ['The', 'qui', 'bro', 'fox']
```

همچنین نشانگرهایی برای تطابق با هر تعداد تکرار وجود دارند – برای مثال، کاراکتر `"+"` با *یک یا چند* تکرار از چیزی که قبل از آن می‌آید تطابق می‌یابد:

```python
regex = re.compile(r'\w+')
regex.findall('The quick brown fox')

>>> ['The', 'quick', 'brown', 'fox']
```

جدول زیر نشانگرهای تکرار موجود برای استفاده در عبارات باقاعده را نمایش می‌دهد:

| کاراکتر | توضیح | مثال |
|-----------|-------------|---------|
| `?` | تطابق با صفر یا یک تکرار از المان قبلی | `"ab?"` با `"a"` یا `"ab"` تطابق می‌یابد |
| `*` | تطابق با صفر یا چند تکرار از المان قبلی | `"ab*"` با `"a"`, `"ab"`, `"abb"`, `"abbb"` و ... تطابق می‌یابد |
| `+` | تطابق با یک یا چند تکرار از المان قبلی | `"ab+"` با `"ab"`, `"abb"`, `"abbb"` و ... تطابق می‌یابد اما با `"a"` خیر |
| `{n}` | تطابق با دقیقاً `n` تکرار از المان قبلی | `"ab{2}"` با `"abb"` تطابق می‌یابد |
| `{m,n}` | تطابق با بین `m` تا `n` تکرار از المان قبلی | `"ab{2,3}"` با `"abb"` یا `"abbb"` تطابق می‌یابد |

با در نظر گرفتن این مبانی پایه، اجازه دهید به تطابق‌دهنده آدرس ایمیل خود بازگردیم:

```python
email = re.compile(r'\w+@\w+\.[a-z]{3}')
```

اکنون میتوانیم معنای این عبارت را درک کنیم: میخواهیم یک یا چند نویسه الفباعددی (``"\w+"``) داشته باشیم که بعد از آن *علامت at* (``"@"``) بیاید، سپس دوباره یک یا چند نویسه الفباعددی (``"\w+"``) آمده و بعد از آن یک نقطه (``"\."`` — توجه کنید که نیاز به escape با بک‌اسلش دارد) قرار گیرد و در نهایت دقیقاً سه حرف کوچک بیاید.

اگر حالا بخواهیم این عبارت را طوری تغییر دهیم که آدرس ایمیل اوباما نیز با آن مطابقت کند، می‌توانیم این کار را با استفاده از نماد براکت انجام دهیم:

```python
email2 = re.compile(r'[\w.]+@\w+\.[a-z]{3}')
email2.findall('barack.obama@whitehouse.gov')

>>> ['barack.obama@whitehouse.gov']
```

ما ``"\w+"`` را به ``"[\w.]+"`` تغییر دادیم، بنابراین حالا هر نویسه الفباعددی *یا* یک نقطه را مطابقت خواهیم داد.

با این عبارت انعطاف‌پذیرتر، می‌توانیم طیف وسیع‌تری از آدرس‌های ایمیل را مطابقت دهیم (اگرچه هنوز هم همه را شامل نمی‌شود – آیا می‌توانید سایر کاستی‌های این عبارت را شناسایی کنید؟).

#### پرانتزها نشان‌دهنده *گروه‌هایی* برای استخراج هستند

برای عبارات منظم مرکب مانند تطبیق‌دهنده ایمیل ما، اغلب می‌خواهیم اجزای آن را به جای تطابق کامل استخراج کنیم. این کار را می‌توان با استفاده از پرانتز برای *گروه‌بندی* نتایج انجام داد:

```python
email3 = re.compile(r'([\w.]+)@(\w+)\.([a-z]{3})')
```

```python
text = "To email Guido, try guido@python.org or the older address guido@google.com."
email3.findall(text)

>>> [('guido', 'python', 'org'), ('guido', 'google', 'com')]
```

همان‌طور که می‌بینید، این گروه‌بندی در واقع یک لیست از زیراجزای آدرس ایمیل را استخراج می‌کند.

می‌توانیم یک قدم فراتر برویم و اجزای استخراج شده را با استفاده از سینتکس ``"(?P<name> )"`` *نام‌گذاری* کنیم. در این حالت، گروه‌ها می‌توانند به عنوان یک دیکشنری پایتون استخراج شوند:


```python
email4 = re.compile(r'(?P<user>[\w.]+)@(?P<domain>\w+)\.(?P<suffix>[a-z]{3})')
match = email4.match('guido@python.org')
match.groupdict()

>>> {'domain': 'python', 'suffix': 'org', 'user': 'guido'}
```

ترکیب این ایده‌ها (همراه با برخی از syntaxهای قدرتمند عبارات باقاعده که در اینجا به آنها نپرداختیم) به شما امکان میدهد تا به شکلی انعطاف‌پذیر و سریع، اطلاعات را از رشتهها در پایتون استخراج کنید.
### منابع بیشتر برای یادگیری عبارات باقاعده

بحث فوق تنها یک مرور سریع (و البته بسیار ناکامل) از این موضوع گسترده بود. اگر مایلید بیشتر یاد بگیرید، منابع زیر را توصیه میکنم:

- **[مستندات بسته ``re`` پایتون](https://docs.python.org/3/library/re.html)**: من همیشه متوجه میشوم که تقریباً هر بار که از عبارات باقاعده استفاده میکنم، نحوه استفاده از آنها را فراموش کردهام. حالا که اصول اولیه را فهمیدهام، این صفحه منبعی بسیار ارزشمند برای یادآوری معنای هر کاراکتر یا دنباله خاص در یک عبارت باقاعده است.
- **[راهنمای رسمی عبارات باقاعده در پایتون](https://docs.python.org/3/howto/regex.html)**: یک رویکرد رواییتر برای یادگیری عبارات باقاعده در پایتون.
- **[کتاب Mastering Regular Expressions (انتشارات OReilly، 2006)](http://shop.oreilly.com/product/9780596528126.do)**: یک کتاب 500+ صفحهای در این زمینه. اگر به دنبال یک درمان واقعاً کامل از این موضوع هستید، این منبع مناسب شماست.

برای مشاهده نمونه‌هایی از کاربردهای عملی manipulation رشتهها و عبارات باقاعده در مقیاس بزرگ‌تر، میتوانید به بخش **[Pandas: داده‌های برچسب‌دار ستونی-محور](15-Preview-of-Data-Science-Tools.ipynb#Pandas:-Labeled-Column-oriented-Data)** مراجعه کنید، جایی که به بررسی اعمال این نوع expressions روی *جدول‌های* داده متنی در بسته Pandas می‌پردازیم.


