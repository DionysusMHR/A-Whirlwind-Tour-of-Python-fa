# تعریف و استفاده از توابع

تاکنون، اسکریپت‌های ما بلوک‌های کد ساده و یک‌بارمصرف بوده‌اند.  
یکی از راه‌های سازماندهی کد پایتون و خوانایی و استفاده مجدد از آن، استخراج بخش‌های مفید و تبدیل آن‌ها به *توابع* قابل استفاده مجدد است.  
در اینجا دو روش برای ایجاد توابع را پوشش می‌دهیم: دستور ``def`` که برای هر نوع تابعی مفید است، و دستور ``lambda`` که برای ایجاد توابع کوتاه ناشناس مفید می‌باشد.

## استفاده از توابع

توابع گروه‌هایی از کد هستند که یک نام دارند و می‌توان آن‌ها را با استفاده از پرانتز فراخوانی کرد.  
قبلاً با توابع آشنا شده‌اید. برای مثال، ``print`` در پایتون 3 یک تابع است:

```python
print('abc')

>>> abc
```

در اینجا ``print`` نام تابع و ``'abc'`` *آرگومان* تابع است.

علاوه بر آرگومان‌ها، *آرگومان‌های کلیدی* نیز وجود دارند که توسط نام مشخص می‌شوند.  
یکی از آرگومان‌های کلیدی موجود برای تابع ``print()`` (در پایتون 3) ``sep`` است که مشخص می‌کند از چه کاراکتر یا کاراکترهایی برای جدا کردن چندین مورد باید استفاده شود:

```python
print(1, 2, 3)

>>> 1 2 3
```

```python
print(1, 2, 3, sep='--')

>>> 1--2--3
```

هنگامی که از آرگومان‌های غیرکلیدی همراه با آرگومان‌های کلیدی استفاده می‌شود، آرگومان‌های کلیدی باید در انتها قرار گیرند.


```python
def fibonacci(N):
    L = []
    a, b = 0, 1
    while len(L) < N:
        a, b = b, a + b
        L.append(a)
    return L
```
حالا تابعی داریم به نام fibonacci که یک ورودی به نام N می‌گیرد، محاسباتی با این ورودی انجام می‌دهد و در نهایت یک مقدار برمی‌گرداند؛ که در این مورد، یک لیست از N عدد اول فیبوناچی است.

```python
fibonacci(10)

>>> [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

اگر با زبان‌های strongly-typed مانند ``C`` آشنا باشید، بلافاصله متوجه خواهید شد که هیچ اطلاعات نوعی مرتبط با ورودی‌ها یا خروجی‌های تابع وجود ندارد.  
توابع پایتون می‌توانند هر شیء پایتون، ساده یا مرکب را بازگردانند، که به این معنی است که ساختارهایی که در سایر زبان‌ها ممکن است دشوار باشند، در پایتون ساده هستند.  

برای مثال، چندین مقدار بازگشتی به سادگی در یک تاپل قرار می‌گیرند که با کاما مشخص می‌شوند:

```python
def real_imag_conj(val):
    return val.real, val.imag, val.conjugate()

r, i, c = real_imag_conj(3 + 4j)
print(r, i, c)

>>> 3.0 4.0 (3-4j)
```
## مقادیر پیش‌فرض آرگومان‌ها

اغلب هنگام تعریف یک تابع، مقادیر مشخصی وجود دارند که می‌خواهیم تابع در *بیشتر* مواقع از آن‌ها استفاده کند، اما در عین حال می‌خواهیم به کاربر انعطاف‌پذیری بدهیم.  
در این حالت می‌توانیم از *مقادیر پیش‌فرض* برای آرگومان‌ها استفاده کنیم.  
تابع ``fibonacci`` قبلی را در نظر بگیرید.  
چه می‌شود اگر بخواهیم کاربر بتواند با مقادیر شروع کار کند؟  
می‌توانیم این کار را به صورت زیر انجام دهیم:

```python
def fibonacci(N, a=0, b=1):
    L = []
    while len(L) < N:
        a, b = b, a + b
        L.append(a)
    return L
```

با یک آرگومان، نتیجه فراخوانی تابع مشابه قبل است:

```python
fibonacci(10)

>>> [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

اما اکنون می‌توانیم از تابع برای کاوش موارد جدید استفاده کنیم، مانند تأثیر مقادیر شروع جدید:

```python
fibonacci(10, 0, 2)

>>> [2, 2, 4, 6, 10, 16, 26, 42, 68, 110]
```

مقادیر همچنین در صورت تمایل می‌توانند بر اساس نام مشخص شوند، که در این case ترتیب مقادیر نام‌گذاری شده اهمیتی ندارد:

```python
fibonacci(10, b=3, a=1)

>>> [3, 4, 7, 11, 18, 29, 47, 76, 123, 199]
```

## ``*args`` و ``**kwargs``: آرگومان‌های انعطاف‌پذیر  
گاهی ممکن است بخواهید تابعی بنویسید که در ابتدا نمی‌دانید کاربر چند آرگومان ارسال خواهد کرد.  
در این حالت می‌توانید از فرم خاص ``*args`` و ``**kwargs`` برای دریافت تمام آرگومان‌های ارسال شده استفاده کنید.  
در اینجا یک مثال آورده شده است:

```python
def catch_all(*args, **kwargs):
    print("args =", args)
    print("kwargs = ", kwargs)
```

```python
catch_all(1, 2, 3, a=4, b=5)

>>> args = (1, 2, 3)
kwargs =  {'a': 4, 'b': 5}
```

```python
catch_all('a', keyword=2)

>>> args = ('a',)
kwargs =  {'keyword': 2}
```

در اینجا نام‌های ``args`` و ``kwargs`` مهم نیستند، بلکه کاراکترهای ``*`` قبل از آن‌ها اهمیت دارند.  
``args`` و ``kwargs`` فقط نام‌های متغیری هستند که معمولاً بر اساس قرارداد استفاده می‌شوند، مخفف «آرگومان‌ها» و «آرگومان‌های کلیدی».  
تفاوت عملی در کاراکترهای ستاره است: یک ``*`` قبل از یک متغیر به معنای «این را به عنوان یک دنباله گسترش بده» است، در حالی که ``**`` قبل از یک متغیر به معنای «این را به عنوان یک دیکشنری گسترش بده» است.  
در واقع، این سینتکس نه تنها در تعریف تابع، بلکه در فراخوانی تابع نیز می‌تواند استفاده شود!


```python
inputs = (1, 2, 3)
keywords = {'pi': 3.14}

catch_all(*inputs, **keywords)

>>> args = (1, 2, 3)
kwargs =  {'pi': 3.14}
```

## توابع ناشناس (``lambda``)  
پیش‌تر به طور خلاصه رایج‌ترین روش تعریف توابع، یعنی دستور ``def`` را پوشش دادیم.  
احتمالاً با روش دیگری برای تعریف توابع کوتاه و یک‌بارمصرف با دستور ``lambda`` برخورد خواهید کرد.  
این دستور به این شکل است:

```python
add = lambda x, y: x + y
add(1, 2)

>>> 3
```

این تابع لامبدا تقریباً معادل است با:


```python
def add(x, y):
    return x + y
```
پس چرا باید از چنین چیزی استفاده کنید؟  
در درجه اول، این موضوع به این حقیقت برمی‌گردد که *همه چیز در پایتون یک شیء است*، حتی خود توابع!  
این یعنی توابع می‌توانند به عنوان آرگومان به توابع دیگر منتقل شوند.  

به عنوان مثال، فرض کنید داده‌هایی در یک لیست از دیکشنری‌ها ذخیره شده است:

```python
data = [{'first':'Guido', 'last':'Van Rossum', 'YOB':1956},
        {'first':'Grace', 'last':'Hopper',     'YOB':1906},
        {'first':'Alan',  'last':'Turing',     'YOB':1912}]
```

حال فرض کنید می‌خواهیم این داده‌ها را مرتب کنیم.  
پایتون یک تابع ``sorted`` دارد که این کار را انجام می‌دهد:

```python
sorted([2,4,3,5,1,6])

>>> [1, 2, 3, 4, 5, 6]
```
```python
data = [{'first':'Guido', 'last':'Van Rossum', 'YOB':1956},
        {'first':'Grace', 'last':'Hopper',     'YOB':1906},
        {'first':'Alan',  'last':'Turing',     'YOB':1912}]
```

دیکشنری‌ها قابل مرتب‌سازی نیستند: به یک راه نیاز داریم تا به تابع بگوییم *چگونه* داده‌های ما را مرتب کند.  
این کار را می‌توانیم با مشخص کردن تابع ``key`` انجام دهیم، تابعی که با دریافت یک آیتم، کلید مرتب‌سازی مربوط به آن آیتم را برمی‌گرداند.

```python
# sort alphabetically by first name
sorted(data, key=lambda item: item['first'])

>>> [{'YOB': 1912, 'first': 'Alan', 'last': 'Turing'},
 {'YOB': 1906, 'first': 'Grace', 'last': 'Hopper'},
 {'YOB': 1956, 'first': 'Guido', 'last': 'Van Rossum'}]
```

```python
# sort by year of birth
sorted(data, key=lambda item: item['YOB'])

>>> [{'YOB': 1906, 'first': 'Grace', 'last': 'Hopper'},
 {'YOB': 1912, 'first': 'Alan', 'last': 'Turing'},
 {'YOB': 1956, 'first': 'Guido', 'last': 'Van Rossum'}]
```

با اینکه این توابع کلید قطعاً می‌توانند با سینتکس معمولی ``def`` ساخته شوند، اما سینتکس ``lambda`` برای چنین توابع کوتاه و یک‌بارمصرفی مناسب‌تر است.
