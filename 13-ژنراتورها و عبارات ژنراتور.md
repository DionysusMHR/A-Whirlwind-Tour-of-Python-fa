<div dir=rtl>



|
<a href="12-تعریف فشرده لیست.md">تعریف فشرده لیست</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="14-ماژول‌ها و بسته‌ها.md">ماژول‌ها و بسته ها</a>
|


<h1>Generators - تولیدکننده‌ها</h1>


<p>در اینجا وارد یک بررسی عمیق‌تر دربارهٔ Generatorهای پایتون می‌شویم؛ شامل عبارت‌های تولیدکننده (Generator Expressions) و توابع تولیدکننده (Generator Functions).</p>


<h2>Generator Expressions - عبارت‌های تولیدکننده</h1>


<p>تفاوت بین لیست‌برداری‌ها (List Comprehensions) و عبارت‌های تولیدکننده (Generator Expressions) گاهی باعث سردرگمی می‌شود؛ در این بخش، به‌طور خلاصه تفاوت‌های میان آن‌ها را بیان می‌کنیم:</p>


<p><b>لیست‌برداری‌ها از براکت‌های مربعی استفاده می‌کنند، در حالی که عبارت‌های تولیدکننده از پرانتز بهره می‌برند.</b></p>


<p>این یک لیست‌برداری نمونه است:</p>



<pre dir=ltr>
<font color=white>
[n ** 2 for n in range(12)]
</pre>
<p dir=ltr>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]</p>


<p>و این یک عبارت تولیدکنندهٔ نمونه است:</p>


<pre dir=ltr>
<font color=white>
(n ** 2 for n in range(12))
</pre>
<p dir=ltr><'generator object <'genexpr'> at 0x104a60518'></p>


<p>توجه کنید که چاپ‌کردن یک عبارت تولیدکننده، محتوای آن را چاپ نمی‌کند؛ برای چاپ محتوای یک Generator Expression می‌توانید آن را به سازندهٔ لیست (list) ارسال کنید:</p>



<pre dir=ltr>
<font color=white>
G = (n ** 2 for n in range(12))
list(G)
</pre>
<p dir=ltr>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]</p>


<p><b>یک لیست مجموعه‌ای از مقدارها است، در حالی که یک ژنراتور دستورالعملی برای تولید مقدارها به‌شمار می‌رود.</b></p>


<p>وقتی یک لیست ایجاد می‌کنید، در حقیقت در حال ساختن یک مجموعه از مقدارها هستید و این کار هزینهٔ حافظه‌ای به همراه دارد. اما هنگامی که یک ژنراتور می‌سازید، شما هیچ مجموعه‌ای از مقدارها را ایجاد نمی‌کنید، بلکه یک دستورالعمل برای تولید آن مقدارها ایجاد می‌کنید.
هر دو دقیقاً همان رابط تکرار (iterator interface) را ارائه می‌دهند، همان‌طور که در اینجا می‌بینیم:</p>


<pre dir=ltr>
<font color=white>
L = [n ** 2 for n in range(12)]
for val in L:
    print(val, end=' ')
</pre>
<p dir=ltr>0 1 4 9 16 25 36 49 64 81 100 121</p>


<pre dir=ltr>
<font color=white>
G = (n ** 2 for n in range(12))
for val in G:
    print(val, end=' ')
</pre>
<p dir=ltr>0 1 4 9 16 25 36 49 64 81 100 121</p>


<p>تفاوت اینجاست که یک عبارت تولیدکننده (Generator Expression) تا زمانی که مقدارها موردنیاز نباشند، آن‌ها را واقعاً محاسبه نمی‌کند. این موضوع نه‌تنها به کارایی حافظه کمک می‌کند، بلکه باعث کارایی محاسباتی نیز می‌شود!
این همچنین به این معناست که در حالی که اندازهٔ یک لیست به مقدار حافظهٔ در دسترس محدود است، اندازهٔ یک Generator Expression نامحدود است!</p>


<p>یک مثال از عبارت تولیدکنندهٔ نامتناهی را می‌توان با استفاده از تکرارگر count که در ماژول itertools تعریف شده، ایجاد کرد:</p>


<pre dir=ltr>
<font color=white>
from itertools import count
count()
</pre>
<p dir=ltr>count(0)</p>



<pre dir=ltr>
<font color=white>
for i in count():
    print(i, end=' ')
    if i >= 10: break
</pre>
<p dir=ltr>0 1 2 3 4 5 6 7 8 9 10</p>


<p>تکرارگر count به‌طور پیوسته و بی‌پایان شمارش می‌کند تا زمانی که شما آن را متوقف کنید؛ این ویژگی ایجاد ژنراتورهایی که به‌طور نامتناهی ادامه می‌یابند را بسیار آسان می‌کند:</p>



<pre dir=ltr>
<font color=white>
factors = [2, 3, 5, 7]
G = (i for i in count() if all(i % n > 0 for n in factors))
for val in G:
    print(val, end=' ')
    if val > 40: break
</pre>
<p dir=ltr>1 11 13 17 19 23 29 31 37 41</p>


<p>شاید متوجه منظوری که داریم شده باشید: اگر لیست عوامل را به‌طور مناسب گسترش دهیم، در واقع در حال ایجاد یک ژنراتور اعداد اول هستیم که از الگوریتم غربال اراتوستن استفاده می‌کند. کمی بعد، این موضوع را به‌طور مفصل بررسی خواهیم کرد.</p>



<p><b>یک لیست را می‌توان چندین بار تکرار کرد، اما یک عبارت تولیدکننده (Generator Expression) تنها یک‌بار قابل استفاده است.</b></p>


<p>این یکی از آن نکات احتمالی پرتگاه‌ساز (gotchas) در عبارت‌های تولیدکننده است. با یک لیست، می‌توانیم به‌سادگی این کار را انجام دهیم:</p>


<pre dir=ltr>
<font color=white>
L = [n ** 2 for n in range(12)]
for val in L:
    print(val, end=' ')
print()

for val in L:
    print(val, end=' ')
</pre>
<p dir=ltr>0 1 4 9 16 25 36 49 64 81 100 121 <br>
0 1 4 9 16 25 36 49 64 81 100 121</p>


<p>از طرف دیگر، یک عبارت تولیدکننده پس از یک بار تکرار تمام می‌شود و دیگر قابل استفاده نیست:</p>



<pre dir=ltr>
<font color=white>
G = (n ** 2 for n in range(12))
list(G)
</pre>
<p dir=ltr>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]</p>


<pre dir=ltr>
<font color=white>
list(G)
</pre>
<p dir=ltr>[]</p>


<p>این ویژگی می‌تواند بسیار مفید باشد، زیرا به این معناست که تکرار می‌تواند متوقف و دوباره از سر گرفته شود:</p>


<pre dir=ltr>
<font color=white>
G = (n**2 for n in range(12))
for n in G:
    print(n, end=' ')
    if n > 30: break

print("\ndoing something in between")

for n in G:
    print(n, end=' ')
</pre>
<p dir=ltr>0 1 4 9 16 25 36 <br>
doing something in between <br>
49 64 81 100 121</p>


<p>یکی از مواردی که این ویژگی برای من مفید بوده، زمانی است که با مجموعه‌ای از فایل‌های داده روی دیسک کار می‌کنیم؛ این بدان معناست که می‌توان به‌راحتی آن‌ها را به‌صورت دسته‌ای تحلیل کرد و ژنراتور پیگیری می‌کند که کدام فایل‌ها هنوز مشاهده نشده‌اند.</p>


<h2> توابع تولیدکننده: استفاده از yield</h2>


<p>دیدیم در بخش قبلی که لیست‌برداری‌ها بهترین کاربرد را برای ساخت لیست‌های نسبتاً ساده دارند، در حالی که استفاده از یک حلقهٔ for معمولی می‌تواند در شرایط پیچیده‌تر مناسب‌تر باشد. همین موضوع برای عبارت‌های تولیدکننده (Generator Expressions) نیز صادق است: می‌توان ژنراتورهای پیچیده‌تر را با استفاده از توابع تولیدکننده (Generator Functions) ساخت که از دستور yield بهره می‌برند.</p>


<p>در اینجا دو روش برای ساخت همان لیست را داریم:</p>



<pre dir=ltr>
<font color=white>
L1 = [n ** 2 for n in range(12)]

L2 = []
for n in range(12):
    L2.append(n ** 2)

print(L1)
print(L2)
</pre>
<p dir=ltr>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121] <br>
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]</p>



<p>به‌طور مشابه، در اینجا دو روش برای ساخت ژنراتورهای معادل را داریم:</p>


<pre dir=ltr>
<font color=white>
L1 = [n ** 2 for n in range(12)]

L2 = []
for n in range(12):
    L2.append(n ** 2)

print(L1)
print(L2)
</pre>
<p dir=ltr>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121] <br>
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121]</p>


<p>به‌طور مشابه، در اینجا دو روش برای ساخت ژنراتورهای معادل را داریم:</p>



<pre dir=ltr>
<font color=white>
G1 = (n ** 2 for n in range(12))

def gen():
    for n in range(12):
        yield n ** 2

G2 = gen()
print(*G1)
print(*G2)
</pre>
<p dir=ltr>0 1 4 9 16 25 36 49 64 81 100 121 <br>
0 1 4 9 16 25 36 49 64 81 100 121</p>


<p>یک تابع تولیدکننده تابعی است که به جای استفاده از return برای بازگرداندن یک مقدار به‌طور یک‌باره، از yield استفاده می‌کند تا یک دنبالهٔ (احتمالاً نامتناهی) از مقدارها را تولید کند. همانند عبارت‌های تولیدکننده، وضعیت ژنراتور بین تکرارهای جزئی حفظ می‌شود، اما اگر بخواهیم یک نسخهٔ تازه از ژنراتور داشته باشیم، کافی است تابع را دوباره فراخوانی کنیم.</p>


<h2>مثال: ژنراتور اعداد اول</h2>


<p>در اینجا می‌خواهم مثال مورد علاقه‌ام از توابع تولیدکننده را نشان دهم: تابعی برای تولید یک دنبالهٔ نامحدود از اعداد اول. یک الگوریتم کلاسیک برای این کار، غربال اراتوستن (Sieve of Eratosthenes) است که به‌طور تقریبی به این شکل عمل می‌کند:</p>



<pre dir=ltr>
<font color=white>
# Generate a list of candidates
L = [n for n in range(2, 40)]
print(L)
</pre>
<p dir=ltr>[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]</p>


<pre dir=ltr>
<font color=white>
# Remove all multiples of the first value
L = [n for n in L if n == L[0] or n % L[0] > 0]
print(L)
</pre>
<p dir=ltr>[2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]</p>


<pre dir=ltr>
<font color=white>
# Remove all multiples of the second value
L = [n for n in L if n == L[1] or n % L[1] > 0]
print(L)
</pre>
<p dir=ltr>[2, 3, 5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37]</p>


<pre dir=ltr>
<font color=white>
# Remove all multiples of the third value
L = [n for n in L if n == L[2] or n % L[2] > 0]
print(L)
</pre>
<p dir=ltr>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]</p>




<p>اگر این روند را به‌اندازهٔ کافی روی لیستی به‌اندازهٔ کافی بزرگ تکرار کنیم، می‌توانیم تعداد دلخواهی از اعداد اول را تولید کنیم.</p>


<p>بیایید این منطق را در یک تابع تولیدکننده قرار دهیم:</p>


<pre dir=ltr>
<font color=white>
def gen_primes(N):
    """Generate primes up to N"""
    primes = set()
    for n in range(2, N):
        if all(n % p > 0 for p in primes):
            primes.add(n)
            yield n

print(*gen_primes(100))
</pre>
<p dir=ltr>2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97</p>


<p>همین بود! هرچند که این مطمئناً بهینه‌ترین پیاده‌سازی محاسباتی الگوریتم غربال اراتوستن نیست، اما نشان می‌دهد که نحو توابع تولیدکننده چقدر می‌تواند برای ساخت دنباله‌های پیچیده‌تر راحت و کاربردی باشد.</p>



|
<a href="12-تعریف فشرده لیست.md">تعریف فشرده لیست</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="14-ماژول‌ها و بسته‌ها.md">ماژول‌ها و بسته ها</a>
|




</div>