<div dir=rtl>

|
<a href="06-انواع داده اسکالر داخلی.md">انواع داده اسکالر داخلی</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="08-دستورات کنترل جریان.md">دستورات کنترل جریان</a>
|


<h1>ساختارهای داده‌ای داخلی (Built-In Data Structures)</h1>


<p>ما تاکنون با انواع سادهٔ پایتون آشنا شدیم: int، float، complex، bool، str و غیره.


پایتون همچنین چندین نوع مرکب داخلی دارد که به‌عنوان کانتینر (Container) برای نگهداری انواع دیگر عمل می‌کنند. این انواع مرکب عبارت‌اند از:</p>


<table>
    <tr>
        <th>نام نوع</th>
        <th>مثال</th>
        <th>توضیحات</th>
    </tr>
    <tr>
        <td>list</td>
        <td>[1, 2, 3]</td>
        <td>مجموعهٔ مرتب (Ordered collection)</td>
    </tr>
    <tr>
        <td>tuple</td>
        <td>(1, 2, 3)</td>
        <td>مجموعهٔ مرتبِ تغییرناپذیر (Immutable ordered collection)</td>
    </tr>
    <tr>
        <td>dict</td>
        <td>{'a':1, 'b':2, 'c':3}</td>
        <td>نگاشت نامرتبِ کلید–مقدار</td>
    </tr>
    <tr>
        <td>set</td>
        <td>{1, 2, 3}</td>
        <td>مجموعهٔ نامرتبِ مقادیر یکتا</td>
    </tr>
</table>



<p>همان‌طور که می‌بینید، پرانتزهای گرد، کروشه‌ها (براکت‌های مربعی) و آکولادها هر کدام معنای متفاوتی در تعیین نوع مجموعه‌ای دارند که ایجاد می‌شود. در ادامه، یک مرور سریع از این ساختارهای داده خواهیم داشت.</p>


<h2>لیست‌ها (Lists)</h2>



<p>لیست‌ها (Lists) نوع پایه‌ای مجموعه‌های مرتب و قابل تغییر (mutable) در پایتون هستند. برای تعریف آن‌ها از مقادیر جداشده با ویرگول داخل کروشه‌ها استفاده می‌کنیم. برای مثال، در اینجا یک فهرست از چند عدد اول ابتدایی آمده است:</p>



<pre dir=ltr>
<font color=white>
L = [2, 3, 5, 7]
</pre>


<p>فهرست‌ها دارای ویژگی‌ها و متدهای مفیدی هستند. در اینجا نگاهی کوتاه به برخی از متداول‌ترین و کاربردی‌ترین آن‌ها می‌اندازیم:</p>


<pre dir=ltr>
<font color=white>
# Length of a list
len(L)
</pre>
<p dir=ltr>4</p>


<pre dir=ltr>
<font color=white>
# Append a value to the end
L.append(11)
L
</pre>
<p dir=ltr>[2, 3, 5, 7, 11]</p>


<pre dir=ltr>
<font color=white>
# Addition concatenates lists
L + [13, 17, 19]
</pre>
<p dir=ltr>[2, 3, 5, 7, 11, 13, 17, 19]</p>


<pre dir=ltr>
<font color=white>
# sort() method sorts in-place
L = [2, 5, 1, 6, 3, 4]
L.sort()
L
</pre>
<p dir=ltr>[1, 2, 3, 4, 5, 6]</p>


<p>علاوه بر این، متدهای داخلی زیادی برای فهرست‌ها وجود دارد که در <a href=https://docs.python.org/3/tutorial/datastructures.html>مستندات آنلاین پایتون</a> به‌طور کامل پوشش داده شده‌اند.</p>


<p>در حالی که تاکنون فهرست‌هایی را نشان داده‌ایم که شامل مقادیر از یک نوع واحد هستند، یکی از ویژگی‌های قدرتمند اشیاء مرکب پایتون این است که می‌توانند اشیاء از هر نوع، یا حتی ترکیبی از انواع مختلف را در خود داشته باشند. برای مثال:</p>


<pre dir=ltr>
<font color=white>
L = [1, 'two', 3.14, [0, 3, 5]]
</pre>


<p>این انعطاف‌پذیری نتیجه‌ی سیستم نوع‌دهی پویا در پایتون است. ایجاد چنین دنباله‌ای با انواع ترکیبی در یک زبان دارای نوع‌دهی ایستا مانند C می‌تواند بسیار مشکل‌ساز باشد! می‌بینیم که فهرست‌ها حتی می‌توانند شامل فهرست‌های دیگر به‌عنوان عناصر خود باشند. این انعطاف نوع‌ها بخش مهمی از دلایلی است که کدنویسی در پایتون را نسبتاً سریع و آسان می‌کند.</p>


<p>تا اینجا ما به دست‌کاری فهرست‌ها به‌صورت کلی پرداخته‌ایم؛ بخش مهم دیگر، دسترسی به عناصر فردی است. این کار در پایتون از طریق اندیس‌گذاری (indexing) و برش (slicing) انجام می‌شود که در ادامه به آن خواهیم پرداخت.</p>


<h2>اندیس‌گذاری و برش فهرست‌ها</h2>


<p>پایتون امکان دسترسی به عناصر در انواع مرکب را از طریق اندیس‌گذاری برای عناصر تک و برش (slicing) برای چندین عنصر فراهم می‌کند. همان‌طور که خواهیم دید، هر دو با استفاده از نگارش کروشه [ ] مشخص می‌شوند. فرض کنید به فهرست چند عدد اول اولیه خود بازگردیم:</p>



<pre dir=ltr>
<font color=white>
L = [2, 3, 5, 7, 11]
</pre>


<p>پایتون از اندیس‌گذاری مبتنی بر صفر استفاده می‌کند، بنابراین می‌توانیم به عنصر اول و دوم با استفاده از نگارش زیر دسترسی پیدا کنیم:</p>


<pre dir=ltr>
<font color=white>
L[0]
</pre>
<p dir=ltr>2</p>


<pre dir=ltr>
<font color=white>
L[1]
</pre>
<p dir=ltr>3</p>


<p>عناصر انتهایی لیست را می‌توان با اعداد منفی و با شروع از -1 دسترسی داشت:</p>


<pre dir=ltr>
<font color=white>
L[-1]
</pre>
<p dir=ltr>11</p>


<pre dir=ltr>
<font color=white>
L[-2]
</pre>
<p dir=ltr>7</p>


<p>می‌توانید این طرح‌بندی اندیس‌دهی را به این شکل تصور کنید:</p>


<img src=img/list-indexing.png>


<p>در اینجا مقادیر موجود در لیست با اعداد بزرگ داخل مربع‌ها نمایش داده شده‌اند؛ اندیس‌های لیست با اعداد کوچک بالاو پایین نشان داده شده‌اند. در این مثال، L[2] مقدار ۵ را برمی‌گرداند، زیرا این مقدار در اندیس ۲ قرار دارد.</p>


<p>در حالی که ایندکس‌گذاری روشی برای دسترسی به یک مقدار واحد از لیست است، برش (slicing) روشی برای دسترسی به چند مقدار به‌صورت زیرلیست‌ها است. در این روش از دونقطه (:) برای مشخص کردن نقطه شروع (شامل) و نقطه پایان (شامل نمی‌شود) زیرآرایه استفاده می‌کنیم. به‌عنوان مثال، برای گرفتن سه عنصر اول لیست می‌توان نوشت:</p>


<pre dir=ltr>
<font color=white>
L[0:3]
</pre>
<p dir=ltr>[2, 3, 5]</p>


<p>به موقعیت ۰ و ۳ در نمودار قبلی توجه کنید و ببینید که برش فقط مقادیر بین ایندکس‌ها را برمی‌دارد. اگر ایندکس اول را حذف کنیم، ۰ به‌صورت پیش‌فرض در نظر گرفته می‌شود، بنابراین می‌توان به‌طور معادل نوشت:</p>


<pre dir=ltr>
<font color=white>
L[:3]
</pre>
<p dir=ltr>[2, 3, 5]</p>


<p>به‌طور مشابه، اگر ایندکس آخر را حذف کنیم، به‌صورت پیش‌فرض طول لیست در نظر گرفته می‌شود. بنابراین، سه عنصر آخر را می‌توان به شکل زیر دسترسی داشت:</p>


<pre dir=ltr>
<font color=white>
L[-3:]
</pre>
<p dir=ltr>[5, 7, 11]</p>


<p>در نهایت، می‌توان یک عدد صحیح سوم مشخص کرد که نشان‌دهنده اندازه گام (step) باشد؛ برای مثال، برای انتخاب هر دومین عنصر لیست، می‌توانیم بنویسیم:</p>


<pre dir=ltr>
<font color=white>
L[::2]  # equivalent to L[0:len(L):2]
</pre>
<p dir=ltr>[2, 5, 11]</p>


<p>نسخه‌ای به‌ویژه کاربردی از این روش، مشخص کردن گام منفی است که باعث برعکس شدن ترتیب آرایه می‌شود:</p>


<pre dir=ltr>
<font color=white>
L[::-1]
</pre>
<p dir=ltr>[11, 7, 5, 3, 2]</p>


<p>هم ایندکس‌گذاری و هم برش (slicing) می‌توانند برای تعیین مقدار عناصر علاوه بر دسترسی به آن‌ها استفاده شوند. نحو آن همان چیزی است که انتظار دارید:</p>


<pre dir=ltr>
<font color=white>
L[0] = 100
print(L)
</pre>
<p dir=ltr>[100, 3, 5, 7, 11]</p>


<pre dir=ltr>
<font color=white>
L[1:3] = [55, 56]
print(L)
</pre>
<p dir=ltr>[100, 55, 56, 7, 11]</p>


<p>یک نحو برش (slicing) بسیار مشابه نیز در بسیاری از کتابخانه‌های مرتبط با علم داده، از جمله NumPy و Pandas (که در مقدمه اشاره شد) استفاده می‌شود.</p>


<p>حال که با لیست‌های پایتون و روش دسترسی به عناصر در نوع داده‌های مرکب مرتب شده آشنا شدیم، بیایید نگاهی به سه نوع داده مرکب استاندارد دیگر که پیش‌تر اشاره شد، بیندازیم.</p>


<h2>تاپل‌ها</h2>


<p>تاپل‌ها در بسیاری از جنبه‌ها شبیه لیست‌ها هستند، با این تفاوت که با پرانتز ( ) تعریف می‌شوند، نه براکت‌های مربع [ ].</p>



<pre dir=ltr>
<font color=white>
t = (1, 2, 3)
</pre>



<p>همچنین می‌توان آن‌ها را بدون هیچ نوع براکتی تعریف کرد:</p>



<pre dir=ltr>
<font color=white>
t = 1, 2, 3
print(t)
</pre>
<p dir=ltr>(1, 2, 3)</p>


<p>مثل لیست‌هایی که قبلاً بررسی شد، تاپل‌ها هم طول دارند و می‌توان عناصر فردی آن‌ها را با استفاده از ایندکس‌گذاری داخل کروشه‌ها استخراج کرد:</p>


<pre dir=ltr>
<font color=white>
len(t)
</pre>
<p dir=ltr>3</p>


<pre dir=ltr>
<font color=white>
t[0]
</pre>
<p dir=ltr>1</p>


<p>ویژگی اصلی متمایزکننده تاپل‌ها این است که آن‌ها غیرقابل تغییر (immutable) هستند: این بدان معناست که پس از ایجاد شدن، اندازه و محتوای آن‌ها نمی‌تواند تغییر کند:</p>


<pre dir=ltr>
<font color=white>
t[1] = 4
</pre>
<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<'ipython-input-23-141c76cb54a2'> in <'module'>()
----> 1 t[1] = 4

TypeError: 'tuple' object does not support item assignment
</pre>


<pre dir=ltr>
<font color=white>
t.append(4)
</pre>

<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<'ipython-input-24-e8bd1632f9dd'> in <'module'>()
----> 1 t.append(4)

AttributeError: 'tuple' object has no attribute 'append'
</pre>


<p>تاپل‌ها اغلب در برنامه‌های پایتون استفاده می‌شوند؛ یکی از موارد رایج، استفاده در توابعی است که چندین مقدار بازگشتی دارند. به عنوان مثال، متد <span dir=ltr>as_integer_ratio()</span> برای اشیاء عدد اعشاری (float) یک صورت و یک مخرج بازمی‌گرداند؛ این بازگشت دوگانه به صورت یک تاپل ارائه می‌شود:</p>


<pre dir=ltr>
<font color=white>
x = 0.125
x.as_integer_ratio()
</pre>
<p dir=ltr>(1, 8)</p>


<p>این مقادیر بازگشتی چندگانه را می‌توان به صورت جداگانه به متغیرها اختصاص داد، به شکل زیر:</p>


<pre dir=ltr>
<font color=white>
numerator, denominator = x.as_integer_ratio()
print(numerator / denominator)
</pre>
<p dir=ltr>0.125</p>


<p>منطق ایندکس‌گذاری و برش‌دهی (slicing) که قبلاً برای لیست‌ها توضیح داده شد، برای تاپل‌ها نیز کاربرد دارد، همراه با مجموعه‌ای از متدهای دیگر. برای فهرست کامل‌تر این متدها، به <a href=https://docs.python.org/3/tutorial/datastructures.html>مستندات آنلاین پایتون</a> مراجعه کنید.</p>


<h2>Dictionaries (واژه‌نامه‌ها)</h2>


<p>واژه‌نامه‌ها (Dictionaries) نگاشت‌هایی بسیار انعطاف‌پذیر از کلیدها به مقادیر هستند و پایه بسیاری از پیاده‌سازی‌های داخلی پایتون را تشکیل می‌دهند. می‌توان آن‌ها را با استفاده از یک فهرست جداشده با کاما از جفت‌های کلید:مقدار در داخل آکولاد ایجاد کرد:</p>


<pre dir=ltr>
<font color=white>
numbers = {'one':1, 'two':2, 'three':3}
</pre>


<p>عناصر دیکشنری با استفاده از سینتکس ایندکس‌گذاری که برای لیست‌ها و تاپل‌ها استفاده می‌شود، دسترسی و مقداردهی می‌شوند؛ با این تفاوت که در اینجا ایندکس یک ترتیب صفر-مبنای عددی نیست، بلکه یک کلید معتبر در دیکشنری است:</p>


<pre dir=ltr>
<font color=white>
# Access a value via the key
numbers['two']
</pre>
<p dir=ltr>2</p>


<p>عناصر جدید را می‌توان با استفاده از ایندکس‌گذاری نیز به دیکشنری اضافه کرد:</p>


<pre dir=ltr>
<font color=white>
# Set a new key:value pair
numbers['ninety'] = 90
print(numbers)
</pre>
<p dir=ltr>{'three': 3, 'ninety': 90, 'two': 2, 'one': 1}</p>


<p>به خاطر داشته باشید که دیکشنری‌ها هیچ ترتیب مشخصی برای پارامترهای ورودی نگه نمی‌دارند؛ این موضوع به صورت طراحی‌شده است. نبود ترتیب باعث می‌شود که دیکشنری‌ها با کارایی بسیار بالا پیاده‌سازی شوند، به طوری که دسترسی تصادفی به عناصر بسیار سریع باشد، بدون توجه به اندازه دیکشنری (اگر کنجکاو هستید که این چگونه کار می‌کند، درباره مفهوم هش‌تیبل (hash table) مطالعه کنید). <a href=https://docs.python.org/3/library/stdtypes.html>مستندات پایتون</a> فهرست کاملی از متدهای موجود برای دیکشنری‌ها را ارائه می‌دهد.</p>


<h2>مجموعه‌ها (Sets)</h2>


<p>چهارمین نوع مجموعه‌های پایه، ست‌ها (Sets) هستند که شامل مجموعه‌های نامرتب از عناصر یکتا می‌باشند. تعریف آن‌ها مشابه لیست‌ها و تاپل‌ها است، با این تفاوت که از آکولادهای دیکشنری استفاده می‌کنند:</p>


<pre dir=ltr>
<font color=white>
primes = {2, 3, 5, 7}
odds = {1, 3, 5, 7, 9}
</pre>


<p>اگر با ریاضیات مجموعه‌ها آشنا باشید، با عملیاتی مانند اجتماع (union)، اشتراک (intersection)، تفاضل (difference)، تفاضل متقارن (symmetric difference) و دیگر عملیات آشنا هستید. ست‌های پایتون همه این عملیات را به‌صورت داخلی ارائه می‌کنند، از طریق متدها یا عملگرها. برای هر کدام، دو روش معادل آن‌ها را نشان خواهیم داد:</p>


<pre dir=ltr>
<font color=white>
# union: items appearing in either
primes | odds      # with an operator
primes.union(odds) # equivalently with a method
</pre>
<p dir=ltr>{1, 2, 3, 5, 7, 9}</p>


<pre dir=ltr>
<font color=white>
# intersection: items appearing in both
primes & odds             # with an operator
primes.intersection(odds) # equivalently with a method
</pre>
<p dir=ltr>{3, 5, 7}</p>


<pre dir=ltr>
<font color=white>
# difference: items in primes but not in odds
primes - odds           # with an operator
primes.difference(odds) # equivalently with a method
</pre>
<p dir=ltr>{2}</p>


<pre dir=ltr>
<font color=white>

# symmetric difference: items appearing in only one set
primes ^ odds                     # with an operator
primes.symmetric_difference(odds) # equivalently with a method
</pre>
<p dir=ltr>{1, 2, 9}</p>


<p>متدها و عملیات‌های بیشتری برای ست‌ها در دسترس است. احتمالاً حدس زده‌اید که چه خواهم گفت: برای مرجع کامل، به <a href=https://docs.python.org/3/library/stdtypes.html>مستندات آنلاین پایتون</a> مراجعه کنید.</p>


<h2>ساختارهای داده‌ای خاص‌تر و تخصصی‌تر</h2>


<p>پایتون شامل چندین ساختار داده‌ای دیگر است که ممکن است برای شما مفید باشد؛ این ساختارها معمولاً در ماژول داخلی collections قرار دارند. ماژول collections به‌طور کامل در <a href=https://docs.python.org/3/library/collections.html>مستندات آنلاین پایتون</a> مستند شده است و می‌توانید درباره اشیاء مختلف موجود در آن اطلاعات بیشتری کسب کنید.</p>


<p>به‌ویژه، من متوجه شده‌ام که موارد زیر گاهی بسیار مفید هستند:</p>


<li><b>collections.namedtuple:</b> مشابه تاپل، اما هر مقدار یک نام مشخص دارد</li>
<li><b>collections.defaultdict:</b> مشابه دیکشنری، اما کلیدهای مشخص‌نشده دارای یک مقدار پیش‌فرض تعیین‌شده توسط کاربر هستند</li>
<li><b>collections.OrderedDict:</b> مشابه دیکشنری، اما ترتیب کلیدها حفظ می‌شود</li>

<br>
<p>زمانی که با انواع مجموعه‌های استاندارد داخلی آشنا شدید، استفاده از این قابلیت‌های گسترش‌یافته بسیار حسی و شهودی خواهد بود و پیشنهاد می‌کنم درباره کاربردهای آن‌ها <a href=https://docs.python.org/3/library/collections.html>مطالعه کنید</a>.</p>



|
<a href="06-انواع داده اسکالر داخلی.md">انواع داده اسکالر داخلی</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="08-دستورات کنترل جریان.md">دستورات کنترل جریان</a>
|


</div>