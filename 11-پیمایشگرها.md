<div dir=rtl>



|
<a href="10-خطاها و استثناها.md">خطاها و استثناها</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="12-تعریف فشرده لیست.md">تعریف فشرده لیست</a>
|


<h1>تکرارشونده‌ها (Iterators)</h1>


<p>اغلب یکی از بخش‌های مهم تحلیل داده، تکرار یک محاسبه مشابه به‌صورت خودکار و بارها و بارها است. برای مثال، ممکن است یک جدول از نام‌ها داشته باشید که بخواهید آن‌ها را به نام و نام خانوادگی تقسیم کنید، یا جدولی از تاریخ‌ها داشته باشید که بخواهید آن‌ها را به یک قالب استاندارد تبدیل کنید. یکی از پاسخ‌های پایتون به این نیاز، استفاده از نحو تکرارشونده‌ها (iterator) است. ما قبلاً این را در تکرارشونده‌ی range دیده‌ایم:</p>


<pre dir=ltr>
<font color=white>
for i in range(10):
    print(i, end=' ')
</pre>
<p dir=ltr>0 1 2 3 4 5 6 7 8 9</p>


<p>در اینجا می‌خواهیم کمی عمیق‌تر بررسی کنیم. مشخص می‌شود که در پایتون ۳، range یک لیست نیست، بلکه چیزی به نام تکرارشونده (iterator) است و یادگیری نحوه‌ی کار آن، کلید درک طیف وسیعی از قابلیت‌های بسیار مفید پایتون است.</p>



<h2>تکرار روی لیست‌ها (Iterating over lists)</h2>


<p>تکرارشونده‌ها (Iterators) احتمالاً ساده‌ترین حالت برای درک را زمانی دارند که بخواهیم روی یک لیست تکرار کنیم. مثال زیر را در نظر بگیرید:</p>


<pre dir=ltr>
<font color=white>
for value in [2, 4, 6, 8, 10]:
    # do some operation
    print(value + 1, end=' ')
</pre>
<p dir=ltr>3 5 7 9 11 </p>


<p>نحو آشنای <kbd>for x in y</kbd> به ما اجازه می‌دهد یک عملیات را برای هر مقدار موجود در لیست تکرار کنیم. این‌که نحو کد تا حد زیادی شبیه توصیف آن به زبان انگلیسی باشد («برای [هر] مقدار در [لیست]») تنها یکی از انتخاب‌های نحوی است که پایتون را به زبانی بسیار شهودی برای یادگیری و استفاده تبدیل می‌کند.</p>


<p>اما رفتار ظاهری همان چیزی نیست که واقعاً رخ می‌دهد. وقتی چیزی مانند <kbd>for val in L</kbd> می‌نویسید، مفسر پایتون بررسی می‌کند که آیا L دارای رابط تکرارشونده (iterator interface) است یا خیر، و شما می‌توانید خودتان این موضوع را با استفاده از تابع داخلی iter بررسی کنید:</p>


<pre dir=ltr>
<font color=white>
iter([2, 4, 6, 8, 10])
</pre>
<p dir=ltr><'list_iterator at 0x104722400'></p>


<p>همین شیء تکرارشونده (iterator) است که قابلیت‌های مورد نیاز حلقه for را فراهم می‌کند. شیء iter یک ظرف (container) است که دسترسی به شیء بعدی را تا زمانی که معتبر باشد، در اختیار شما قرار می‌دهد، و این را می‌توان با استفاده از تابع داخلی next مشاهده کرد:</p>



<pre dir=ltr>
<font color=white>
I = iter([2, 4, 6, 8, 10])
</pre>


<pre dir=ltr>
<font color=white>
print(next(I))
</pre>
<p dir=ltr>2</p>


<pre dir=ltr>
<font color=white>
print(next(I))
</pre>
<p dir=ltr>4</p>


<pre dir=ltr>
<font color=white>
print(next(I))
</pre>
<p dir=ltr>6</p>


<p>هدف از این سطح از واسطه‌گری چیست؟ در واقع، این ویژگی بسیار مفید است، زیرا به پایتون اجازه می‌دهد چیزهایی را به‌عنوان لیست در نظر بگیرد که در واقع لیست نیستند.</p>


<h2>range(): لیست همیشه یک لیست نیست</h2>


<p>شاید رایج‌ترین مثال از این تکرار غیرمستقیم، تابع <span dir=ltr>range()</span> در پایتون ۳ باشد (که در پایتون ۲ با نام <span dir=ltr>xrange()</span> شناخته می‌شد)، که به جای یک لیست، یک شیء ویژه‌ی <span dir=ltr>range()</span> بازمی‌گرداند:</p>



<pre dir=ltr>
<font color=white>
range(10)
</pre>
<p dir=ltr>range(0, 10)</p>


<p>range، مانند یک لیست، یک تکرارشونده (iterator) را ارائه می‌دهد:</p>



<pre dir=ltr>
<font color=white>
iter(range(10))
</pre>
<p dir=ltr><'range_iterator at 0x1045a1810'></p>


<p>بنابراین پایتون می‌داند که باید آن را طوری رفتار کند که گویی یک لیست است:</p>




<pre dir=ltr>
<font color=white>
for i in range(10):
    print(i, end=' ')
</pre>
<p dir=ltr>0 1 2 3 4 5 6 7 8 9</p>


<p>مزیت واسطه‌گری تکرارشونده این است که لیست کامل هرگز به‌طور صریح ایجاد نمی‌شود! می‌توانیم این موضوع را با انجام یک محاسبه range ببینیم که اگر واقعاً آن را ایجاد می‌کردیم، حافظه سیستم ما را پر می‌کرد (توجه داشته باشید که در پایتون ۲، range یک لیست ایجاد می‌کند، بنابراین اجرای مثال زیر نتایج خوبی نخواهد داشت!):</p>



<pre dir=ltr>
<font color=white>
N = 10 ** 12
for i in range(N):
    if i >= 10: break
    print(i, end=', ')
</pre>
<p dir=ltr>0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</p>


<p>اگر range واقعاً آن لیست یک تریلیون مقداری را ایجاد می‌کرد، ده‌ها ترابایت از حافظه‌ی سیستم را اشغال می‌کرد: اتلافی بیهوده، با توجه به این که ما همه‌ی مقادیر به جز ده مقدار اول را نادیده می‌گیریم!</p>


<p>در واقع، هیچ دلیلی وجود ندارد که تکرارشونده‌ها حتماً باید پایان داشته باشند! کتابخانه itertools پایتون شامل تابع count است که مانند یک range بی‌نهایت عمل می‌کند:</p>



<pre dir=ltr>
<font color=white>
from itertools import count

for i in count():
    if i >= 10:
        break
    print(i, end=', ')
</pre>
<p dir=ltr>0, 1, 2, 3, 4, 5, 6, 7, 8, 9,</p>


<p>اگر در اینجا حلقه را متوقف نمی‌کردیم، این شمارش با خوشحالی ادامه پیدا می‌کرد تا زمانی که فرایند به‌صورت دستی متوقف یا خاتمه داده شود (برای مثال با استفاده از Ctrl-C).</p>


<h2>تکرارشونده‌های مفید (Useful Iterators)</h2>


<p>این نحو تکرارشونده تقریباً به‌طور جهانی در انواع داده‌های داخلی پایتون و همچنین در اشیاء ویژه‌ی علم داده که در بخش‌های بعدی بررسی خواهیم کرد، استفاده می‌شود. در اینجا برخی از تکرارشونده‌های مفید در زبان پایتون را معرفی می‌کنیم:</p>


<h3>enumerate</h3>


<p>اغلب نیاز دارید که نه تنها روی مقادیر یک آرایه تکرار کنید، بلکه شاخص آن‌ها را نیز دنبال کنید. ممکن است وسوسه شوید که این کار را به این شکل انجام دهید:</p>


<pre dir=ltr>
<font color=white>
L = [2, 4, 6, 8, 10]
for i in range(len(L)):
    print(i, L[i])
</pre>
<p dir=ltr>0 2<br>
1 4<br>
2 6<br>
3 8<br>
4 10</p>


<p>اگرچه این روش کار می‌کند، پایتون یک نحو تمیزتر با استفاده از تکرارشونده‌ی enumerate ارائه می‌دهد:</p>


<pre dir=ltr>
<font color=white>
for i, val in enumerate(L):
    print(i, val)
</pre>
<p dir=ltr>0 2<br>
1 4<br>
2 6<br>
3 8<br>
4 10</p>


<p>این روش، شکل «پایتونیک‌تر» برای شمارش شاخص‌ها و مقادیر در یک لیست است.</p>


<h3>zip</h3>


<p>گاهی اوقات ممکن است چندین لیست داشته باشید که بخواهید هم‌زمان روی آن‌ها تکرار کنید. مطمئناً می‌توانستید مانند مثال غیرپایتونیک قبلی روی شاخص‌ها تکرار کنید، اما بهتر است از تکرارشونده‌ی zip استفاده کنید که چندین Iterable را به هم می‌چسباند:</p>



<pre dir=ltr>
<font color=white>
L = [2, 4, 6, 8, 10]
R = [3, 6, 9, 12, 15]
for lval, rval in zip(L, R):
    print(lval, rval)
</pre>
<p dir=ltr>
2 3<br>
4 6<br>
6 9<br>
8 12<br>
10 15</p>


<p>هر تعداد از Iterable‌ها می‌توانند با هم zip شوند، و اگر طول آن‌ها متفاوت باشد، کوتاه‌ترین آن‌ها طول خروجی zip را تعیین می‌کند.</p>


<h3>map و filter
</h3>


<p>تکرارشونده‌ی map یک تابع می‌گیرد و آن را روی مقادیر موجود در یک تکرارشونده اعمال می‌کند:</p>


<pre dir=ltr>
<font color=white>
# find the first 10 square numbers
square = lambda x: x ** 2
for val in map(square, range(10)):
    print(val, end=' ')
</pre>
<p dir=ltr>0 1 4 9 16 25 36 49 64 81</p>



<p>تکرارشونده‌ی filter شبیه map است، با این تفاوت که تنها مقادیری را عبور می‌دهد که تابع فیلتر برای آن‌ها مقدار True برگرداند:</p>


<pre dir=ltr>
<font color=white>
# find values up to 10 for which x % 2 is zero
is_even = lambda x: x % 2 == 0
for val in filter(is_even, range(10)):
    print(val, end=' ')
</pre>
<p dir=ltr>0 2 4 6 8</p>


<p>توابع map و filter، همراه با تابع reduce (که در ماژول functools پایتون قرار دارد)، از اجزای بنیادی سبک برنامه‌نویسی تابعی (functional programming) هستند. اگرچه این سبک برنامه‌نویسی در دنیای پایتون غالب نیست، طرفداران پرشماری دارد (برای مثال به کتابخانه‌ی <a href=https://toolz.readthedocs.org/en/latest/>pytoolz</a> مراجعه کنید).</p>


<h3>تکرارشونده‌ها به‌عنوان آرگومان تابع (Iterators as function arguments)</h3>


<p>همان‌طور که در بخش *args و **kwargs: آرگومان‌های انعطاف‌پذیر دیدیم، می‌توان از *args و **kwargs برای ارسال دنباله‌ها و دیکشنری‌ها به توابع استفاده کرد. مشخص شد که نحو *args تنها با دنباله‌ها کار نمی‌کند، بلکه با هر تکرارشونده‌ای نیز قابل استفاده است:</p>


<pre dir=ltr>
<font color=white>
print(*range(10))
</pre>
<p dir=ltr>0 1 2 3 4 5 6 7 8 9</p>


<p>بنابراین، به‌عنوان مثال، می‌توانیم کمی خلاقیت به خرج دهیم و مثال map قبلی را به شکل زیر فشرده کنیم:</p>



<pre dir=ltr>
<font color=white>
print(*map(lambda x: x ** 2, range(10)))
</pre>
<p dir=ltr>0 1 4 9 16 25 36 49 64 81</p>


<p>استفاده از این ترفند به ما اجازه می‌دهد به سؤال قدیمی که در انجمن‌های یادگیرندگان پایتون مطرح می‌شود پاسخ دهیم: چرا تابع <span dir=ltr>unzip()</span> که عکس <span dir=ltr>zip()</span> عمل کند وجود ندارد؟ اگر خودتان را در یک کمد تاریک حبس کنید و کمی درباره‌ی آن فکر کنید، ممکن است متوجه شوید که عکس <span dir=ltr>zip()</span> همان… <span dir=ltr>zip()</span> است! نکته کلیدی این است که <span dir=ltr>zip()</span> می‌تواند هر تعداد تکرارشونده یا دنباله را به هم بچسباند. توجه کنید:</p>


<pre dir=ltr>
<font color=white>
L1 = (1, 2, 3, 4)
L2 = ('a', 'b', 'c', 'd')
</pre>



<pre dir=ltr>
<font color=white>
z = zip(L1, L2)
print(*z)
</pre>
<p dir=ltr>(1, 'a') (2, 'b') (3, 'c') (4, 'd')</p>


<pre dir=ltr>
<font color=white>
z = zip(L1, L2)
new_L1, new_L2 = zip(*z)
print(new_L1, new_L2)
</pre>
<p dir=ltr>(1, 2, 3, 4) ('a', 'b', 'c', 'd')</p>


<p>برای مدتی به این موضوع فکر کنید. اگر بفهمید چرا این روش کار می‌کند، قدم بزرگی در درک تکرارشونده‌های پایتون برداشته‌اید!</p>



<h2>تکرارشونده‌های تخصصی: itertools</h2>


<p>ما کمی به تکرارشونده‌ی بی‌نهایت itertools.count نگاه کردیم. ماژول itertools مجموعه‌ای کامل از تکرارشونده‌های مفید را در خود دارد؛ ارزش دارد که این ماژول را بررسی کنید تا ببینید چه امکاناتی در دسترس است. به‌عنوان مثال، تابع itertools.permutations را در نظر بگیرید که روی تمام جایگشت‌های یک دنباله تکرار می‌کند:</p>


<pre dir=ltr>
<font color=white>
from itertools import permutations
p = permutations(range(3))
print(*p)
</pre>
<p dir=ltr>(0, 1, 2) (0, 2, 1) (1, 0, 2) (1, 2, 0) (2, 0, 1) (2, 1, 0)</p>


<p>به‌طور مشابه، تابع itertools.combinations روی تمام ترکیب‌های یکتا شامل N مقدار از یک لیست تکرار می‌کند:</p>


<pre dir=ltr>
<font color=white>
from itertools import combinations
c = combinations(range(4), 2)
print(*c)
</pre>
<p dir=ltr>(0, 1) (0, 2) (0, 3) (1, 2) (1, 3) (2, 3)</p>


<p>تا حدی مرتبط، تکرارشونده‌ی product است که روی تمام مجموعه‌های جفت بین دو یا چند Iterable تکرار می‌کند:</p>



<pre dir=ltr>
<font color=white>
from itertools import product
p = product('ab', range(3))
print(*p)
</pre>
<p dir=ltr>('a', 0) ('a', 1) ('a', 2) ('b', 0) ('b', 1) ('b', 2)</p>


<p>تکرارشونده‌های مفید بیشتری در itertools وجود دارند: فهرست کامل آن‌ها همراه با چند مثال را می‌توانید در <a href=https://docs.python.org/3.5/library/itertools.html>مستندات آنلاین پایتون</a> پیدا کنید.</p>



|
<a href="10-خطاها و استثناها.md">خطاها و استثناها</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="12-تعریف فشرده لیست.md">تعریف فشرده لیست</a>
|



</div>