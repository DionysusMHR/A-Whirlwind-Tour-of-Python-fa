<div dir=rtl>



|
<a href="14-ماژول‌ها و بسته‌ها.md">ماژول‌ها و بسته ها</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="16-معرفی ابزارهای علم داده.md">معرفی ابزارهای علم داده</a>
|



<h1>دست‌کاری رشته‌ها و عبارات باقاعده (Regular Expressions)</h1>


<p>یکی از حوزه‌هایی که زبان پایتون واقعاً در آن می‌درخشد، دست‌کاری رشته‌ها است. در این بخش، ابتدا تعدادی از متدهای توکار رشته‌ها و عملیات قالب‌بندی (Formatting) در پایتون را مرور می‌کنیم و سپس به یک راهنمای سریع دربارهٔ موضوع بسیار کاربردیِ عبارات باقاعده (Regular Expressions) می‌پردازیم.
</p>


<p>چنین الگوهای دست‌کاری رشته‌ای، در کارهای حوزهٔ علم داده بسیار دیده می‌شوند و یکی از مزیت‌های مهم پایتون در این زمینه محسوب می‌شوند.</p>


<p>در پایتون، رشته‌ها را می‌توان با تک‌گیومه یا دگیومه تعریف کرد (از نظر کارکردی هیچ تفاوتی با هم ندارند):</p>




<pre dir=ltr>
<font color=white>
x = 'a string'
y = "a string"
x == y
</pre>
<p dir=ltr>True</p>


<p>علاوه بر این، می‌توان رشته‌های چندخطی را با استفاده از سینتکس سه‌گیومه تعریف کرد:</p>


<pre dir=ltr>
<font color=white>
multiline = """
one
two
three
"""
</pre>


<p>با این توضیحات، بیایید یک مرور سریع بر برخی ابزارهای پایتون برای دست‌کاری رشته‌ها داشته باشیم.</p>


<h2>دست‌کاری سادهٔ رشته‌ها در پایتون</h2>


<p>برای دست‌کاری‌های پایه‌ایِ رشته‌ها، متدهای توکار رشته در پایتون می‌توانند بسیار کارآمد باشند. اگر پیش‌زمینه‌ای در کار با C یا سایر زبان‌های سطح پایین داشته باشید، احتمالاً سادگی این متدها در پایتون برایتان بسیار دلپذیر و غافلگیرکننده خواهد بود.
</p>


<p>پیش‌تر نوع دادهٔ رشته (string) در پایتون و چند مورد از این متدها را معرفی کردیم؛ در این بخش کمی عمیق‌تر به آن‌ها می‌پردازیم.</p>


<h3>قالب‌بندی رشته‌ها: تنظیم حروف کوچک و بزرگ (Case Adjustment)</h3>


<p>پایتون کارِ تنظیم حالت حروف یک رشته (بزرگ/کوچک کردن) را بسیار ساده می‌کند. در این بخش، متدهای
<span dir=ltr>upper()، lower()، capitalize()، title() و swapcase()</span> را بررسی می‌کنیم و از رشتهٔ به‌هم‌ریختهٔ زیر به‌عنوان مثال استفاده خواهیم کرد:</p>


<pre dir=ltr>
<font color=white>
fox = "tHe qUICk bROWn fOx."
</pre>


<p>برای تبدیل کل رشته به حروف بزرگ یا حروف کوچک، می‌توانید به‌ترتیب از متدهای <span dir=ltr>upper() و lower()</span> استفاده کنید:</p>


<pre dir=ltr>
<font color=white>
fox.upper()
</pre>
<p dir=ltr>'THE QUICK BROWN FOX.'</p>


<pre dir=ltr>
<font color=white>
fox.lower()
</pre>
<p dir=ltr>'the quick brown fox.'</p>


<p>یکی از نیازهای رایج در قالب‌بندی رشته‌ها، بزرگ کردن تنها حرف اول هر کلمه یا حرف اول هر جمله است. این کار را می‌توان با متدهای <span dir=ltr>title() و capitalize()</span> انجام داد:</p>


<pre dir=ltr>
<font color=white>
fox.title()
</pre>
<p dir=ltr>'The Quick Brown Fox.'</p>



<pre dir=ltr>
<font color=white>
fox.capitalize()
</pre>
<p dir=ltr>'The quick brown fox.'</p>



<p>می‌توان حالت حروف را با استفاده از متد <span dir=ltr>swapcase()</span> معکوس کرد:</p>


<pre dir=ltr>
<font color=white>
fox.swapcase()
</pre>
<p dir=ltr>'ThE QuicK BrowN FoX.'</p>



<h3>قالب‌بندی رشته‌ها: اضافه و حذف فاصله‌ها (Spaces)</h3>


<p>یکی دیگر از نیازهای رایج، حذف فاصله‌ها (یا سایر کاراکترها) از ابتدای یا انتهای رشته است. متد پایه برای این کار، <span dir=ltr>strip()</span> است که فاصله‌های سفید (whitespace) را از ابتدای و انتهای رشته حذف می‌کند:</p>



<pre dir=ltr>
<font color=white>
line = '         this is the content         '
line.strip()
</pre>
<p dir=ltr>'this is the content'</p>


<p>برای حذف فاصله تنها از سمت راست یا سمت چپ، به‌ترتیب از متدهای <span dir=ltr>rstrip() و lstrip()</span> استفاده کنید:</p>


<pre dir=ltr>
<font color=white>
line.rstrip()
</pre>

<style>    .code {
    	white-space: pre;
    }
</style>
<p dir=ltr class=code>'         this is the content'</p>



<pre dir=ltr>
<font color=white>
line.lstrip()
</pre>
<p dir=ltr class=code>'this is the content         '</p>


<p>برای حذف کاراکترهایی غیر از فاصله، می‌توانید کاراکتر موردنظر را به متد <span dir=ltr>strip()</span> بدهید:</p>



<pre dir=ltr>
<font color=white>
num = "000000000000435"
num.strip('0')
</pre>
<p dir=ltr class=code>'435'</p>


<p>عمل عکس این عملیات، یعنی اضافه کردن فاصله‌ها یا سایر کاراکترها، را می‌توان با استفاده از متدهای <span dir=ltr>center()، ljust() و rjust()</span> انجام داد.</p>


<p>برای مثال، می‌توانیم از متد <span dir=ltr>center()</span> استفاده کنیم تا یک رشتهٔ داده‌شده را در وسط تعداد مشخصی فاصله قرار دهیم:</p>




<pre dir=ltr>
<font color=white>
line = "this is the content"
line.center(30)
</pre>
<p dir=ltr class=code>'     this is the content      '</p>


<p>به‌طور مشابه، متدهای <span dir=ltr>ljust() و rjust()</span> رشته را به‌ترتیب چپ‌چین یا راست‌چین می‌کنند، در حالی که طول کل رشته با فاصله‌های مشخص تنظیم می‌شود:</p>


<pre dir=ltr>
<font color=white>
line.ljust(30)
</pre>
<p dir=ltr class=code>'this is the content           '</p>


<pre dir=ltr>
<font color=white>
line.rjust(30)
</pre>
<p dir=ltr class=code>'           this is the content'</p>


<p>تمام این متدها همچنین می‌توانند هر کاراکتری را برای پر کردن فاصله‌ها دریافت کنند. برای مثال:</p>


<pre dir=ltr>
<font color=white>
'435'.rjust(10, '0')
</pre>
<p dir=ltr class=code>'0000000435'</p>


<p>از آن‌جایی که پر کردن رشته با صفر (zero-filling) یک نیاز رایج است، پایتون متد ویژه‌ای به نام <span dir=ltr>zfill()</span> نیز ارائه می‌دهد که رشته را از سمت راست با صفر پر می‌کند:</p>




<pre dir=ltr>
<font color=white>
'435'.zfill(10)
</pre>
<p dir=ltr class=code>'0000000435'</p>


<h3>یافتن و جایگزینی زیررشته‌ها (Substrings)</h3>


<p>اگر بخواهید مکان وقوع یک کاراکتر یا زیررشته خاص را در یک رشته پیدا کنید، بهترین متدهای توکار پایتون عبارت‌اند از: <span dir=ltr>find() / rfind()، index() / rindex() و replace()</span>.</p>



<p>متدهای <span dir=ltr>find() و index()</span> بسیار مشابه‌اند؛ هر دو اولین وقوع یک کاراکتر یا زیررشته را در رشته جستجو می‌کنند و شاخص (index) زیررشته را بازمی‌گردانند:</p>



<pre dir=ltr>
<font color=white>
line = 'the quick brown fox jumped over a lazy dog'
line.find('fox')
</pre>
<p dir=ltr class=code>16</p>


<pre dir=ltr>
<font color=white>
line.index('fox')
</pre>
<p dir=ltr class=code>16</p>


<p>تنها تفاوت بین <span dir=ltr>find() و index()</span> در رفتار آن‌ها زمانی است که رشتهٔ مورد جستجو یافت نشود؛
<span dir=ltr>find()</span>  مقدار <span dir=ltr>-1</span>  را بازمی‌گرداند، در حالی که <span dir=ltr>index()</span>  یک ValueError ایجاد می‌کند:</p>



<pre dir=ltr>
<font color=white>
line.find('bear')
</pre>
<p dir=ltr class=code>-1</p>



<pre dir=ltr>
<font color=white>
line.index('bear')
</pre>



<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-21-4cbe6ee9b0eb> in <module>()
----> 1 line.index('bear')

ValueError: substring not found
</pre>



<p>متدهای مرتبط <span dir=ltr>rfind() و rindex()</span> نیز به‌طور مشابه عمل می‌کنند، با این تفاوت که جستجو را از انتهای رشته به سمت ابتدا انجام می‌دهند، نه از ابتدای رشته:</p>



<pre dir=ltr>
<font color=white>
line.rfind('a')
</pre>
<p dir=ltr class=code>35</p>



<p>برای حالت خاص بررسی وجود یک زیررشته در ابتدای یا انتهای رشته، پایتون متدهای <span dir=ltr>startswith() و endswith()</span> را ارائه می‌دهد:</p>


<pre dir=ltr>
<font color=white>
line.endswith('dog')
</pre>
<p dir=ltr class=code>True</p>



<pre dir=ltr>
<font color=white>
line.startswith('fox')
</pre>
<p dir=ltr class=code>False</p>


<p>برای قدم بعدی و جایگزینی یک زیررشته با رشتهٔ جدید، می‌توانید از متد <span dir=ltr>replace()</span> استفاده کنید.
در این مثال، می‌خواهیم 'brown' را با 'red' جایگزین کنیم:</p>


<pre dir=ltr>
<font color=white>
line.replace('brown', 'red')
</pre>
<p dir=ltr class=code>'the quick red fox jumped over a lazy dog'</p>



<p>متد <span dir=ltr>replace()</span> یک رشتهٔ جدید بازمی‌گرداند و تمام وقوع‌های زیررشتهٔ ورودی را جایگزین می‌کند:</p>




<pre dir=ltr>
<font color=white>
line.replace('o', '--')
</pre>
<p dir=ltr class=code>'the quick br--wn f--x jumped --ver a lazy d--g'</p>


<p>برای یک رویکرد انعطاف‌پذیرتر نسبت به عملکرد <span dir=ltr>replace()</span>، می‌توانید به بخش عبارات باقاعده و الگویابی انعطاف‌پذیر (Flexible Pattern Matching with Regular Expressions)مراجعه کنید.</p>



<h3>تقسیم و بخش‌بندی رشته‌ها (Splitting and Partitioning Strings)</h3>


<p>اگر می‌خواهید یک زیررشته را پیدا کرده و رشته را بر اساس موقعیت آن تقسیم کنید، متدهای <span dir=ltr>partition() و/یا split()</span> ابزار مناسب شما هستند. هر دو یک دنباله‌ای از زیررشته‌ها را بازمی‌گردانند.</p>



<p>متد <span dir=ltr>partition()</span> یک تاپل با سه عنصر بازمی‌گرداند:</p>
<li>زیررشته قبل از اولین وقوع نقطهٔ تقسیم</li>
<li>خود نقطهٔ تقسیم</li>
<li>زیررشته بعد از نقطهٔ تقسیم</li>



<pre dir=ltr>
<font color=white>
line.partition('fox')
</pre>
<p dir=ltr class=code>('the quick brown ', 'fox', ' jumped over a lazy dog')</p>



<p>متد <span dir=ltr>rpartition()</span> مشابه است، با این تفاوت که جستجو را از سمت راست رشته انجام می‌دهد.</p>



<p>متد <span dir=ltr>split()</span> احتمالاً کاربردی‌تر است؛ این متد تمام وقوع‌های نقطهٔ تقسیم را پیدا کرده و زیررشته‌های بین آن‌ها را بازمی‌گرداند. حالت پیش‌فرض، تقسیم بر هر فاصلهٔ سفید (whitespace) است و یک لیست از کلمات جداگانهٔ رشته را بازمی‌گرداند:</p>


<pre dir=ltr>
<font color=white>
line.split()
</pre>
<p dir=ltr class=code>['the', 'quick', 'brown', 'fox', 'jumped', 'over', 'a', 'lazy', 'dog']</p>



<p>متد مرتبط <span dir=ltr>splitlines()</span> است که رشته را بر اساس کاراکترهای خط جدید (newline) تقسیم می‌کند.
</p>


<p>بیایید این کار را با یک هایکو انجام دهیم که به شاعر قرن هفدهم، ماتسوئو باشو (Matsuo Bashō) نسبت داده می‌شود:</p>



<pre dir=ltr>
<font color=white>
haiku = """matsushima-ya
aah matsushima-ya
matsushima-ya"""

haiku.splitlines()
</pre>
<p dir=ltr class=code>['matsushima-ya', 'aah matsushima-ya', 'matsushima-ya']</p>



<p>توجه داشته باشید که اگر بخواهید عملیات <span dir=ltr>split()</span> را معکوس کنید، می‌توانید از متد <span dir=ltr>join()</span> استفاده کنید، که یک رشته ایجاد شده از نقطهٔ اتصال (split-point) و یک iterable را بازمی‌گرداند:</p>


<pre dir=ltr>
<font color=white>
'--'.join(['1', '2', '3'])
</pre>
<p dir=ltr class=code>'1--2--3'</p>


<p>یک الگوی رایج، استفاده از کاراکتر ویژه <span dir=ltr>\n</span> (خط جدید) برای وصل کردن دوباره خطوطی است که قبلاً با split جدا شده‌اند و بازگرداندن رشتهٔ اصلی:</p>



<pre dir=ltr>
<font color=white>
print("\n".join(['matsushima-ya', 'aah matsushima-ya', 'matsushima-ya']))
</pre>
<p dir=ltr class=code>matsushima-ya<br>
aah matsushima-ya<br>
matsushima-ya</p>



<h2>قالب‌بندی رشته‌ها (Format Strings)</h2>



<p>در روش‌های قبلی، یاد گرفتیم که چگونه مقادیر را از رشته‌ها استخراج کنیم و خود رشته‌ها را به قالب‌های دلخواه درآوریم.
کاربرد دیگر متدهای رشته، دست‌کاری نمایش رشته‌ای مقادیر از نوع‌های دیگر است.
البته، همیشه می‌توان نمایش رشته‌ای یک مقدار را با استفاده از تابع <span dir=ltr>str()</span> به‌دست آورد؛ برای مثال:</p>



<pre dir=ltr>
<font color=white>
pi = 3.14159
str(pi)
</pre>
<p dir=ltr class=code>'3.14159'</p>


<p>برای قالب‌بندی‌های پیچیده‌تر، ممکن است وسوسه شوید که از عملیات ریاضی روی رشته‌ها استفاده کنید، همان‌طور که در بخش  <a href="05-معناشناسی پایتون: عملگرها.md">معناشناسی پایتون: عملگرها</a> توضیح داده شد:</p>


<pre dir=ltr>
<font color=white>
"The value of pi is " + str(pi)
</pre>
<p dir=ltr class=code>'The value of pi is 3.14159'</p>


<p>یک روش انعطاف‌پذیرتر برای این کار، استفاده از رشته‌های قالب‌بندی (format strings) است؛ این رشته‌ها شامل نشانه‌های ویژه (با آکولاد {} مشخص می‌شوند) هستند که مقادیر قالب‌بندی‌شده به رشته در آن‌ها قرار می‌گیرند.
در اینجا یک مثال پایه آورده شده است:</p>


<pre dir=ltr>
<font color=white>
"The value of pi is {}".format(pi)
</pre>
<p dir=ltr class=code>'The value of pi is 3.14159'</p>



<p>درون نشانهٔ {} می‌توانید اطلاعات دقیق دربارهٔ آنچه می‌خواهید نمایش داده شود را نیز وارد کنید.
اگر یک عدد وارد کنید، به شاخص آرگومان مورد نظر برای قرارگیری مقدار اشاره خواهد داشت:</p>



<pre dir=ltr>
<font color=white>
"""First letter: {0}. Last letter: {1}.""".format('A', 'Z')
</pre>
<p dir=ltr class=code>'First letter: A. Last letter: Z.'</p>



<p>اگر یک رشته وارد کنید، به کلید (key) هر آرگومان کلیدی (keyword argument) اشاره خواهد داشت:</p>




<pre dir=ltr>
<font color=white>
"""First letter: {first}. Last letter: {last}.""".format(last='Z', first='A')
</pre>
<p dir=ltr class=code>'First letter: A. Last letter: Z.'</p>


<p>در نهایت، برای ورودی‌های عددی، می‌توانید کدهای قالب‌بندی (format codes) را وارد کنید که تعیین می‌کنند مقدار چگونه به رشته تبدیل شود.
برای مثال، برای چاپ یک عدد به صورت اعشاری با سه رقم بعد از نقطهٔ اعشار، می‌توانید از روش زیر استفاده کنید:</p>


<pre dir=ltr>
<font color=white>
"pi = {0:.3f}".format(pi)
</pre>
<p dir=ltr class=code>'pi = 3.142'</p>


<p>همانند قبل، عدد 0 به شاخص مقداری که قرار است درج شود اشاره دارد. علامت : نشان می‌دهد که کدهای قالب‌بندی دنبال خواهند شد.
<span dir=ltr>.3f</span> دقت موردنظر را مشخص می‌کند: سه رقم بعد از نقطهٔ اعشار، و قالب اعداد اعشاری (floating-point).</p>



<p>این سبک تعریف قالب‌بندی بسیار انعطاف‌پذیر است و مثال‌های ارائه‌شده تنها سطح ابتدایی گزینه‌های قالب‌بندی را پوشش می‌دهند.
برای اطلاعات بیشتر در مورد سینتکس رشته‌های قالب‌بندی، به بخش <a href=https://docs.python.org/3/library/string.html#formatspec>Format Specification</a> در مستندات آنلاین پایتون مراجعه کنید.</p>



<h2>الگویابی انعطاف‌پذیر با عبارات باقاعده (Regular Expressions)</h2>


<p>متدهای نوع دادهٔ str در پایتون مجموعه‌ای قدرتمند از ابزارها برای قالب‌بندی، تقسیم و دست‌کاری رشته‌ها در اختیار شما قرار می‌دهند.
اما ابزارهای قدرتمندتری نیز در ماژول عبارات باقاعده (regular expression) توکار پایتون موجود است.
عبارات باقاعده موضوع بسیار گسترده‌ای هستند؛ حتی کتاب‌های کاملی دربارهٔ آن‌ها نوشته شده است (از جمله Mastering Regular Expressions اثر Jeffrey E.F. Friedl، ویرایش سوم)، بنابراین پوشش کامل آن در یک زیرقسمت، محدود و ناقص خواهد بود.</p>


<p>هدف من در اینجا، ارائهٔ تصوری کلی از نوع مسائلی است که می‌توان با عبارات باقاعده حل کرد و همچنین ایده‌ای پایه دربارهٔ نحوهٔ استفاده از آن‌ها در پایتون است.
برای یادگیری بیشتر، منابعی را در ادامه معرفی خواهم کرد.</p>



<p>به‌طور بنیادی، عبارات باقاعده وسیله‌ای برای الگویابی انعطاف‌پذیر در رشته‌ها هستند.
اگر زیاد از خط فرمان (command-line) استفاده می‌کنید، احتمالاً با این نوع الگویابی انعطاف‌پذیر با کاراکتر * آشنا هستید که به‌عنوان wildcard عمل می‌کند.
برای مثال، می‌توانیم تمام دفترچه‌های IPython (فایل‌هایی با پسوند .ipynb) که در نامشان Python آمده است را با استفاده از wildcard *، که هر کاراکتری را در میان آن‌ها می‌گیرد، فهرست کنیم:</p>




<pre dir=ltr>
<font color=white>
!ls *Python*.ipynb
</pre>
<p dir=ltr class=code>01-How-to-Run-Python-Code.ipynb 02-Basic-Python-Syntax.ipynb</p>


<p>عبارات باقاعده این ایدهٔ wildcard را به یک دامنهٔ گسترده از سینتکس‌های انعطاف‌پذیر برای مطابقت رشته‌ها تعمیم می‌دهند.
رابط پایتون برای عبارات باقاعده در ماژول توکار re قرار دارد؛ به‌عنوان یک مثال ساده، بیایید از آن برای تکرار عملکرد متد <span dir=ltr>split()</span> استفاده کنیم:</p>


<pre dir=ltr>
<font color=white>
import re
regex = re.compile('\s+')
regex.split(line)
</pre>
<p dir=ltr class=code>['the', 'quick', 'brown', 'fox', 'jumped', 'over', 'a', 'lazy', 'dog']</p>




<p>در اینجا، ابتدا یک عبارت باقاعده را کامپایل کرده‌ایم و سپس از آن برای تقسیم یک رشته استفاده کرده‌ایم. همان‌طور که متد <span dir=ltr>split()</span> پایتون لیستی از تمام زیررشته‌ها بین فاصله‌ها بازمی‌گرداند، متد <span dir=ltr>split()</span> در عبارات باقاعده نیز لیستی از تمام زیررشته‌ها بین تطابق‌ها با الگوی ورودی بازمی‌گرداند.</p>



<p>در این مثال، ورودی <span dir=ltr>\s+</span> است:</p>
<li><span dir=ltr>\s</span> یک کاراکتر ویژه است که هر نوع فاصله سفید (فضا، تب، خط جدید و غیره) را مطابقت می‌دهد.</li>
<li>+ نشان‌دهندهٔ یک یا چند مورد از موجودیت قبل از خود است.</li>
<p>بنابراین، این عبارت باقاعده هر زیررشته‌ای که شامل یک یا چند فاصله باشد را پیدا می‌کند.</p>




<p>متد <span dir=ltr>split()</span> در اینجا اساساً یک رویهٔ کمکی است که بر اساس همین رفتار الگویابی ساخته شده است؛
اما متد اساسی‌تر، متد <span dir=ltr>match()</span> است، که اعلام می‌کند آیا ابتدای رشته با الگو مطابقت دارد یا خیر:</p>




<pre dir=ltr>
<font color=white>
for s in ["     ", "abc  ", "  abc"]:
    if regex.match(s):
        print(repr(s), "matches")
    else:
        print(repr(s), "does not match")
</pre>
<p dir=ltr class=code>'     ' matches
'abc  ' does not match
'  abc' matches</p>



<p>مشابه <span dir=ltr>split()</span> ، رویه‌های کمکی مشابهی برای پیدا کردن اولین مطابقت (مانند <span dir=ltr>str.index()</span>  یا <span dir=ltr>str.find()</span> ) یا برای پیدا کردن و جایگزینی (مانند <span dir=ltr>str.replace()</span> ) نیز وجود دارند.
در اینجا دوباره از همان خط قبلی استفاده خواهیم کرد:</p>




<pre dir=ltr>
<font color=white>
line = 'the quick brown fox jumped over a lazy dog'
</pre>




<p>با این روش، می‌توان مشاهده کرد که متد <span dir=ltr>regex.search()</span> بسیار شبیه به <span dir=ltr>str.index()</span> یا <span dir=ltr>str.find()</span> عمل می‌کند:</p>




<pre dir=ltr>
<font color=white>
line.index('fox')
</pre>
<p dir=ltr class=code>16</p>



<pre dir=ltr>
<font color=white>
regex = re.compile('fox')
match = regex.search(line)
match.start()
</pre>
<p dir=ltr class=code>16</p>



<p>به‌طور مشابه، متد <span dir=ltr>regex.sub()</span> بسیار شبیه به <span dir=ltr>str.replace()</span> عمل می‌کند:</p>



<pre dir=ltr>
<font color=white>
line.replace('fox', 'BEAR')
</pre>
<p dir=ltr class=code>'the quick brown BEAR jumped over a lazy dog'</p>




<pre dir=ltr>
<font color=white>
regex.sub('BEAR', line)
</pre>
<p dir=ltr class=code>'the quick brown BEAR jumped over a lazy dog'</p>



<p>با کمی تأمل، می‌توان سایر عملیات توکار روی رشته‌ها را نیز به صورت عبارات باقاعده بازتعریف کرد.</p>



<h3>یک مثال پیشرفته‌تر</h3>



<p>اما ممکن است بپرسید، چرا باید از سینتکس پیچیده و طولانی عبارات باقاعده استفاده کنیم، در حالی که متدهای رشته‌ای ساده و شهودی هستند؟
مزیت عبارات باقاعده این است که انعطاف‌پذیری بسیار بیشتری ارائه می‌دهند.</p>



<p>در اینجا یک مثال پیچیده‌تر را بررسی می‌کنیم: کار رایج مطابقت با آدرس‌های ایمیل.
ابتدا یک عبارت باقاعده نسبتاً پیچیده و دشوار برای خواندن می‌نویسم و سپس قدم‌به‌قدم توضیح می‌دهم که چه اتفاقی می‌افتد.
عبارت به این صورت است:</p>



<pre dir=ltr>
<font color=white>
email = re.compile('\w+@\w+\.[a-z]{3}')
</pre>




<p>با استفاده از این عبارت، اگر یک خط از یک سند داشته باشیم، می‌توانیم به‌سرعت مقادیری که شبیه آدرس ایمیل هستند را استخراج کنیم.</p>



<pre dir=ltr>
<font color=white>
text = "To email Guido, try guido@python.org or the older address guido@google.com."
email.findall(text)
</pre>
<p dir=ltr class=code>['guido@python.org', 'guido@google.com']</p>


<p>(توجه داشته باشید که این آدرس‌ها کاملاً ساختگی هستند؛ احتمالاً روش‌های بهتری برای تماس با Guido وجود دارد).</p>




<p>ما می‌توانیم عملیات‌های بیشتری نیز انجام دهیم؛ برای مثال می‌توانیم این آدرس‌های ایمیل را با یک رشتهٔ دیگر جایگزین کنیم، شاید برای این‌که آدرس‌ها را در خروجی مخفی کنیم:</p>




<pre dir=ltr>
<font color=white>
email.sub('--@--.--', text)
</pre>
<p dir=ltr class=code>'To email Guido, try --@--.-- or the older address --@--.--.'</p>



<p>در نهایت، توجه داشته باشید که اگر واقعاً بخواهید هر آدرس ایمیل ممکن را مطابقت دهید، عبارت باقاعدهٔ قبلی خیلی ساده است.
برای مثال، این عبارت تنها آدرس‌هایی را می‌پذیرد که متشکل از حروف و اعداد باشند و با یکی از چند پسوند دامنهٔ رایج ختم شوند.
بنابراین، برای مثال، نقطه‌ای که در اینجا استفاده شده است به این معنی است که ما فقط بخشی از آدرس را پیدا می‌کنیم:</p>



<pre dir=ltr>
<font color=white>
email.findall('barack.obama@whitehouse.gov')
</pre>
<p dir=ltr class=code>['obama@whitehouse.gov']</p>



<p>این نشان می‌دهد که عبارات باقاعده می‌توانند بسیار سختگیرانه باشند اگر دقت نکنید!
اگر در اینترنت جستجو کنید، می‌توانید برخی پیشنهادها برای عبارات باقاعده‌ای که همهٔ ایمیل‌های معتبر را مطابقت می‌دهند پیدا کنید، اما مراقب باشید: این عبارات بسیار پیچیده‌تر از عبارت ساده‌ای که در اینجا استفاده شد هستند!</p>




<h3>مبانی سینتکس عبارات باقاعده (Basics of Regular Expression Syntax)</h3>




<p>سینتکس عبارات باقاعده موضوع بسیار گسترده‌ای است و نمی‌توان آن را در این بخش کوتاه پوشش داد.
با این حال، آشنایی اولیه می‌تواند بسیار مفید باشد: در اینجا برخی از ساختارهای پایه را بررسی می‌کنم و سپس منابع کامل‌تری را برای یادگیری بیشتر معرفی خواهم کرد.
هدف من این است که این مقدمهٔ سریع به شما کمک کند تا بتوانید از این منابع به‌طور مؤثر استفاده کنید.</p>




<h4>رشته‌های ساده به‌صورت مستقیم مطابقت داده می‌شوند</h4>


<p>اگر یک عبارت باقاعده را بر اساس رشته‌ای ساده از حروف یا اعداد بسازید، دقیقاً با همان رشته مطابقت خواهد داشت:</p>



<pre dir=ltr>
<font color=white>
regex = re.compile('ion')
regex.findall('Great Expectations')
</pre>
<p dir=ltr class=code>['ion']</p>



<h4>برخی از کاراکترها معانی ویژه‌ای دارند</h4>



<p>در حالی که حروف یا اعداد ساده به‌صورت مستقیم مطابقت داده می‌شوند، تعدادی از کاراکترها در عبارات باقاعده معانی ویژه‌ای دارند. این کاراکترها عبارت‌اند از:</p>



<p>.<br> ^<br>  $<br>  *<br>  +<br>  ?<br>  { }<br>  [ ]<br>  \<br>  |<br>  ( )
</p>


<p>به‌زودی دربارهٔ معنی برخی از این کاراکترها صحبت خواهیم کرد.
در همین حال، باید بدانید که اگر بخواهید هر یک از این کاراکترها را به‌صورت مستقیم مطابقت دهید، می‌توانید از کاراکتر بک‌اسلش (\) برای فرار (escape) استفاده کنید:</p>





<pre dir=ltr>
<font color=white>
regex = re.compile(r'\$')
regex.findall("the cost is $20")
</pre>
<p dir=ltr class=code>['$']</p>


<p>پیش‌وند r در <span dir=ltr>r'\$'</span> نشان‌دهندهٔ رشتهٔ خام (raw string) است؛ در رشته‌های استاندارد پایتون، بک‌اسلش برای نشانه‌گذاری کاراکترهای ویژه استفاده می‌شود.
برای مثال، یک تب با <span dir=ltr>"\t"</span> نمایش داده می‌شود:</p>



<pre dir=ltr>
<font color=white>
print('a\tb\tc')
</pre>
<p dir=ltr class=code>a	b	c</p>


<p>در یک رشتهٔ خام (raw string) چنین جایگزینی‌هایی انجام نمی‌شود:</p>




<pre dir=ltr>
<font color=white>
print(r'a\tb\tc')
</pre>
<p dir=ltr class=code>a\tb\tc</p>



<p>به همین دلیل، هر زمان که از بک‌اسلش‌ها در یک عبارت باقاعده استفاده می‌کنید، استفاده از رشتهٔ خام (raw string) توصیه می‌شود.</p>



<h4>کاراکترهای ویژه می‌توانند گروه‌های کاراکتری را مطابقت دهند</h4>



<p>همان‌طور که کاراکتر \ در عبارات باقاعده می‌تواند کاراکترهای ویژه را فرار دهد و آن‌ها را به کاراکترهای معمولی تبدیل کند، می‌تواند به کاراکترهای معمولی نیز معنای ویژه بدهد.
این کاراکترهای ویژه، گروه‌های مشخصی از کاراکترها را مطابقت می‌دهند، و پیش‌تر با آن‌ها آشنا شدیم.
برای مثال، در عبارت باقاعدهٔ ایمیل قبلی، از کاراکتر w\ استفاده کردیم که هر کاراکتر الفبایی-عددی (alphanumeric) را مطابقت می‌دهد.
به‌طور مشابه، در مثال سادهٔ <span dir=ltr>split()</span> نیز با s\ آشنا شدیم، که هر کاراکتر فاصله سفید (whitespace) را نشان می‌دهد.</p>




<p>با ترکیب این موارد، می‌توانیم یک عبارت باقاعده بسازیم که هر دو حرف یا عدد را با یک فاصله سفید بین آن‌ها مطابقت دهد:</p>





<pre dir=ltr>
<font color=white>
regex = re.compile(r'\w\s\w')
regex.findall('the fox is 9 years old')
</pre>
<p dir=ltr class=code>['e f', 'x i', 's 9', 's o']</p>



<p>این مثال قدرت و انعطاف‌پذیری عبارات باقاعده را تا حدی نشان می‌دهد.</p>


<p>جدول زیر، تعدادی از این کاراکترها را که اغلب کاربرد دارند، فهرست می‌کند:</p>


<table>
    <tr>
        <th>کاراکتر</th>
        <th>توضیح</th>
        <th>کاراکتر</th>
        <th>توضیح</th>
    </tr>
    <tr>
        <td>"\d"</td>
        <td>مطابقت با هر رقم</td>
        <td>"\D"</td>
        <td>مطابقت با هر کاراکتر غیررقمی</td>
    </tr>
    <tr>
        <td>"\s"</td>
        <td>مطابقت با هر فاصله سفید</td>
        <td>"\S"</td>
        <td>مطابقت با هر کاراکتر غیر فاصله‌ای</td>
    </tr>
    <tr>
        <td>"\w"</td>
        <td>مطابقت با هر کاراکتر الفبایی-عددی</td>
        <td>"\W"</td>
        <td>مطابقت با هر کاراکتر غیر الفبایی-عددی</td>
    </tr>
</table>



<p>این فهرست و توضیح جامع نیستند؛ برای جزئیات بیشتر، به <a href=https://docs.python.org/3/library/re.html#re-syntax>مستندات سینتکس عبارات باقاعدهٔ</a> پایتون مراجعه کنید.</p>


<h4>براکت‌های مربعی برای مطابقت با گروه‌های کاراکتری دلخواه استفاده می‌شوند</h4>



<p>اگر گروه‌های کاراکتری توکار برای شما کافی نیستند، می‌توانید از براکت‌های مربعی استفاده کنید تا هر مجموعهٔ کاراکتری که مدنظر دارید را مشخص کنید.
برای مثال، عبارت زیر هر حرف صدادار کوچک را مطابقت می‌دهد:</p>



<pre dir=ltr>
<font color=white>
regex = re.compile('[aeiou]')
regex.split('consequential')
</pre>
<p dir=ltr class=code>['c', 'ns', 'q', '', 'nt', '', 'l']</p>


<p>به‌طور مشابه، می‌توانید از خط فاصله (dash) برای مشخص کردن یک بازه استفاده کنید:
برای مثال، [a-z] هر حرف کوچک و [1-3] هر یک از اعداد "1"، "2" یا "3" را مطابقت می‌دهد.
به عنوان نمونه، ممکن است نیاز داشته باشید از یک سند کدهای عددی خاصی را استخراج کنید که شامل یک حرف بزرگ و سپس یک عدد هستند. می‌توانید این کار را به شکل زیر انجام دهید:</p>




<pre dir=ltr>
<font color=white>
regex = re.compile('[A-Z][0-9]')
regex.findall('1043879, G2, H6')
</pre>
<p dir=ltr class=code>['G2', 'H6']</p>



<h4>Wildcardها برای مطابقت با کاراکترهای تکراری استفاده می‌شوند</h4>



<p>اگر بخواهید رشته‌ای را که مثلاً سه کاراکتر الفبایی-عددی پشت سر هم دارد مطابقت دهید، می‌توان به‌طور مثال نوشت: w\w\w\.
از آنجایی که این نیاز خیلی رایج است، سینتکس خاصی برای مطابقت با تکرارها وجود دارد: آکولاد {} همراه با یک عدد:</p>



<pre dir=ltr>
<font color=white>
regex = re.compile(r'\w{3}')
regex.findall('The quick brown fox')
</pre>
<p dir=ltr class=code>['The', 'qui', 'bro', 'fox']</p>



<p>همچنین نشانه‌هایی برای مطابقت با هر تعداد تکرار وجود دارد؛
برای مثال، کاراکتر + یک یا چند تکرار از موجودیت قبل از خود را مطابقت می‌دهد:</p>



<pre dir=ltr>
<font color=white>
regex = re.compile(r'\w+')
regex.findall('The quick brown fox')
</pre>
<p dir=ltr class=code>['The', 'quick', 'brown', 'fox']</p>



<p>جدول زیر، نشانه‌های تکرار (repetition markers) قابل استفاده در عبارات باقاعده را نشان می‌دهد:</p>


<table>
    <tr>
        <th>کاراکتر</th>
        <th>توضیح</th>
        <th>مثال</th>
    </tr>
    <tr>
        <td>?</td>
        <td>با صفر یا یک بار تکرار از الگوی قبلی مطابقت دارد.</td>
        <td dir=ltr>"ab?" matches "a" or "ab"</td>
    </tr>
    <tr>
        <td>*</td>
        <td>با صفر یا بیشتر تکرارهای الگوی قبلی مطابقت دارد.</td>
        <td dir=ltr>"ab*" matches "a", "ab", "abb", "abbb"...</td>
    </tr>
    <tr>
        <td>+</td>
        <td>با یک یا بیشتر تکرارهای الگوی قبلی مطابقت دارد.</td>
        <td dir=ltr>"ab+" matches "ab", "abb", "abbb"... but not "a"</td>
    </tr>
    <tr>
        <td>{n}</td>
        <td>با n بار تکرار الگوی قبلی مطابقت دارد.</td>
        <td dir=ltr>"ab{2}" matches "abb"</td>
    </tr>
    <tr>
        <td>{m.n}</td>
        <td>با تکرارهای بین m تا n از الگوی قبلی مطابقت دارد.</td>
        <td dir=ltr>"ab{2,3}" matches "abb" or "abbb"</td>
    </tr>
</table>



<p>با در نظر گرفتن این مبانی، بیایید به مچ‌کنندهٔ آدرس ایمیل خود بازگردیم:</p>


<pre dir=ltr>
<font color=white>
email = re.compile(r'\w+@\w+\.[a-z]{3}')
</pre>


<p>حال می‌توانیم بفهمیم این عبارت به چه معناست: ما می‌خواهیم یک یا چند کاراکتر الفبایی-عددی (<span dir=ltr>"\w+"</span>) داشته باشیم که به دنبال آن علامت @ بیاید، سپس یک یا چند کاراکتر الفبایی-عددی دیگر (<span dir=ltr>"\w+"</span>)، سپس یک نقطه (".\" – توجه کنید که نیاز به بک‌اسلش برای فرار داریم)، و در نهایت دقیقاً سه حرف کوچک انگلیسی بیاید.</p>



<p>اگر حالا بخواهیم این عبارت را طوری تغییر دهیم که آدرس ایمیل اوباما هم مطابقت داشته باشد، می‌توانیم از نگارش کروشه‌ای (square-bracket) استفاده کنیم:</p>


<pre dir=ltr>
<font color=white>
email2 = re.compile(r'[\w.]+@\w+\.[a-z]{3}')
email2.findall('barack.obama@whitehouse.gov')
</pre>
<p dir=ltr>['barack.obama@whitehouse.gov']</p>




<p>ما <span dir=ltr>"\w+"</span> را به <span dir=ltr>"[\w.]+"</span> تغییر داده‌ایم، بنابراین هر کاراکتر الفبایی-عددی یا یک نقطه را مطابقت می‌دهد. با این عبارت منعطف‌تر، می‌توانیم دامنهٔ وسیع‌تری از آدرس‌های ایمیل را مطابقت دهیم (اگرچه هنوز همه را پوشش نمی‌دهد – آیا می‌توانی سایر محدودیت‌های این عبارت را شناسایی کنی؟).</p>



<h4>پرانتزها نشان‌دهندهٔ گروه‌هایی هستند که می‌توان آن‌ها را استخراج کرد.</h4>



<p>برای عبارت‌های منظم مرکب مانند مچ‌کنندهٔ ایمیل ما، اغلب می‌خواهیم اجزای آن‌ها را استخراج کنیم، نه فقط مطابقت کامل. این کار را می‌توان با استفاده از پرانتزها برای گروه‌بندی نتایج انجام داد:</p>


<pre dir=ltr>
<font color=white>
email3 = re.compile(r'([\w.]+)@(\w+)\.([a-z]{3})')
</pre>




<pre dir=ltr>
<font color=white>
text = "To email Guido, try guido@python.org or the older address guido@google.com."
email3.findall(text)
</pre>
<p dir=ltr>[('guido', 'python', 'org'), ('guido', 'google', 'com')]</p>



<p>همان‌طور که می‌بینیم، این گروه‌بندی در واقع یک لیست از زیرمؤلفه‌های آدرس ایمیل را استخراج می‌کند.</p>



<p>می‌توانیم کمی جلوتر برویم و مؤلفه‌های استخراج‌شده را با استفاده از نگارش <span dir=ltr>"?P<'name'>"</span> نام‌گذاری کنیم، در این صورت گروه‌ها را می‌توان به‌صورت یک دیکشنری پایتون استخراج کرد.</p>



<pre dir=ltr>
<font color=white>
email4 = re.compile(r'(?P<user>[\w.]+)@(?P<domain>\w+)\.(?P<suffix>[a-z]{3})')
match = email4.match('guido@python.org')
match.groupdict()
</pre>
<p dir=ltr>{'domain': 'python', 'suffix': 'org', 'user': 'guido'}</p>



<p>ترکیب این ایده‌ها (همراه با برخی از نگارش‌های قدرتمند عبارت منظم که در اینجا پوشش داده نشده‌اند) به شما امکان می‌دهد به‌صورت انعطاف‌پذیر و سریع اطلاعات را از رشته‌ها در پایتون استخراج کنید.</p>



<h2>منابع بیشتر دربارهٔ عبارت‌های منظم</h2>


<p>بحث فوق تنها یک بررسی سریع (و به هیچ‌وجه کامل) از این موضوع گسترده بود. اگر می‌خواهید بیشتر یاد بگیرید، منابع زیر را توصیه می‌کنم:</p>



<li><a href=https://docs.python.org/3/library/re.html>مستندات پکیج re در پایتون:</a> من معمولاً هر بار که از عبارت‌های منظم استفاده می‌کنم، به‌سرعت فراموش می‌کنم چگونه باید از آن‌ها استفاده کنم. حالا که اصول پایه را یاد گرفته‌ام، این صفحه برایم یک منبع بسیار ارزشمند است تا بتوانم معنای هر کاراکتر یا دنبالهٔ خاص در یک عبارت منظم را به‌خاطر بیاورم.</li>
<li><a href=https://docs.python.org/3/howto/regex.html>راهنمای رسمی پایتون برای عبارت‌های منظم (Regular Expression HOWTO):</a> یک رویکرد روایی‌تر برای یادگیری عبارت‌های منظم در پایتون.</li>
<li><a href=http://shop.oreilly.com/product/9780596528126.do>کتاب Mastering Regular Expressions (انتشارات O'Reilly، ۲۰۰۶)</a> یک کتاب بیش از ۵۰۰ صفحه‌ای در این زمینه است. اگر به دنبال پوشش واقعاً کامل این موضوع هستید، این منبع مناسب شماست.</li>



<p>برای مشاهدهٔ نمونه‌هایی از دست‌کاری رشته‌ها و استفاده از عبارت‌های منظم در مقیاس بزرگ‌تر، به <a href="16-معرفی ابزارهای علم داده.md">16-معرفی ابزارهای علم داده</a> مراجعه کنید، جایی که نحوهٔ اعمال این نوع عبارات روی جداول داده‌های متنی در پکیج Pandas را بررسی می‌کنیم.</p>




|
<a href="14-ماژول‌ها و بسته‌ها.md">ماژول‌ها و بسته ها</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="16-معرفی ابزارهای علم داده.md">معرفی ابزارهای علم داده</a>
|





</div>