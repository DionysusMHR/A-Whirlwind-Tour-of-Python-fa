<div dir=rtl>

|
<a href="09-تعریف توابع.md">تغریف توابع</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="11-پیمایشگرها.md">پیمایشگرها</a>
|



<h1>خطاها و استثناها</h1>


<p>فرقی نمی‌کند مهارتت در برنامه‌نویسی چقدر باشد، در نهایت مرتکب اشتباه کدنویسی خواهی شد. این اشتباه‌ها به‌طور کلی در سه دستهٔ اصلی قرار می‌گیرند:</p>


<li>خطاهای نحوی (Syntax errors): خطاهایی که در آن کد از نظر قواعد پایتون معتبر نیست (معمولاً رفع آن‌ها آسان است).</li>
<li>خطاهای زمان اجرا (Runtime errors): خطاهایی که در آن کد از نظر نحوی معتبر است اما هنگام اجرا با شکست مواجه می‌شود، معمولاً به‌دلیل ورودی نامعتبر کاربر (گاهی رفع آن‌ها آسان است).</li>
<li>خطاهای معنایی (Semantic errors): خطاهای منطقی؛ کد بدون مشکل اجرا می‌شود، اما نتیجه همان چیزی نیست که انتظار داری (اغلب بسیار سخت برای پیدا کردن و رفع کردن).</li>

<br>
<p>در اینجا قرار است روی نحوهٔ مدیریت صحیح خطاهای زمان اجرا تمرکز کنیم. همان‌طور که خواهیم دید، پایتون خطاهای زمان اجرا را از طریق چارچوب مدیریت استثناها (exception handling) کنترل می‌کند.</p>


<h2>خطاهای زمان اجرا</h2>


<p>اگر تا به حال در پایتون کدنویسی کرده باشی، احتمالاً با خطاهای زمان اجرا مواجه شده‌ای. این خطاها می‌توانند به روش‌های مختلفی رخ دهند.</p>


<p>برای مثال، اگر تلاش کنی به یک متغیر تعریف‌نشده ارجاع بدهی:</p>


<pre dir=ltr>
<font color=white>
print(Q)
</pre>


<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<'ipython-input-3-e796bdcf24ff'> in <'module'>()
----> 1 print(Q)

NameError: name 'Q' is not defined
</pre>


<p>یا اگر عملیاتی را انجام دهی که تعریف نشده است:</p>



<pre dir=ltr>
<font color=white>
1 + 'abc'
</pre>



<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<'ipython-input-4-aab9e8ede4f7'> in <'module'>()
----> 1 1 + 'abc'

TypeError: unsupported operand type(s) for +: 'int' and 'str'
</pre>


<p>یا ممکن است بخواهی نتیجه‌ای را محاسبه کنی که از نظر ریاضی تعریف نشده است:</p>


<pre dir=ltr>
<font color=white>
2 / 0
</pre>


<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
ZeroDivisionError                         Traceback (most recent call last)
<'ipython-input-5-ae0c5d243292'> in <'module'>()
----> 1 2 / 0

ZeroDivisionError: division by zero
</pre>


<p>یا شاید بخواهی به عنصری از یک دنباله دسترسی پیدا کنی که وجود ندارد:</p>


<pre dir=ltr>
<font color=white>
L = [1, 2, 3]
L[1000]
</pre>


<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<'ipython-input-6-06b6eb1b8957'> in <'module'>()
      1 L = [1, 2, 3]
----> 2 L[1000]

IndexError: list index out of range
</pre>


<p>توجه داشته باش که در هر یک از این موارد، پایتون به‌قدری «مهربان» است که تنها اعلام خطا نمی‌کند، بلکه یک استثنای معنادار (meaningful exception) صادر می‌کند که شامل اطلاعاتی دربارهٔ اینکه دقیقاً چه چیزی اشتباه شده و کدام خط کد باعث وقوع خطا شده است، می‌باشد. دسترسی به خطاهای معناداری از این دست هنگام پی‌گیری ریشهٔ مشکلات در کد، فوق‌العاده مفید است.</p>


<h2>دستگیری استثناها: بلوک try و except</h2>


<p>ابزار اصلی که پایتون برای مدیریت استثناهای زمان اجرا در اختیار شما می‌گذارد، عبارت try…except است. ساختار پایهٔ آن به صورت زیر است:</p>


<pre dir=ltr>
<font color=white>
try:
    print("this gets executed first")
except:
    print("this gets executed only if there is an error")
</pre>
<p dir=ltr>this gets executed first</p>


<p>توجه داشته باش که بلوک دوم در اینجا اجرا نشد: دلیل آن این است که بلوک اول هیچ خطایی برنگرداند. بیایید یک دستور مشکل‌دار در بلوک try قرار دهیم و ببینیم چه اتفاقی می‌افتد:</p>


<pre dir=ltr>
<font color=white>
try:
    print("let's try something:")
    x = 1 / 0 # ZeroDivisionError
except:
    print("something bad happened!")
</pre>
<p dir=ltr>let's try something:<br>
something bad happened!</p>


<p>در اینجا می‌بینیم که وقتی خطا در دستور try رخ داد (در این مثال، یک ZeroDivisionError)، خطا گرفته شد و بلوک except اجرا شد.</p>


<p>یکی از کاربردهای رایج این روش، بررسی ورودی کاربر در یک تابع یا بخش دیگری از کد است. برای مثال، ممکن است بخواهیم تابعی داشته باشیم که خطای تقسیم بر صفر را بگیرد و به جای آن مقدار دیگری بازگرداند، مثلاً یک عدد نسبتاً بزرگ مانند...</p>


<pre dir=ltr>
<font color=white>
def safe_divide(a, b):
    try:
        return a / b
    except:
        return 1E100
</pre>


<pre dir=ltr>
<font color=white>
safe_divide(1, 2)
</pre>
<p dir=ltr>0.5</p>


<pre dir=ltr>
<font color=white>
safe_divide(2, 0)
</pre>
<p dir=ltr>1e+100</p>


<p>با این حال، یک مشکل ظریف در این کد وجود دارد: وقتی نوع دیگری از استثنا رخ دهد، چه اتفاقی می‌افتد؟ برای مثال، احتمالاً این همان چیزی نیست که ما مد نظر داشتیم:</p>


<pre dir=ltr>
<font color=white>
safe_divide (1, '2')
</pre>
<p dir=ltr>1e+100</p>


<p>تقسیم یک عدد صحیح بر یک رشته باعث ایجاد TypeError می‌شود، اما کد ما با بیش‌روی این خطا را گرفت و فرض کرد که ZeroDivisionError است! به همین دلیل، تقریباً همیشه بهتر است استثناها را به‌طور صریح مدیریت کنیم:</p>



<pre dir=ltr>
<font color=white>
def safe_divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        return 1E100
</pre>


<pre dir=ltr>
<font color=white>
safe_divide(1, 0)
</pre>
<p dir=ltr>1e+100</p>


<pre dir=ltr>
<font color=white>
safe_divide(1, '2')
</pre>


<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<'ipython-input-15-2331af6a0acf'> in <'module'>()
----> 1 safe_divide(1, '2')

<'ipython-input-13-10b5f0163af8'> in safe_divide(a, b)
      1 def safe_divide(a, b):
      2     try:
----> 3         return a / b
      4     except ZeroDivisionError:
      5         return 1E100

TypeError: unsupported operand type(s) for /: 'int' and 'str'
</pre>


<p>اکنون ما تنها خطاهای تقسیم بر صفر را می‌گیریم و اجازه می‌دهیم تمام خطاهای دیگر بدون تغییر عبور کنند.</p>


<h2>ایجاد استثناها: دستور raise</h2>


<p>دیدیم که داشتن استثناهای اطلاع‌رسان هنگام استفاده از بخش‌های زبان پایتون چقدر ارزشمند است. به همان اندازه، استفاده از استثناهای اطلاع‌رسان در کدی که خودتان می‌نویسید نیز مهم است، تا کاربران کد شما (و در درجهٔ اول خودتان!) بتوانند بفهمند چه چیزی باعث خطا شده است.</p>


<p>روش ایجاد استثناهای دلخواه خود، استفاده از دستور raise است. برای مثال:</p>


<pre dir=ltr>
<font color=white>
raise RuntimeError("my error message")
</pre>


<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
<'ipython-input-16-c6a4c1ed2f34'> in <'module'>()
----> 1 raise RuntimeError("my error message")

RuntimeError: my error message
</pre>


<p>به‌عنوان نمونه‌ای از جایی که این کار می‌تواند مفید باشد، بیایید به تابع فیبوناچی خود که قبلاً تعریف کردیم بازگردیم:</p>


<pre dir=ltr>
<font color=white>
def fibonacci(N):
    L = []
    a, b = 0, 1
    while len(L) < N:
        a, b = b, a + b
        L.append(a)
    return L
</pre>


<p>یکی از مشکلات احتمالی در اینجا این است که مقدار ورودی می‌تواند منفی باشد. در حال حاضر این موضوع هیچ خطایی در تابع ما ایجاد نمی‌کند، اما ممکن است بخواهیم به کاربر اطلاع دهیم که مقدار منفی برای N پشتیبانی نمی‌شود. بر اساس قرارداد، خطاهایی که ناشی از مقادیر نامعتبر پارامترها هستند، معمولاً با ایجاد ValueError مشخص می‌شوند:</p>


<pre dir=ltr>
<font color=white>
def fibonacci(N):
    if N < 0:
        raise ValueError("N must be non-negative")
    L = []
    a, b = 0, 1
    while len(L) < N:
        a, b = b, a + b
        L.append(a)
    return L
</pre>


<pre dir=ltr>
<font color=white>
fibonacci(10)
</pre>
<p dir=ltr>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</p>


<pre dir=ltr>
<font color=white>
fibonacci(-10)
</pre>


<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<'ipython-input-20-3d291499cfa7'> in <'module'>()
----> 1 fibonacci(-10)

<'ipython-input-18-01d0cf168d63'> in fibonacci(N)
      1 def fibonacci(N):
      2     if N < 0:
----> 3         raise ValueError("N must be non-negative")
      4     L = []
      5     a, b = 0, 1

ValueError: N must be non-negative
</pre>


<p>اکنون کاربر دقیقاً می‌داند چرا ورودی نامعتبر است و حتی می‌تواند از بلوک try…except برای مدیریت آن استفاده کند!</p>


<pre dir=ltr>
<font color=white>
N = -10
try:
    print("trying this...")
    print(fibonacci(N))
except ValueError:
    print("Bad value: need to do something else")
</pre>
<p dir=ltr>trying this...<br>
Bad value: need to do something else</p>


<h2>بررسی عمیق‌تر استثناها</h2>


<p>به‌طور کوتاه، می‌خواهم برخی مفاهیم دیگر را که ممکن است با آن‌ها برخورد کنید، ذکر کنم. من وارد جزئیات این مفاهیم و چگونگی و چرایی استفاده از آن‌ها نمی‌شوم، بلکه صرفاً نحو (syntax) آن‌ها را نشان می‌دهم تا خودتان بتوانید بیشتر کاوش کنید.</p>


<h3>دسترسی به پیام خطا</h3>


<p>گاهی اوقات در یک بلوک try…except، ممکن است بخواهید خود پیام خطا را مدیریت کنید. این کار با استفاده از کلیدواژه as امکان‌پذیر است:</p>


<pre dir=ltr>
<font color=white>
try:
    x = 1 / 0
except ZeroDivisionError as err:
    print("Error class is:  ", type(err))
    print("Error message is:", err)
</pre>
<p dir=ltr>Error class is:   <'class' 'ZeroDivisionError'> <br>
Error message is: division by zero</p>


<p>با استفاده از این الگو، می‌توانید مدیریت استثنا در تابع خود را به‌طور بیشتری شخصی‌سازی کنید.</p>


<h3>تعریف استثناهای سفارشی</h3>


<p>علاوه بر استثناهای داخلی، می‌توان استثناهای سفارشی را از طریق وراثت کلاس تعریف کرد. برای مثال، اگر بخواهید نوع خاصی از ValueError داشته باشید، می‌توانید به این شکل عمل کنید:</p>


<pre dir=ltr>
<font color=white>
class MySpecialError(ValueError):
    pass

raise MySpecialError("here's the message")
</pre>


<pre dir=ltr>
<font color=white>
---------------------------------------------------------------------------
MySpecialError                            Traceback (most recent call last)
<'ipython-input-23-92c36e04a9d0'> in <'module'>()
      2     pass
      3 
----> 4 raise MySpecialError("here's the message")

MySpecialError: here's the message
</pre>


<p>این امکان را به شما می‌دهد که از یک بلوک try…except استفاده کنید که تنها این نوع خطا را بگیرد:</p>


<pre dir=ltr>
<font color=white>
try:
    print("do something")
    raise MySpecialError("[informative error message here]")
except MySpecialError:
    print("do something else")
</pre>
<p dir=ltr>do something<br>
do something else</p>


<p>ممکن است این برایتان مفید باشد، به‌ویژه زمانی که در حال توسعه کدهای سفارشی‌تر هستید.</p>


<h2>try...except...else...finally</h2>


<p>علاوه بر try و except، می‌توانید از کلیدواژه‌های else و finally برای تنظیم دقیق‌تر مدیریت استثناها در کد خود استفاده کنید. ساختار پایهٔ آن به صورت زیر است:</p>


<pre dir=ltr>
<font color=white>
try:
    print("try something here")
except:
    print("this happens only if it fails")
else:
    print("this happens only if it succeeds")
finally:
    print("this happens no matter what")
</pre>
<p dir=ltr>try something here<br>
this happens only if it succeeds<br>
this happens no matter what</p>


<p>کاربرد else در اینجا واضح است، اما هدف از finally چیست؟ در واقع، بلوک finally بدون توجه به شرایط اجرا می‌شود: معمولاً از آن برای انجام برخی عملیات پاک‌سازی پس از اتمام یک عملیات استفاده می‌شود.</p>



|
<a href="09-تعریف توابع.md">تغریف توابع</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="11-پیمایشگرها.md">پیمایشگرها</a>
|



</div>