<div dir=rtl>

|
<a href="05-معناشناسی پایتون: عملگرها.md">معناشناسی پایتون: عملگرها</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="07-ساختارهای داده داخلی.md">ساختارهای داده داخلی</a>
|


<h1>نوع‌های داخلی: مقادیر ساده</h1>


<p>هنگام بحث درباره متغیرها و اشیاء پایتون، اشاره کردیم که همه اشیاء پایتون دارای اطلاعات نوع هستند. در اینجا به‌طور مختصر به نوع‌های ساده‌ی داخلی ارائه‌شده توسط پایتون می‌پردازیم. از عبارت «نوع‌های ساده» استفاده می‌کنیم تا آن‌ها را با چند نوع مرکب که در بخش بعدی بررسی خواهند شد، متمایز کنیم.</p>


<p>نوع‌های ساده پایتون در جدول زیر خلاصه شده‌اند:</p>


<p><b>نوع‌های اسکالر پایتون</b></p>


<table>
    <tr>
        <th>نوع</th>
        <th>مثال</th>
        <th>توضیح</th>
    </tr>
    <tr>
        <td>int</td>
        <td>x = 1</td>
        <td>اعداد صحیح (یعنی اعداد بدون قسمت اعشاری)</td>
    </tr>
    <tr>
        <td>float</td>
        <td>x = 1.0</td>
        <td>اعداد ممیز شناور (یعنی اعداد حقیقی)</td>
    </tr>
    <tr>
        <td>complex</td>
        <td>x = 1 + 2j</td>
        <td>اعداد مختلط (یعنی اعدادی با بخش‌های حقیقی و موهومی)</td>
    </tr>
    <tr>
        <td>bool</td>
        <td>x = True</td>
        <td>بولین: مقادیر True/False</td>
    </tr>
    <tr>
        <td>str</td>
        <td>x = 'abc'</td>
        <td>رشته (String): کاراکترها یا متن</td>
    </tr>
    <tr>
        <td>NoneType</td>
        <td>x = None</td>
        <td>شیء ویژه‌ای که نشان‌دهنده مقدار تهی (null) است.</td>
    </tr>
</table>


<p>به‌صورت مختصر هر یک از این‌ها را به نوبت بررسی خواهیم کرد.</p>


<h2>Integers</h2>

<p>ابتدایی‌ترین نوع عددی در پایتون عدد صحیح (Integer) است. هر عددی که نقطهٔ اعشار نداشته باشد، یک عدد صحیح محسوب می‌شود:</p>


<pre dir=ltr>
<font color=white>
x = 1
type(x)
</pre>
<p dir=ltr>int</p>


<p>اعداد صحیح در پایتون در واقع بسیار پیچیده‌تر از اعداد صحیح در زبان‌هایی مانند C هستند. اعداد صحیح در زبان C دارای دقت ثابت هستند و معمولاً در یک مقدار مشخص سرریز می‌شوند. (معمولاً نزدیک به 2<sup>63</sup> یا 2<sup>31</sup> ،بسته به سیستم شما) اعداد صحیح در پایتون دارای دقت متغیر هستند، بنابراین می‌توانید محاسباتی انجام دهید که در سایر زبان‌ها باعث سرریز می‌شوند:</p>


<pre dir=ltr>
<font color=white>
2 ** 200
</pre>
<p dir=ltr>1606938044258990275541962092341162602522202993782792835301376</p>


<p>ویژگی دیگر اعداد صحیح در پایتون این است که به‌طور پیش‌فرض، عملیات تقسیم، نتیجه را به نوع عدد اعشاری (float) تبدیل می‌کند:</p>


<pre dir=ltr>
<font color=white>
5 / 2
</pre>
<p dir=ltr>2.5</p>


<p>توجه داشته باشید که این تبدیل خودکار (upcasting) ویژگی پایتون ۳ است؛ در پایتون ۲، مشابه بسیاری از زبان‌های دارای نوع ثابت مثل C، تقسیم اعداد صحیح هر قسمت اعشاری را حذف می‌کند و همیشه یک عدد صحیح برمی‌گرداند:</p>


<pre dir=ltr>
<font color=white>
# Python 2 behavior
>>> 5 / 2
</pre>
<p dir=ltr>2</p>


<p>برای بازیابی این رفتار در پایتون ۳، می‌توانید از عملگر تقسیم کف (floor-division) استفاده کنید:</p>



<pre dir=ltr>
<font color=white>
5 // 2
</pre>
<p dir=ltr>2</p>


<p>در نهایت، توجه داشته باشید که اگرچه پایتون ۲.x هم نوع int و هم نوع long داشت، پایتون ۳ رفتار این دو نوع را در یک نوع واحد به نام int ترکیب کرده است.</p>


<h2>اعداد اعشاری (Floating-Point Numbers)</h2>


<p>نوع اعشاری (float) می‌تواند اعداد کسری را ذخیره کند. این اعداد را می‌توان به‌صورت نوشتار دهدهی استاندارد یا نوشتار نمایی (exponential) تعریف کرد:</p>


<pre dir=ltr>
<font color=white>
x = 0.000005
y = 5e-6
print(x == y)
</pre>
<p dir=ltr>True</p>


<pre dir=ltr>
<font color=white>
x = 1400000.00
y = 1.4e6
print(x == y)
</pre>
<p dir=ltr>True</p>


<p>در نوشتار نمایی، نماد e یا E به‌صورت «ضرب در ده به توان ...» خوانده می‌شود، بنابراین 1.4e6 به‌صورت زیر تفسیر می‌شود:

1.4 * 10<sup>6</sup></p>


<p>یک عدد صحیح می‌تواند به‌صورت صریح با استفاده از سازنده‌ی float به عدد اعشاری تبدیل شود:</p>


<pre dir=ltr>
<font color=white>
float(1)
</pre>
<p dir=ltr>1.0</p>


<h2>توضیح جانبی: دقت اعداد اعشاری (Floating-point)</h2>


<p>یکی از مواردی که باید در محاسبات اعشاری (floating-point) به آن توجه داشت، محدودیت دقت آن است که می‌تواند باعث ناپایداری در آزمون‌های برابری شود. برای مثال:</p>


<pre dir=ltr>
<font color=white>
0.1 + 0.2 == 0.3
</pre>
<p dir=ltr>False</p>


<p>چرا چنین است؟ مشخص می‌شود که این رفتار منحصر به پایتون نیست، بلکه به دلیل فرمت با دقت ثابت ذخیره‌سازی اعشاری دودویی است که در بیشتر، اگر نگوییم تمام، پلتفرم‌های محاسبات علمی استفاده می‌شود. تمام زبان‌های برنامه‌نویسی که از اعداد اعشاری استفاده می‌کنند، آن‌ها را در تعداد ثابتی بیت ذخیره می‌کنند و این باعث می‌شود برخی اعداد تنها به‌طور تقریبی نمایش داده شوند. می‌توان این موضوع را با چاپ سه مقدار با دقت بالا مشاهده کرد:</p>


<pre dir=ltr>
<font color=white>
print("0.1 = {0:.17f}".format(0.1))
print("0.2 = {0:.17f}".format(0.2))
print("0.3 = {0:.17f}".format(0.3))
</pre>
<p dir=ltr>0.1 = 0.10000000000000001<br>
0.2 = 0.20000000000000001<br>
0.3 = 0.29999999999999999</p>


<p>ما عادت داریم اعداد را به صورت ده‌دهی (مبنای ۱۰) در نظر بگیریم، به طوری که هر کسر باید به صورت مجموع توان‌های ۱۰ بیان شود:</p>


<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mn>1</mn>
  <mrow data-mjx-texclass="ORD">
    <mo>/</mo>
  </mrow>
  <mn>8</mn>
  <mo>=</mo>
  <mn>1</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>10</mn>
    <mrow data-mjx-texclass="ORD">
      <mo>&#x2212;</mo>
      <mn>1</mn>
    </mrow>
  </msup>
  <mo>+</mo>
  <mn>2</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>10</mn>
    <mrow data-mjx-texclass="ORD">
      <mo>&#x2212;</mo>
      <mn>2</mn>
    </mrow>
  </msup>
  <mo>+</mo>
  <mn>5</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>10</mn>
    <mrow data-mjx-texclass="ORD">
      <mo>&#x2212;</mo>
      <mn>3</mn>
    </mrow>
  </msup>
</math>

<br>
<p>در نمایش آشنا به صورت مبنای ۱۰، این را به شکل عدد ده‌دهی معمول نمایش می‌دهیم: 0.125</p>


<p>رایانه‌ها معمولاً مقادیر را به صورت دودویی ذخیره می‌کنند، به‌طوری که هر عدد به شکل مجموع توان‌های ۲ نمایش داده می‌شود:</p>


<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mn>1</mn>
  <mrow data-mjx-texclass="ORD">
    <mo>/</mo>
  </mrow>
  <mn>8</mn>
  <mo>=</mo>
  <mn>0</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>2</mn>
    <mrow data-mjx-texclass="ORD">
      <mo>&#x2212;</mo>
      <mn>1</mn>
    </mrow>
  </msup>
  <mo>+</mo>
  <mn>0</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>2</mn>
    <mrow data-mjx-texclass="ORD">
      <mo>&#x2212;</mo>
      <mn>2</mn>
    </mrow>
  </msup>
  <mo>+</mo>
  <mn>1</mn>
  <mo>&#x22C5;</mo>
  <msup>
    <mn>2</mn>
    <mrow data-mjx-texclass="ORD">
      <mo>&#x2212;</mo>
      <mn>3</mn>
    </mrow>
  </msup>
</math>
<br>


<p>در نمایش پایه-۲، می‌توانیم این را به صورت <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mn>0.001</mn>
    <mn>2</mn>
  </msub>
</math> بنویسیم، که اندیس ۲ نشان‌دهنده‌ی سیستم دودویی است.
مقدار <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mn>0.125</mn>
  <mo>=</mo>
  <msub>
    <mn>0.001</mn>
    <mn>2</mn>
  </msub>
</math> یکی از اعدادی است که هم در نمایش دودویی و هم در نمایش دهدهی می‌تواند با تعداد محدودی رقم نشان داده شود.
</p>


<p>در نمایش آشنای اعداد در پایه ۱۰، احتمالاً با اعدادی آشنا هستید که نمی‌توان آن‌ها را با تعداد محدودی رقم نشان داد.
برای مثال، تقسیم 1 بر 3 در نمایش دهدهی استاندارد به صورت زیر است:
</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mn>1</mn>
  <mrow data-mjx-texclass="ORD">
    <mo>/</mo>
  </mrow>
  <mn>3</mn>
  <mo>=</mo>
  <mn>0.333333333</mn>
  <mo>&#x22EF;</mo>
</math>

<br>
<p>اعداد ۳ ادامه پیدا می‌کنند و بی‌نهایت هستند؛ یعنی برای نمایش دقیق این خارج قسمت، تعداد ارقام لازم بی‌نهایت است!</p>


<p>به‌طور مشابه، اعدادی وجود دارند که نمایش باینری آن‌ها نیاز به تعداد بی‌نهایت بیت دارد. برای مثال:</p>


<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mn>1</mn>
  <mrow data-mjx-texclass="ORD">
    <mo>/</mo>
  </mrow>
  <mn>10</mn>
  <mo>=</mo>
  <mn>0.00011001100110011</mn>
  <msub>
    <mo>&#x22EF;</mo>
    <mn>2</mn>
  </msub>
</math>

<br>


<p>همان‌طور که نمایش ده‌دهی برای نمایش دقیق <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mn>1</mn>
  <mrow data-mjx-texclass="ORD">
    <mo>/</mo>
  </mrow>
  <mn>3</mn>
</math> نیاز به تعداد بی‌نهایت رقم دارد، نمایش باینری نیز برای نمایش <math xmlns="http://www.w3.org/1998/Math/MathML">
  <mn>1</mn>
  <mrow data-mjx-texclass="ORD">
    <mo>/</mo>
  </mrow>
  <mn>10</mn>
</math> نیاز به تعداد بی‌نهایت بیت دارد. پایتون در اکثر سیستم‌ها این نمایش‌ها را به صورت داخلی تا ۵۲ بیت پس از اولین بیت غیرصفر کوتاه می‌کند.
</p>



<p>این خطای گرد کردن برای اعداد شناور، بخش اجتناب‌ناپذیر کار با اعداد اعشاری است. بهترین روش برای مدیریت آن این است که همیشه به یاد داشته باشید حساب‌های اعشاری تقریبی هستند و هرگز نباید به آزمون برابری دقیق برای اعداد شناور اعتماد کنید.</p>


<h2>اعداد مختلط</h2>


<p>اعداد مختلط، اعدادی هستند که شامل بخش حقیقی و بخش موهومی (شناور) می‌شوند. پیش‌تر با اعداد صحیح و اعداد حقیقی آشنا شدیم؛ می‌توانیم از این اعداد برای ساخت یک عدد مختلط استفاده کنیم:</p>



<pre dir=ltr>
<font color=white>
complex(1, 2)
</pre>
<p dir=ltr>(1+2j)</p>


<p>به‌طور جایگزین، می‌توانیم از پسوند "j" در عبارات استفاده کنیم تا بخش موهومی عدد را مشخص کنیم:</p>


<pre dir=ltr>
<font color=white>
1 + 2j
</pre>
<p dir=ltr>(1+2j)</p>


<p>اعداد مختلط دارای ویژگی‌ها و متدهای متنوعی هستند که در اینجا به‌طور مختصر آن‌ها را نشان خواهیم داد:</p>


<pre dir=ltr>
<font color=white>
c = 3 + 4j
</pre>


<pre dir=ltr>
<font color=white>
c.real  # real part
</pre>
<p dir=ltr>3.0</p>


<pre dir=ltr>
<font color=white>
c.imag  # imaginary part
</pre>
<p dir=ltr>4.0</p>


<pre dir=ltr>
<font color=white>
c.conjugate()  # complex conjugate
</pre>
<p dir=ltr>(3-4j)</p>


<pre dir=ltr>
<font color=white>
abs(c)  # magnitude, i.e. sqrt(c.real ** 2 + c.imag ** 2)
</pre>
<p dir=ltr>5.0</p>


<h2>نوع داده رشته (String)</h2>


<p>رشته‌ها در پایتون با استفاده از کوتیشن تکی (' ') یا دوتایی (" ") ساخته می‌شوند:</p>



<pre dir=ltr>
<font color=white>
message = "what do you like?"
response = 'spam'
</pre>

<p>پایتون دارای توابع و متدهای بسیار مفید برای کار با رشته‌ها است؛ در اینجا به برخی از آن‌ها اشاره می‌کنیم:</p>


<pre dir=ltr>
<font color=white>
# length of string
len(response)
</pre>
<p dir=ltr>4</p>


<pre dir=ltr>
<font color=white>
# Make upper-case. See also str.lower()
response.upper()
</pre>
<p dir=ltr>'SPAM'</p>


<pre dir=ltr>
<font color=white>
# Capitalize. See also str.title()
message.capitalize()
</pre>
<p dir=ltr>'What do you like?'</p>


<pre dir=ltr>
<font color=white>
# concatenation with +
message + response
</pre>
<p dir=ltr>'what do you like?spam'</p>


<pre dir=ltr>
<font color=white>
# multiplication is multiple concatenation
5 * response
</pre>
<p dir=ltr>'spamspamspamspamspam'</p>


<pre dir=ltr>
<font color=white>
# Access individual characters (zero-based indexing)
message[0]
</pre>
<p dir=ltr>'w'</p>


<p>برای بحث بیشتر در مورد اندیس‌گذاری در پایتون، به بخش <a href="07-ساختارهای داده داخلی.md">لیست ها</a> مراجعه کنید.</p>



<h2>نوع None</h2>

<p>پایتون شامل یک نوع ویژه به نام NoneType است که تنها یک مقدار ممکن دارد: None.

 برای مثال:</p>

<pre dir=ltr>
<font color=white>
type(None)
</pre>
<p dir=ltr>NoneType</p>


<p>شما None را در بسیاری از مواقع خواهید دید، اما معمولاً رایج‌ترین استفاده آن به‌عنوان مقدار پیش‌فرض بازگشتی یک تابع است. برای مثال، تابع <span dir=ltr>print()</span> در پایتون ۳ هیچ مقداری برنمی‌گرداند، اما هنوز می‌توانیم مقدار آن را دریافت کنیم:</p>


<pre dir=ltr>
<font color=white>
return_value = print('abc')
</pre>
<p dir=ltr>abc</p>



<pre dir=ltr>
<font color=white>
print(return_value)
</pre>
<p dir=ltr>None</p>


<p>به همین ترتیب، هر تابعی در پایتون که مقداری باز نمی‌گرداند، در واقع None را برمی‌گرداند.</p>


<h2>نوع Boolean</h2>


<p>نوع Boolean یک نوع ساده است که تنها دو مقدار ممکن دارد: True و False، و این نوع معمولاً توسط عملگرهای مقایسه‌ای که پیش‌تر بحث شد، بازگردانده می‌شود.</p>



<pre dir=ltr>
<font color=white>
result = (4 < 5)
result
</pre>
<p dir=ltr>True</p>


<pre dir=ltr>
<font color=white>
type(result)
</pre>
<p dir=ltr>bool</p>


<p>به خاطر داشته باشید که مقادیر Boolean حساس به حروف بزرگ و کوچک هستند: برخلاف برخی زبان‌های دیگر، باید حتماً True و False با حرف بزرگ نوشته شوند!</p>



<pre dir=ltr>
<font color=white>
print(True, False)
</pre>
<p dir=ltr>True False</p>


<p>همچنین می‌توان مقادیر Boolean را با استفاده از سازنده شیء bool() ساخت: مقادیر هر نوع دیگری را می‌توان طبق قواعد قابل پیش‌بینی به Boolean تبدیل کرد. به عنوان مثال، هر نوع عددی اگر برابر صفر باشد، مقدار آن False و در غیر این صورت True خواهد بود:</p>



<pre dir=ltr>
<font color=white>
bool(2014)
</pre>
<p dir=ltr>True</p>


<pre dir=ltr>
<font color=white>
bool(0)
</pre>
<p dir=ltr>False</p>


<pre dir=ltr>
<font color=white>
bool(3.1415)
</pre>
<p dir=ltr>True</p>


<p>تبدیل Boolean برای مقدار None همیشه False است:</p>


<pre dir=ltr>
<font color=white>
bool(None)
</pre>
<p dir=ltr>False</p>


<p>برای رشته‌ها، bool(s) برای رشته‌های خالی False و برای رشته‌های غیرخالی True است:</p>


<pre dir=ltr>
<font color=white>
bool("")
</pre>
<p dir=ltr>False</p>


<pre dir=ltr>
<font color=white>
bool("abc")
</pre>
<p dir=ltr>True</p>


<p>برای دنباله‌ها، که در بخش بعدی با آن‌ها آشنا می‌شویم، نمایش بولی False برای دنباله‌های خالی و True برای هر دنبالهٔ غیرخالی است.</p>


<pre dir=ltr>
<font color=white>
bool([1, 2, 3])
</pre>
<p dir=ltr>True</p>


<pre dir=ltr>
<font color=white>
bool([])
</pre>
<p dir=ltr>False</p>




|
<a href="05-معناشناسی پایتون: عملگرها.md">معناشناسی پایتون: عملگرها</a>
|
<a href="00-فهرست.md">فهرست</a>
|
<a href="07-ساختارهای داده داخلی.md">ساختارهای داده داخلی</a>
|



</div>